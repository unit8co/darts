
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sklearn.multioutput &#8212; darts  documentation</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet">
  <link href="../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/blank.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="shortcut icon" href="../../_static/docs-favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../index.html">
  <img src="../../_static/darts-logo-trim.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../README.html">
  Home
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../quickstart/00-quickstart.html">
  Quickstart
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../userguide.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../generated_api/darts.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../examples.html">
  Examples
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/unit8co/darts" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/unit8co" rel="noopener" target="_blank" title="Twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for sklearn.multioutput</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module implements multioutput regression and classification.</span>

<span class="sd">The estimators provided in this module are meta-estimators: they require</span>
<span class="sd">a base estimator to be provided in their constructor. The meta-estimator</span>
<span class="sd">extends single output estimators to multioutput estimators.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Author: Tim Head &lt;betatim@gmail.com&gt;</span>
<span class="c1"># Author: Hugo Bowne-Anderson &lt;hugobowne@gmail.com&gt;</span>
<span class="c1"># Author: Chris Rivera &lt;chris.richard.rivera@gmail.com&gt;</span>
<span class="c1"># Author: Michael Williamson</span>
<span class="c1"># Author: James Ashton Nichols &lt;james.ashton.nichols@gmail.com&gt;</span>
<span class="c1">#</span>
<span class="c1"># License: BSD 3 clause</span>


<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Integral</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sp</span>

<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">BaseEstimator</span><span class="p">,</span>
    <span class="n">ClassifierMixin</span><span class="p">,</span>
    <span class="n">MetaEstimatorMixin</span><span class="p">,</span>
    <span class="n">RegressorMixin</span><span class="p">,</span>
    <span class="n">_fit_context</span><span class="p">,</span>
    <span class="n">clone</span><span class="p">,</span>
    <span class="n">is_classifier</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_predict</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">Bunch</span><span class="p">,</span> <span class="n">_print_elapsed_time</span><span class="p">,</span> <span class="n">check_random_state</span>
<span class="kn">from</span> <span class="nn">.utils._param_validation</span> <span class="kn">import</span> <span class="n">HasMethods</span><span class="p">,</span> <span class="n">StrOptions</span>
<span class="kn">from</span> <span class="nn">.utils.metadata_routing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">MetadataRouter</span><span class="p">,</span>
    <span class="n">MethodMapping</span><span class="p">,</span>
    <span class="n">_routing_enabled</span><span class="p">,</span>
    <span class="n">process_routing</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.utils.metaestimators</span> <span class="kn">import</span> <span class="n">available_if</span>
<span class="kn">from</span> <span class="nn">.utils.multiclass</span> <span class="kn">import</span> <span class="n">check_classification_targets</span>
<span class="kn">from</span> <span class="nn">.utils.parallel</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">from</span> <span class="nn">.utils.validation</span> <span class="kn">import</span> <span class="n">_check_fit_params</span><span class="p">,</span> <span class="n">check_is_fitted</span><span class="p">,</span> <span class="n">has_fit_parameter</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;MultiOutputRegressor&quot;</span><span class="p">,</span>
    <span class="s2">&quot;MultiOutputClassifier&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ClassifierChain&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RegressorChain&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="k">def</span> <span class="nf">_fit_estimator</span><span class="p">(</span><span class="n">estimator</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">):</span>
    <span class="n">estimator</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="n">estimator</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sample_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">estimator</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">estimator</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">estimator</span>


<span class="k">def</span> <span class="nf">_partial_fit_estimator</span><span class="p">(</span>
    <span class="n">estimator</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">classes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">partial_fit_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">first_time</span><span class="o">=</span><span class="kc">True</span>
<span class="p">):</span>
    <span class="n">partial_fit_params</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">partial_fit_params</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">partial_fit_params</span>
    <span class="k">if</span> <span class="n">first_time</span><span class="p">:</span>
        <span class="n">estimator</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="n">estimator</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">classes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">estimator</span><span class="o">.</span><span class="n">partial_fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">classes</span><span class="o">=</span><span class="n">classes</span><span class="p">,</span> <span class="o">**</span><span class="n">partial_fit_params</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">estimator</span><span class="o">.</span><span class="n">partial_fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">partial_fit_params</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">estimator</span>


<span class="k">def</span> <span class="nf">_available_if_estimator_has</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a function to check if the sub-estimator(s) has(have) `attr`.</span>

<span class="sd">    Helper for Chain implementations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;estimators_&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">est</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">est</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimator</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">available_if</span><span class="p">(</span><span class="n">_check</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_MultiOutputEstimator</span><span class="p">(</span><span class="n">MetaEstimatorMixin</span><span class="p">,</span> <span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="n">_parameter_constraints</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;estimator&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">HasMethods</span><span class="p">([</span><span class="s2">&quot;fit&quot;</span><span class="p">,</span> <span class="s2">&quot;predict&quot;</span><span class="p">])],</span>
        <span class="s2">&quot;n_jobs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">Integral</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
    <span class="p">}</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimator</span> <span class="o">=</span> <span class="n">estimator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span>

    <span class="nd">@_available_if_estimator_has</span><span class="p">(</span><span class="s2">&quot;partial_fit&quot;</span><span class="p">)</span>
    <span class="nd">@_fit_context</span><span class="p">(</span>
        <span class="c1"># MultiOutput*.estimator is not validated yet</span>
        <span class="n">prefer_skip_nested_validation</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">partial_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">classes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">partial_fit_params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Incrementally fit a separate model for each class output.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {array-like, sparse matrix} of shape (n_samples, n_features)</span>
<span class="sd">            The input data.</span>

<span class="sd">        y : {array-like, sparse matrix} of shape (n_samples, n_outputs)</span>
<span class="sd">            Multi-output targets.</span>

<span class="sd">        classes : list of ndarray of shape (n_outputs,), default=None</span>
<span class="sd">            Each array is unique classes for one output in str/int.</span>
<span class="sd">            Can be obtained via</span>
<span class="sd">            ``[np.unique(y[:, i]) for i in range(y.shape[1])]``, where `y`</span>
<span class="sd">            is the target matrix of the entire dataset.</span>
<span class="sd">            This argument is required for the first call to partial_fit</span>
<span class="sd">            and can be omitted in the subsequent calls.</span>
<span class="sd">            Note that `y` doesn&#39;t need to contain all labels in `classes`.</span>

<span class="sd">        sample_weight : array-like of shape (n_samples,), default=None</span>
<span class="sd">            Sample weights. If `None`, then samples are equally weighted.</span>
<span class="sd">            Only supported if the underlying regressor supports sample</span>
<span class="sd">            weights.</span>

<span class="sd">        **partial_fit_params : dict of str -&gt; object</span>
<span class="sd">            Parameters passed to the ``estimator.partial_fit`` method of each</span>
<span class="sd">            sub-estimator.</span>

<span class="sd">            Only available if `enable_metadata_routing=True`. See the</span>
<span class="sd">            :ref:`User Guide &lt;metadata_routing&gt;`.</span>

<span class="sd">            .. versionadded:: 1.3</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : object</span>
<span class="sd">            Returns a fitted instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">partial_fit_params</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_routing_enabled</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;partial_fit_params is only supported if enable_metadata_routing=True.&quot;</span>
                <span class="s2">&quot; See the User Guide for more information.&quot;</span>
            <span class="p">)</span>

        <span class="n">first_time</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;estimators_&quot;</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="s2">&quot;no_validation&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">multi_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;y must have at least two dimensions for &quot;</span>
                <span class="s2">&quot;multi-output regression but has only one.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">_routing_enabled</span><span class="p">():</span>
            <span class="n">routed_params</span> <span class="o">=</span> <span class="n">process_routing</span><span class="p">(</span>
                <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;partial_fit&quot;</span><span class="p">,</span>
                <span class="n">other_params</span><span class="o">=</span><span class="n">partial_fit_params</span><span class="p">,</span>
                <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sample_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_fit_parameter</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">estimator</span><span class="p">,</span> <span class="s2">&quot;sample_weight&quot;</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Underlying estimator does not support sample weights.&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">sample_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">routed_params</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span>
                    <span class="n">estimator</span><span class="o">=</span><span class="n">Bunch</span><span class="p">(</span><span class="n">partial_fit</span><span class="o">=</span><span class="n">Bunch</span><span class="p">(</span><span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">routed_params</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="n">estimator</span><span class="o">=</span><span class="n">Bunch</span><span class="p">(</span><span class="n">partial_fit</span><span class="o">=</span><span class="n">Bunch</span><span class="p">()))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">_partial_fit_estimator</span><span class="p">)(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">first_time</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimator</span><span class="p">,</span>
                <span class="n">X</span><span class="p">,</span>
                <span class="n">y</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                <span class="n">classes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">classes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">partial_fit_params</span><span class="o">=</span><span class="n">routed_params</span><span class="o">.</span><span class="n">estimator</span><span class="o">.</span><span class="n">partial_fit</span><span class="p">,</span>
                <span class="n">first_time</span><span class="o">=</span><span class="n">first_time</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">first_time</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;n_features_in_&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_features_in_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n_features_in_</span>
        <span class="k">if</span> <span class="n">first_time</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;feature_names_in_&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">feature_names_in_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">feature_names_in_</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@_fit_context</span><span class="p">(</span>
        <span class="c1"># MultiOutput*.estimator is not validated yet</span>
        <span class="n">prefer_skip_nested_validation</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit the model to data, separately for each output variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {array-like, sparse matrix} of shape (n_samples, n_features)</span>
<span class="sd">            The input data.</span>

<span class="sd">        y : {array-like, sparse matrix} of shape (n_samples, n_outputs)</span>
<span class="sd">            Multi-output targets. An indicator matrix turns on multilabel</span>
<span class="sd">            estimation.</span>

<span class="sd">        sample_weight : array-like of shape (n_samples,), default=None</span>
<span class="sd">            Sample weights. If `None`, then samples are equally weighted.</span>
<span class="sd">            Only supported if the underlying regressor supports sample</span>
<span class="sd">            weights.</span>

<span class="sd">        **fit_params : dict of string -&gt; object</span>
<span class="sd">            Parameters passed to the ``estimator.fit`` method of each step.</span>

<span class="sd">            .. versionadded:: 0.23</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : object</span>
<span class="sd">            Returns a fitted instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimator</span><span class="p">,</span> <span class="s2">&quot;fit&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The base estimator should implement a fit method&quot;</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="s2">&quot;no_validation&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">multi_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_classifier</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">check_classification_targets</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;y must have at least two dimensions for &quot;</span>
                <span class="s2">&quot;multi-output regression but has only one.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">_routing_enabled</span><span class="p">():</span>
            <span class="n">routed_params</span> <span class="o">=</span> <span class="n">process_routing</span><span class="p">(</span>
                <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fit&quot;</span><span class="p">,</span>
                <span class="n">other_params</span><span class="o">=</span><span class="n">fit_params</span><span class="p">,</span>
                <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sample_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_fit_parameter</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">estimator</span><span class="p">,</span> <span class="s2">&quot;sample_weight&quot;</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Underlying estimator does not support sample weights.&quot;</span>
                <span class="p">)</span>

            <span class="n">fit_params_validated</span> <span class="o">=</span> <span class="n">_check_fit_params</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fit_params</span><span class="p">)</span>
            <span class="n">routed_params</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="n">estimator</span><span class="o">=</span><span class="n">Bunch</span><span class="p">(</span><span class="n">fit</span><span class="o">=</span><span class="n">fit_params_validated</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">sample_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">routed_params</span><span class="o">.</span><span class="n">estimator</span><span class="o">.</span><span class="n">fit</span><span class="p">[</span><span class="s2">&quot;sample_weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_weight</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">_fit_estimator</span><span class="p">)(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">estimator</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">routed_params</span><span class="o">.</span><span class="n">estimator</span><span class="o">.</span><span class="n">fit</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;n_features_in_&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_features_in_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n_features_in_</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;feature_names_in_&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">feature_names_in_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">feature_names_in_</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Predict multi-output variable using model for each target variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {array-like, sparse matrix} of shape (n_samples, n_features)</span>
<span class="sd">            The input data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : {array-like, sparse matrix} of shape (n_samples, n_outputs)</span>
<span class="sd">            Multi-output targets predicted across multiple predictors.</span>
<span class="sd">            Note: Separate models are generated for each predictor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;predict&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The base estimator should implement a predict method&quot;</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">predict</span><span class="p">)(</span><span class="n">X</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">def</span> <span class="nf">_more_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;multioutput_only&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">get_metadata_routing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get metadata routing of this object.</span>

<span class="sd">        Please check :ref:`User Guide &lt;metadata_routing&gt;` on how the routing</span>
<span class="sd">        mechanism works.</span>

<span class="sd">        .. versionadded:: 1.3</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        routing : MetadataRouter</span>
<span class="sd">            A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating</span>
<span class="sd">            routing information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">router</span> <span class="o">=</span> <span class="n">MetadataRouter</span><span class="p">(</span><span class="n">owner</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
            <span class="n">estimator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">estimator</span><span class="p">,</span>
            <span class="n">method_mapping</span><span class="o">=</span><span class="n">MethodMapping</span><span class="p">()</span>
            <span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">callee</span><span class="o">=</span><span class="s2">&quot;partial_fit&quot;</span><span class="p">,</span> <span class="n">caller</span><span class="o">=</span><span class="s2">&quot;partial_fit&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">callee</span><span class="o">=</span><span class="s2">&quot;fit&quot;</span><span class="p">,</span> <span class="n">caller</span><span class="o">=</span><span class="s2">&quot;fit&quot;</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">router</span>


<span class="k">class</span> <span class="nc">MultiOutputRegressor</span><span class="p">(</span><span class="n">RegressorMixin</span><span class="p">,</span> <span class="n">_MultiOutputEstimator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Multi target regression.</span>

<span class="sd">    This strategy consists of fitting one regressor per target. This is a</span>
<span class="sd">    simple strategy for extending regressors that do not natively support</span>
<span class="sd">    multi-target regression.</span>

<span class="sd">    .. versionadded:: 0.18</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    estimator : estimator object</span>
<span class="sd">        An estimator object implementing :term:`fit` and :term:`predict`.</span>

<span class="sd">    n_jobs : int or None, optional (default=None)</span>
<span class="sd">        The number of jobs to run in parallel.</span>
<span class="sd">        :meth:`fit`, :meth:`predict` and :meth:`partial_fit` (if supported</span>
<span class="sd">        by the passed estimator) will be parallelized for each target.</span>

<span class="sd">        When individual estimators are fast to train or predict,</span>
<span class="sd">        using ``n_jobs &gt; 1`` can result in slower performance due</span>
<span class="sd">        to the parallelism overhead.</span>

<span class="sd">        ``None`` means `1` unless in a :obj:`joblib.parallel_backend` context.</span>
<span class="sd">        ``-1`` means using all available processes / threads.</span>
<span class="sd">        See :term:`Glossary &lt;n_jobs&gt;` for more details.</span>

<span class="sd">        .. versionchanged:: 0.20</span>
<span class="sd">            `n_jobs` default changed from `1` to `None`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    estimators_ : list of ``n_output`` estimators</span>
<span class="sd">        Estimators used for predictions.</span>

<span class="sd">    n_features_in_ : int</span>
<span class="sd">        Number of features seen during :term:`fit`. Only defined if the</span>
<span class="sd">        underlying `estimator` exposes such an attribute when fit.</span>

<span class="sd">        .. versionadded:: 0.24</span>

<span class="sd">    feature_names_in_ : ndarray of shape (`n_features_in_`,)</span>
<span class="sd">        Names of features seen during :term:`fit`. Only defined if the</span>
<span class="sd">        underlying estimators expose such an attribute when fit.</span>

<span class="sd">        .. versionadded:: 1.0</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    RegressorChain : A multi-label model that arranges regressions into a</span>
<span class="sd">        chain.</span>
<span class="sd">    MultiOutputClassifier : Classifies each output independently rather than</span>
<span class="sd">        chaining.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.datasets import load_linnerud</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.multioutput import MultiOutputRegressor</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.linear_model import Ridge</span>
<span class="sd">    &gt;&gt;&gt; X, y = load_linnerud(return_X_y=True)</span>
<span class="sd">    &gt;&gt;&gt; regr = MultiOutputRegressor(Ridge(random_state=123)).fit(X, y)</span>
<span class="sd">    &gt;&gt;&gt; regr.predict(X[[0]])</span>
<span class="sd">    array([[176..., 35..., 57...]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">estimator</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>

<div class="viewcode-block" id="MultiOutputRegressor.partial_fit"><a class="viewcode-back" href="../../generated_api/darts.utils.multioutput.html#darts.utils.multioutput.MultiOutputRegressor.partial_fit">[docs]</a>    <span class="nd">@_available_if_estimator_has</span><span class="p">(</span><span class="s2">&quot;partial_fit&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">partial_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">partial_fit_params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Incrementally fit the model to data, for each output variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {array-like, sparse matrix} of shape (n_samples, n_features)</span>
<span class="sd">            The input data.</span>

<span class="sd">        y : {array-like, sparse matrix} of shape (n_samples, n_outputs)</span>
<span class="sd">            Multi-output targets.</span>

<span class="sd">        sample_weight : array-like of shape (n_samples,), default=None</span>
<span class="sd">            Sample weights. If `None`, then samples are equally weighted.</span>
<span class="sd">            Only supported if the underlying regressor supports sample</span>
<span class="sd">            weights.</span>

<span class="sd">        **partial_fit_params : dict of str -&gt; object</span>
<span class="sd">            Parameters passed to the ``estimator.partial_fit`` method of each</span>
<span class="sd">            sub-estimator.</span>

<span class="sd">            Only available if `enable_metadata_routing=True`. See the</span>
<span class="sd">            :ref:`User Guide &lt;metadata_routing&gt;`.</span>

<span class="sd">            .. versionadded:: 1.3</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : object</span>
<span class="sd">            Returns a fitted instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">partial_fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">,</span> <span class="o">**</span><span class="n">partial_fit_params</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">MultiOutputClassifier</span><span class="p">(</span><span class="n">ClassifierMixin</span><span class="p">,</span> <span class="n">_MultiOutputEstimator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Multi target classification.</span>

<span class="sd">    This strategy consists of fitting one classifier per target. This is a</span>
<span class="sd">    simple strategy for extending classifiers that do not natively support</span>
<span class="sd">    multi-target classification.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    estimator : estimator object</span>
<span class="sd">        An estimator object implementing :term:`fit` and :term:`predict`.</span>
<span class="sd">        A :term:`predict_proba` method will be exposed only if `estimator` implements</span>
<span class="sd">        it.</span>

<span class="sd">    n_jobs : int or None, optional (default=None)</span>
<span class="sd">        The number of jobs to run in parallel.</span>
<span class="sd">        :meth:`fit`, :meth:`predict` and :meth:`partial_fit` (if supported</span>
<span class="sd">        by the passed estimator) will be parallelized for each target.</span>

<span class="sd">        When individual estimators are fast to train or predict,</span>
<span class="sd">        using ``n_jobs &gt; 1`` can result in slower performance due</span>
<span class="sd">        to the parallelism overhead.</span>

<span class="sd">        ``None`` means `1` unless in a :obj:`joblib.parallel_backend` context.</span>
<span class="sd">        ``-1`` means using all available processes / threads.</span>
<span class="sd">        See :term:`Glossary &lt;n_jobs&gt;` for more details.</span>

<span class="sd">        .. versionchanged:: 0.20</span>
<span class="sd">            `n_jobs` default changed from `1` to `None`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    classes_ : ndarray of shape (n_classes,)</span>
<span class="sd">        Class labels.</span>

<span class="sd">    estimators_ : list of ``n_output`` estimators</span>
<span class="sd">        Estimators used for predictions.</span>

<span class="sd">    n_features_in_ : int</span>
<span class="sd">        Number of features seen during :term:`fit`. Only defined if the</span>
<span class="sd">        underlying `estimator` exposes such an attribute when fit.</span>

<span class="sd">        .. versionadded:: 0.24</span>

<span class="sd">    feature_names_in_ : ndarray of shape (`n_features_in_`,)</span>
<span class="sd">        Names of features seen during :term:`fit`. Only defined if the</span>
<span class="sd">        underlying estimators expose such an attribute when fit.</span>

<span class="sd">        .. versionadded:: 1.0</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ClassifierChain : A multi-label model that arranges binary classifiers</span>
<span class="sd">        into a chain.</span>
<span class="sd">    MultiOutputRegressor : Fits one regressor per target variable.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.datasets import make_multilabel_classification</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.multioutput import MultiOutputClassifier</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.linear_model import LogisticRegression</span>
<span class="sd">    &gt;&gt;&gt; X, y = make_multilabel_classification(n_classes=3, random_state=0)</span>
<span class="sd">    &gt;&gt;&gt; clf = MultiOutputClassifier(LogisticRegression()).fit(X, y)</span>
<span class="sd">    &gt;&gt;&gt; clf.predict(X[-2:])</span>
<span class="sd">    array([[1, 1, 1],</span>
<span class="sd">           [1, 0, 1]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">estimator</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit the model to data matrix X and targets Y.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {array-like, sparse matrix} of shape (n_samples, n_features)</span>
<span class="sd">            The input data.</span>

<span class="sd">        Y : array-like of shape (n_samples, n_classes)</span>
<span class="sd">            The target values.</span>

<span class="sd">        sample_weight : array-like of shape (n_samples,), default=None</span>
<span class="sd">            Sample weights. If `None`, then samples are equally weighted.</span>
<span class="sd">            Only supported if the underlying classifier supports sample</span>
<span class="sd">            weights.</span>

<span class="sd">        **fit_params : dict of string -&gt; object</span>
<span class="sd">            Parameters passed to the ``estimator.fit`` method of each step.</span>

<span class="sd">            .. versionadded:: 0.23</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : object</span>
<span class="sd">            Returns a fitted instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classes_</span> <span class="o">=</span> <span class="p">[</span><span class="n">estimator</span><span class="o">.</span><span class="n">classes_</span> <span class="k">for</span> <span class="n">estimator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_check_predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;estimators_&quot;</span><span class="p">):</span>
            <span class="c1"># raise an AttributeError if `predict_proba` does not exist for</span>
            <span class="c1"># each estimator</span>
            <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">est</span><span class="p">,</span> <span class="s2">&quot;predict_proba&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">est</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">]</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="c1"># raise an AttributeError if `predict_proba` does not exist for the</span>
        <span class="c1"># unfitted estimator</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimator</span><span class="p">,</span> <span class="s2">&quot;predict_proba&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@available_if</span><span class="p">(</span><span class="n">_check_predict_proba</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return prediction probabilities for each class of each output.</span>

<span class="sd">        This method will raise a ``ValueError`` if any of the</span>
<span class="sd">        estimators do not have ``predict_proba``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like of shape (n_samples, n_features)</span>
<span class="sd">            The input data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        p : array of shape (n_samples, n_classes), or a list of n_outputs \</span>
<span class="sd">                such arrays if n_outputs &gt; 1.</span>
<span class="sd">            The class probabilities of the input samples. The order of the</span>
<span class="sd">            classes corresponds to that in the attribute :term:`classes_`.</span>

<span class="sd">            .. versionchanged:: 0.19</span>
<span class="sd">                This function now returns a list of arrays where the length of</span>
<span class="sd">                the list is ``n_outputs``, and each array is (``n_samples``,</span>
<span class="sd">                ``n_classes``) for that particular output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">estimator</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="k">for</span> <span class="n">estimator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the mean accuracy on the given test data and labels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like of shape (n_samples, n_features)</span>
<span class="sd">            Test samples.</span>

<span class="sd">        y : array-like of shape (n_samples, n_outputs)</span>
<span class="sd">            True values for X.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scores : float</span>
<span class="sd">            Mean accuracy of predicted target versus true target.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">n_outputs_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;y must have at least two dimensions for &quot;</span>
                <span class="s2">&quot;multi target classification but has only one&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_outputs_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The number of outputs of Y for fit </span><span class="si">{0}</span><span class="s2"> and&quot;</span>
                <span class="s2">&quot; score </span><span class="si">{1}</span><span class="s2"> should be same&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_outputs_</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_more_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># FIXME</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;_skip_test&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">_available_if_base_estimator_has</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a function to check if `base_estimator` or `estimators_` has `attr`.</span>

<span class="sd">    Helper for Chain implementations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_estimator</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">est</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">est</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">available_if</span><span class="p">(</span><span class="n">_check</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_BaseChain</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="n">_parameter_constraints</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;base_estimator&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">HasMethods</span><span class="p">([</span><span class="s2">&quot;fit&quot;</span><span class="p">,</span> <span class="s2">&quot;predict&quot;</span><span class="p">])],</span>
        <span class="s2">&quot;order&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;array-like&quot;</span><span class="p">,</span> <span class="n">StrOptions</span><span class="p">({</span><span class="s2">&quot;random&quot;</span><span class="p">}),</span> <span class="kc">None</span><span class="p">],</span>
        <span class="s2">&quot;cv&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;cv_object&quot;</span><span class="p">,</span> <span class="n">StrOptions</span><span class="p">({</span><span class="s2">&quot;prefit&quot;</span><span class="p">})],</span>
        <span class="s2">&quot;random_state&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;random_state&quot;</span><span class="p">],</span>
        <span class="s2">&quot;verbose&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;boolean&quot;</span><span class="p">],</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">base_estimator</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_estimator</span> <span class="o">=</span> <span class="n">base_estimator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv</span> <span class="o">=</span> <span class="n">cv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

    <span class="k">def</span> <span class="nf">_log_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">estimator_idx</span><span class="p">,</span> <span class="n">n_estimators</span><span class="p">,</span> <span class="n">processing_msg</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">estimator_idx</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">n_estimators</span><span class="si">}</span><span class="s2">) </span><span class="si">{</span><span class="n">processing_msg</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit the model to data matrix X and targets Y.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {array-like, sparse matrix} of shape (n_samples, n_features)</span>
<span class="sd">            The input data.</span>

<span class="sd">        Y : array-like of shape (n_samples, n_classes)</span>
<span class="sd">            The target values.</span>

<span class="sd">        **fit_params : dict of string -&gt; object</span>
<span class="sd">            Parameters passed to the `fit` method of each step.</span>

<span class="sd">            .. versionadded:: 0.23</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : object</span>
<span class="sd">            Returns a fitted instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">multi_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">random_state</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">order_</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid order&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span> <span class="o">=</span> <span class="p">[</span><span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_estimator</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Y_pred_chain</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                <span class="n">X_aug</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Y_pred_chain</span><span class="p">),</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;lil&quot;</span><span class="p">)</span>
                <span class="n">X_aug</span> <span class="o">=</span> <span class="n">X_aug</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">X_aug</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Y_pred_chain</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
            <span class="n">Y_pred_chain</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">X_aug</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Y_pred_chain</span><span class="p">),</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;lil&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">Y_pred_chain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">X_aug</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Y_pred_chain</span><span class="p">))</span>

        <span class="k">del</span> <span class="n">Y_pred_chain</span>

        <span class="k">if</span> <span class="n">_routing_enabled</span><span class="p">():</span>
            <span class="n">routed_params</span> <span class="o">=</span> <span class="n">process_routing</span><span class="p">(</span>
                <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fit&quot;</span><span class="p">,</span> <span class="n">other_params</span><span class="o">=</span><span class="n">fit_params</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">routed_params</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="n">estimator</span><span class="o">=</span><span class="n">Bunch</span><span class="p">(</span><span class="n">fit</span><span class="o">=</span><span class="n">fit_params</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">chain_idx</span><span class="p">,</span> <span class="n">estimator</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">):</span>
            <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_message</span><span class="p">(</span>
                <span class="n">estimator_idx</span><span class="o">=</span><span class="n">chain_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">n_estimators</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">),</span>
                <span class="n">processing_msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Processing order </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">order_</span><span class="p">[</span><span class="n">chain_idx</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_</span><span class="p">[</span><span class="n">chain_idx</span><span class="p">]]</span>
            <span class="k">with</span> <span class="n">_print_elapsed_time</span><span class="p">(</span><span class="s2">&quot;Chain&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
                <span class="n">estimator</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
                    <span class="n">X_aug</span><span class="p">[:,</span> <span class="p">:</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">chain_idx</span><span class="p">)],</span>
                    <span class="n">y</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">routed_params</span><span class="o">.</span><span class="n">estimator</span><span class="o">.</span><span class="n">fit</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">chain_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">col_idx</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">chain_idx</span>
                <span class="n">cv_result</span> <span class="o">=</span> <span class="n">cross_val_predict</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">base_estimator</span><span class="p">,</span> <span class="n">X_aug</span><span class="p">[:,</span> <span class="p">:</span><span class="n">col_idx</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">X_aug</span><span class="p">):</span>
                    <span class="n">X_aug</span><span class="p">[:,</span> <span class="n">col_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">cv_result</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">X_aug</span><span class="p">[:,</span> <span class="n">col_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">cv_result</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Predict on the data matrix X using the ClassifierChain model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {array-like, sparse matrix} of shape (n_samples, n_features)</span>
<span class="sd">            The input data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Y_pred : array-like of shape (n_samples, n_classes)</span>
<span class="sd">            The predicted values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">Y_pred_chain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">chain_idx</span><span class="p">,</span> <span class="n">estimator</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">):</span>
            <span class="n">previous_predictions</span> <span class="o">=</span> <span class="n">Y_pred_chain</span><span class="p">[:,</span> <span class="p">:</span><span class="n">chain_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">chain_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">X_aug</span> <span class="o">=</span> <span class="n">X</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">X_aug</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">previous_predictions</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">X_aug</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">previous_predictions</span><span class="p">))</span>
            <span class="n">Y_pred_chain</span><span class="p">[:,</span> <span class="n">chain_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_aug</span><span class="p">)</span>

        <span class="n">inv_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_</span><span class="p">)</span>
        <span class="n">inv_order</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">order_</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_</span><span class="p">))</span>
        <span class="n">Y_pred</span> <span class="o">=</span> <span class="n">Y_pred_chain</span><span class="p">[:,</span> <span class="n">inv_order</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">Y_pred</span>


<span class="k">class</span> <span class="nc">ClassifierChain</span><span class="p">(</span><span class="n">MetaEstimatorMixin</span><span class="p">,</span> <span class="n">ClassifierMixin</span><span class="p">,</span> <span class="n">_BaseChain</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A multi-label model that arranges binary classifiers into a chain.</span>

<span class="sd">    Each model makes a prediction in the order specified by the chain using</span>
<span class="sd">    all of the available features provided to the model plus the predictions</span>
<span class="sd">    of models that are earlier in the chain.</span>

<span class="sd">    For an example of how to use ``ClassifierChain`` and benefit from its</span>
<span class="sd">    ensemble, see</span>
<span class="sd">    :ref:`ClassifierChain on a yeast dataset</span>
<span class="sd">    &lt;sphx_glr_auto_examples_multioutput_plot_classifier_chain_yeast.py&gt;` example.</span>

<span class="sd">    Read more in the :ref:`User Guide &lt;classifierchain&gt;`.</span>

<span class="sd">    .. versionadded:: 0.19</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    base_estimator : estimator</span>
<span class="sd">        The base estimator from which the classifier chain is built.</span>

<span class="sd">    order : array-like of shape (n_outputs,) or &#39;random&#39;, default=None</span>
<span class="sd">        If `None`, the order will be determined by the order of columns in</span>
<span class="sd">        the label matrix Y.::</span>

<span class="sd">            order = [0, 1, 2, ..., Y.shape[1] - 1]</span>

<span class="sd">        The order of the chain can be explicitly set by providing a list of</span>
<span class="sd">        integers. For example, for a chain of length 5.::</span>

<span class="sd">            order = [1, 3, 2, 4, 0]</span>

<span class="sd">        means that the first model in the chain will make predictions for</span>
<span class="sd">        column 1 in the Y matrix, the second model will make predictions</span>
<span class="sd">        for column 3, etc.</span>

<span class="sd">        If order is `random` a random ordering will be used.</span>

<span class="sd">    cv : int, cross-validation generator or an iterable, default=None</span>
<span class="sd">        Determines whether to use cross validated predictions or true</span>
<span class="sd">        labels for the results of previous estimators in the chain.</span>
<span class="sd">        Possible inputs for cv are:</span>

<span class="sd">        - None, to use true labels when fitting,</span>
<span class="sd">        - integer, to specify the number of folds in a (Stratified)KFold,</span>
<span class="sd">        - :term:`CV splitter`,</span>
<span class="sd">        - An iterable yielding (train, test) splits as arrays of indices.</span>

<span class="sd">    random_state : int, RandomState instance or None, optional (default=None)</span>
<span class="sd">        If ``order=&#39;random&#39;``, determines random number generation for the</span>
<span class="sd">        chain order.</span>
<span class="sd">        In addition, it controls the random seed given at each `base_estimator`</span>
<span class="sd">        at each chaining iteration. Thus, it is only used when `base_estimator`</span>
<span class="sd">        exposes a `random_state`.</span>
<span class="sd">        Pass an int for reproducible output across multiple function calls.</span>
<span class="sd">        See :term:`Glossary &lt;random_state&gt;`.</span>

<span class="sd">    verbose : bool, default=False</span>
<span class="sd">        If True, chain progress is output as each model is completed.</span>

<span class="sd">        .. versionadded:: 1.2</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    classes_ : list</span>
<span class="sd">        A list of arrays of length ``len(estimators_)`` containing the</span>
<span class="sd">        class labels for each estimator in the chain.</span>

<span class="sd">    estimators_ : list</span>
<span class="sd">        A list of clones of base_estimator.</span>

<span class="sd">    order_ : list</span>
<span class="sd">        The order of labels in the classifier chain.</span>

<span class="sd">    n_features_in_ : int</span>
<span class="sd">        Number of features seen during :term:`fit`. Only defined if the</span>
<span class="sd">        underlying `base_estimator` exposes such an attribute when fit.</span>

<span class="sd">        .. versionadded:: 0.24</span>

<span class="sd">    feature_names_in_ : ndarray of shape (`n_features_in_`,)</span>
<span class="sd">        Names of features seen during :term:`fit`. Defined only when `X`</span>
<span class="sd">        has feature names that are all strings.</span>

<span class="sd">        .. versionadded:: 1.0</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    RegressorChain : Equivalent for regression.</span>
<span class="sd">    MultiOutputClassifier : Classifies each output independently rather than</span>
<span class="sd">        chaining.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Jesse Read, Bernhard Pfahringer, Geoff Holmes, Eibe Frank, &quot;Classifier</span>
<span class="sd">    Chains for Multi-label Classification&quot;, 2009.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.datasets import make_multilabel_classification</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.linear_model import LogisticRegression</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.model_selection import train_test_split</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.multioutput import ClassifierChain</span>
<span class="sd">    &gt;&gt;&gt; X, Y = make_multilabel_classification(</span>
<span class="sd">    ...    n_samples=12, n_classes=3, random_state=0</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; X_train, X_test, Y_train, Y_test = train_test_split(</span>
<span class="sd">    ...    X, Y, random_state=0</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; base_lr = LogisticRegression(solver=&#39;lbfgs&#39;, random_state=0)</span>
<span class="sd">    &gt;&gt;&gt; chain = ClassifierChain(base_lr, order=&#39;random&#39;, random_state=0)</span>
<span class="sd">    &gt;&gt;&gt; chain.fit(X_train, Y_train).predict(X_test)</span>
<span class="sd">    array([[1., 1., 0.],</span>
<span class="sd">           [1., 0., 0.],</span>
<span class="sd">           [0., 1., 0.]])</span>
<span class="sd">    &gt;&gt;&gt; chain.predict_proba(X_test)</span>
<span class="sd">    array([[0.8387..., 0.9431..., 0.4576...],</span>
<span class="sd">           [0.8878..., 0.3684..., 0.2640...],</span>
<span class="sd">           [0.0321..., 0.9935..., 0.0625...]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@_fit_context</span><span class="p">(</span>
        <span class="c1"># ClassifierChain.base_estimator is not validated yet</span>
        <span class="n">prefer_skip_nested_validation</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit the model to data matrix X and targets Y.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {array-like, sparse matrix} of shape (n_samples, n_features)</span>
<span class="sd">            The input data.</span>

<span class="sd">        Y : array-like of shape (n_samples, n_classes)</span>
<span class="sd">            The target values.</span>

<span class="sd">        **fit_params : dict of string -&gt; object</span>
<span class="sd">            Parameters passed to the `fit` method of each step.</span>

<span class="sd">            Only available if `enable_metadata_routing=True`. See the</span>
<span class="sd">            :ref:`User Guide &lt;metadata_routing&gt;`.</span>

<span class="sd">            .. versionadded:: 1.3</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : object</span>
<span class="sd">            Class instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fit_params</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_routing_enabled</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;fit_params is only supported if enable_metadata_routing=True. &quot;</span>
                <span class="s2">&quot;See the User Guide for more information.&quot;</span>
            <span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classes_</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">estimator</span><span class="o">.</span><span class="n">classes_</span> <span class="k">for</span> <span class="n">chain_idx</span><span class="p">,</span> <span class="n">estimator</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@_available_if_base_estimator_has</span><span class="p">(</span><span class="s2">&quot;predict_proba&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Predict probability estimates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {array-like, sparse matrix} of shape (n_samples, n_features)</span>
<span class="sd">            The input data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Y_prob : array-like of shape (n_samples, n_classes)</span>
<span class="sd">            The predicted probabilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">Y_prob_chain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">)))</span>
        <span class="n">Y_pred_chain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">chain_idx</span><span class="p">,</span> <span class="n">estimator</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">):</span>
            <span class="n">previous_predictions</span> <span class="o">=</span> <span class="n">Y_pred_chain</span><span class="p">[:,</span> <span class="p">:</span><span class="n">chain_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                <span class="n">X_aug</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">previous_predictions</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">X_aug</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">previous_predictions</span><span class="p">))</span>
            <span class="n">Y_prob_chain</span><span class="p">[:,</span> <span class="n">chain_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_aug</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">Y_pred_chain</span><span class="p">[:,</span> <span class="n">chain_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_aug</span><span class="p">)</span>
        <span class="n">inv_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_</span><span class="p">)</span>
        <span class="n">inv_order</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">order_</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_</span><span class="p">))</span>
        <span class="n">Y_prob</span> <span class="o">=</span> <span class="n">Y_prob_chain</span><span class="p">[:,</span> <span class="n">inv_order</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">Y_prob</span>

    <span class="nd">@_available_if_base_estimator_has</span><span class="p">(</span><span class="s2">&quot;decision_function&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">decision_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate the decision_function of the models in the chain.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like of shape (n_samples, n_features)</span>
<span class="sd">            The input data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Y_decision : array-like of shape (n_samples, n_classes)</span>
<span class="sd">            Returns the decision function of the sample for each model</span>
<span class="sd">            in the chain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">Y_decision_chain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">)))</span>
        <span class="n">Y_pred_chain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">chain_idx</span><span class="p">,</span> <span class="n">estimator</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimators_</span><span class="p">):</span>
            <span class="n">previous_predictions</span> <span class="o">=</span> <span class="n">Y_pred_chain</span><span class="p">[:,</span> <span class="p">:</span><span class="n">chain_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                <span class="n">X_aug</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">previous_predictions</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">X_aug</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">previous_predictions</span><span class="p">))</span>
            <span class="n">Y_decision_chain</span><span class="p">[:,</span> <span class="n">chain_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">X_aug</span><span class="p">)</span>
            <span class="n">Y_pred_chain</span><span class="p">[:,</span> <span class="n">chain_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_aug</span><span class="p">)</span>

        <span class="n">inv_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_</span><span class="p">)</span>
        <span class="n">inv_order</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">order_</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_</span><span class="p">))</span>
        <span class="n">Y_decision</span> <span class="o">=</span> <span class="n">Y_decision_chain</span><span class="p">[:,</span> <span class="n">inv_order</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">Y_decision</span>

    <span class="k">def</span> <span class="nf">get_metadata_routing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get metadata routing of this object.</span>

<span class="sd">        Please check :ref:`User Guide &lt;metadata_routing&gt;` on how the routing</span>
<span class="sd">        mechanism works.</span>

<span class="sd">        .. versionadded:: 1.3</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        routing : MetadataRouter</span>
<span class="sd">            A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating</span>
<span class="sd">            routing information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">router</span> <span class="o">=</span> <span class="n">MetadataRouter</span><span class="p">(</span><span class="n">owner</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
            <span class="n">estimator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_estimator</span><span class="p">,</span>
            <span class="n">method_mapping</span><span class="o">=</span><span class="n">MethodMapping</span><span class="p">()</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">callee</span><span class="o">=</span><span class="s2">&quot;fit&quot;</span><span class="p">,</span> <span class="n">caller</span><span class="o">=</span><span class="s2">&quot;fit&quot;</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">router</span>

    <span class="k">def</span> <span class="nf">_more_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;_skip_test&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;multioutput_only&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>


<span class="k">class</span> <span class="nc">RegressorChain</span><span class="p">(</span><span class="n">MetaEstimatorMixin</span><span class="p">,</span> <span class="n">RegressorMixin</span><span class="p">,</span> <span class="n">_BaseChain</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A multi-label model that arranges regressions into a chain.</span>

<span class="sd">    Each model makes a prediction in the order specified by the chain using</span>
<span class="sd">    all of the available features provided to the model plus the predictions</span>
<span class="sd">    of models that are earlier in the chain.</span>

<span class="sd">    Read more in the :ref:`User Guide &lt;regressorchain&gt;`.</span>

<span class="sd">    .. versionadded:: 0.20</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    base_estimator : estimator</span>
<span class="sd">        The base estimator from which the regressor chain is built.</span>

<span class="sd">    order : array-like of shape (n_outputs,) or &#39;random&#39;, default=None</span>
<span class="sd">        If `None`, the order will be determined by the order of columns in</span>
<span class="sd">        the label matrix Y.::</span>

<span class="sd">            order = [0, 1, 2, ..., Y.shape[1] - 1]</span>

<span class="sd">        The order of the chain can be explicitly set by providing a list of</span>
<span class="sd">        integers. For example, for a chain of length 5.::</span>

<span class="sd">            order = [1, 3, 2, 4, 0]</span>

<span class="sd">        means that the first model in the chain will make predictions for</span>
<span class="sd">        column 1 in the Y matrix, the second model will make predictions</span>
<span class="sd">        for column 3, etc.</span>

<span class="sd">        If order is &#39;random&#39; a random ordering will be used.</span>

<span class="sd">    cv : int, cross-validation generator or an iterable, default=None</span>
<span class="sd">        Determines whether to use cross validated predictions or true</span>
<span class="sd">        labels for the results of previous estimators in the chain.</span>
<span class="sd">        Possible inputs for cv are:</span>

<span class="sd">        - None, to use true labels when fitting,</span>
<span class="sd">        - integer, to specify the number of folds in a (Stratified)KFold,</span>
<span class="sd">        - :term:`CV splitter`,</span>
<span class="sd">        - An iterable yielding (train, test) splits as arrays of indices.</span>

<span class="sd">    random_state : int, RandomState instance or None, optional (default=None)</span>
<span class="sd">        If ``order=&#39;random&#39;``, determines random number generation for the</span>
<span class="sd">        chain order.</span>
<span class="sd">        In addition, it controls the random seed given at each `base_estimator`</span>
<span class="sd">        at each chaining iteration. Thus, it is only used when `base_estimator`</span>
<span class="sd">        exposes a `random_state`.</span>
<span class="sd">        Pass an int for reproducible output across multiple function calls.</span>
<span class="sd">        See :term:`Glossary &lt;random_state&gt;`.</span>

<span class="sd">    verbose : bool, default=False</span>
<span class="sd">        If True, chain progress is output as each model is completed.</span>

<span class="sd">        .. versionadded:: 1.2</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    estimators_ : list</span>
<span class="sd">        A list of clones of base_estimator.</span>

<span class="sd">    order_ : list</span>
<span class="sd">        The order of labels in the classifier chain.</span>

<span class="sd">    n_features_in_ : int</span>
<span class="sd">        Number of features seen during :term:`fit`. Only defined if the</span>
<span class="sd">        underlying `base_estimator` exposes such an attribute when fit.</span>

<span class="sd">        .. versionadded:: 0.24</span>

<span class="sd">    feature_names_in_ : ndarray of shape (`n_features_in_`,)</span>
<span class="sd">        Names of features seen during :term:`fit`. Defined only when `X`</span>
<span class="sd">        has feature names that are all strings.</span>

<span class="sd">        .. versionadded:: 1.0</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ClassifierChain : Equivalent for classification.</span>
<span class="sd">    MultiOutputRegressor : Learns each output independently rather than</span>
<span class="sd">        chaining.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.multioutput import RegressorChain</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.linear_model import LogisticRegression</span>
<span class="sd">    &gt;&gt;&gt; logreg = LogisticRegression(solver=&#39;lbfgs&#39;,multi_class=&#39;multinomial&#39;)</span>
<span class="sd">    &gt;&gt;&gt; X, Y = [[1, 0], [0, 1], [1, 1]], [[0, 2], [1, 1], [2, 0]]</span>
<span class="sd">    &gt;&gt;&gt; chain = RegressorChain(base_estimator=logreg, order=[0, 1]).fit(X, Y)</span>
<span class="sd">    &gt;&gt;&gt; chain.predict(X)</span>
<span class="sd">    array([[0., 2.],</span>
<span class="sd">           [1., 1.],</span>
<span class="sd">           [2., 0.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@_fit_context</span><span class="p">(</span>
        <span class="c1"># RegressorChain.base_estimator is not validated yet</span>
        <span class="n">prefer_skip_nested_validation</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit the model to data matrix X and targets Y.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {array-like, sparse matrix} of shape (n_samples, n_features)</span>
<span class="sd">            The input data.</span>

<span class="sd">        Y : array-like of shape (n_samples, n_classes)</span>
<span class="sd">            The target values.</span>

<span class="sd">        **fit_params : dict of string -&gt; object</span>
<span class="sd">            Parameters passed to the `fit` method at each step</span>
<span class="sd">            of the regressor chain.</span>

<span class="sd">            .. versionadded:: 0.23</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : object</span>
<span class="sd">            Returns a fitted instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">get_metadata_routing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get metadata routing of this object.</span>

<span class="sd">        Please check :ref:`User Guide &lt;metadata_routing&gt;` on how the routing</span>
<span class="sd">        mechanism works.</span>

<span class="sd">        .. versionadded:: 1.3</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        routing : MetadataRouter</span>
<span class="sd">            A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating</span>
<span class="sd">            routing information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">router</span> <span class="o">=</span> <span class="n">MetadataRouter</span><span class="p">(</span><span class="n">owner</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
            <span class="n">estimator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_estimator</span><span class="p">,</span>
            <span class="n">method_mapping</span><span class="o">=</span><span class="n">MethodMapping</span><span class="p">()</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">callee</span><span class="o">=</span><span class="s2">&quot;fit&quot;</span><span class="p">,</span> <span class="n">caller</span><span class="o">=</span><span class="s2">&quot;fit&quot;</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">router</span>

    <span class="k">def</span> <span class="nf">_more_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;multioutput_only&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
</pre></div>

              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2020 - 2023, Unit8 SA (Apache 2.0 License).<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.3.2.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>