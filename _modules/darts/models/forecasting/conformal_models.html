
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>darts.models.forecasting.conformal_models &#8212; darts  documentation</title>
    
  <link href="../../../../_static/css/theme.css" rel="stylesheet">
  <link href="../../../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/css/blank.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    
  <link rel="preload" as="script" href="../../../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <link rel="shortcut icon" href="../../../../_static/docs-favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../../index.html">
  <img src="../../../../_static/darts-logo-trim.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../README.html">
  Home
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../quickstart/00-quickstart.html">
  Quickstart
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../userguide.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../generated_api/darts.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../examples.html">
  Examples
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../release_notes/RELEASE_NOTES.html">
  Release Notes
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/unit8co/darts" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/unit8co" rel="noopener" target="_blank" title="Twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for darts.models.forecasting.conformal_models</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Conformal Models</span>
<span class="sd">----------------</span>

<span class="sd">A collection of conformal prediction models for pre-trained global forecasting models.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">BinaryIO</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">darts.utils.likelihood_models.base</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Likelihood</span><span class="p">,</span>
    <span class="n">LikelihoodType</span><span class="p">,</span>
    <span class="n">quantile_names</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Literal</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">typing_extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Literal</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Self</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">typing_extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Self</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">darts</span><span class="w"> </span><span class="kn">import</span> <span class="n">TimeSeries</span><span class="p">,</span> <span class="n">metrics</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">darts.dataprocessing.pipeline</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">darts.dataprocessing.transformers</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseDataTransformer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">darts.logging</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_logger</span><span class="p">,</span> <span class="n">raise_log</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">darts.metrics.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">METRIC_TYPE</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">darts.models.forecasting.forecasting_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">GlobalForecastingModel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">darts.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">_build_tqdm_iterator</span><span class="p">,</span> <span class="n">_with_sanity_checks</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">darts.utils.historical_forecasts.utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">_adjust_historical_forecasts_time_index</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">darts.utils.timeseries_generation</span><span class="w"> </span><span class="kn">import</span> <span class="n">_build_forecast_series</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">darts.utils.ts_utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">SeriesType</span><span class="p">,</span>
    <span class="n">get_series_seq_type</span><span class="p">,</span>
    <span class="n">series2seq</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">darts.utils.utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">TORCH_AVAILABLE</span><span class="p">,</span>
    <span class="n">_check_quantiles</span><span class="p">,</span>
    <span class="n">generate_index</span><span class="p">,</span>
    <span class="n">n_steps_between</span><span class="p">,</span>
    <span class="n">random_method</span><span class="p">,</span>
    <span class="n">sample_from_quantiles</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">TORCH_AVAILABLE</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">darts.models.forecasting.torch_forecasting_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">TorchForecastingModel</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">TorchForecastingModel</span> <span class="o">=</span> <span class="kc">None</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="ConformalModel"><a class="viewcode-back" href="../../../../generated_api/darts.models.forecasting.conformal_models.html#darts.models.forecasting.conformal_models.ConformalModel">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">ConformalModel</span><span class="p">(</span><span class="n">GlobalForecastingModel</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="nd">@random_method</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">GlobalForecastingModel</span><span class="p">,</span>
        <span class="n">quantiles</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">symmetric</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">cal_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cal_stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">cal_num_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Base Conformal Prediction Model.</span>

<span class="sd">        Base class for any conformal prediction model. A conformal model calibrates the predictions from any</span>
<span class="sd">        pre-trained global forecasting model. It does not have to be trained, and can generate calibrated forecasts</span>
<span class="sd">        directly using the underlying trained forecasting model. Since it is a probabilistic model, you can generate</span>
<span class="sd">        forecasts in two ways (when calling `predict()`, `historical_forecasts()`, ...):</span>

<span class="sd">        - Predict the calibrated quantile intervals directly: Pass parameters `predict_likelihood_parameters=True`, and</span>
<span class="sd">          `num_samples=1` to the forecast method.</span>
<span class="sd">        - Predict stochastic samples from the calibrated quantile intervals: Pass parameters</span>
<span class="sd">          `predict_likelihood_parameters=False`, and `num_samples&gt;&gt;1` to the forecast method.</span>

<span class="sd">        Conformal models can be applied to any of Darts&#39; global forecasting model, as long as the model has been</span>
<span class="sd">        fitted before. In general the workflow of the models to produce one calibrated forecast/prediction is as</span>
<span class="sd">        follows:</span>

<span class="sd">        - Extract a calibration set: The calibration set for each conformal forecast is automatically extracted from</span>
<span class="sd">          the most recent past of your input series relative to the forecast start point. The number of calibration</span>
<span class="sd">          examples (forecast errors / non-conformity scores) to consider can be defined at model creation with</span>
<span class="sd">          parameter `cal_length`. Note that when using `cal_stride&gt;1`, a longer history is required since the</span>
<span class="sd">          calibration examples are generated with stridden historical forecasts.</span>
<span class="sd">        - Generate historical forecasts on the calibration set (using the forecasting model) with a stride `cal_stride`.</span>
<span class="sd">        - Compute the errors/non-conformity scores (specific to each conformal model) on these historical forecasts</span>
<span class="sd">        - Compute the quantile values from the errors / non-conformity scores (using our desired quantiles set at model</span>
<span class="sd">          creation with parameter `quantiles`).</span>
<span class="sd">        - Compute the conformal prediction: Using these quantile values, add calibrated intervals to (or adjust the</span>
<span class="sd">          existing intervals of) the forecasting model&#39;s predictions.</span>

<span class="sd">        Some notes:</span>

<span class="sd">        - When computing `historical_forecasts()`, `backtest()`, `residuals()`, ... the above is applied for each</span>
<span class="sd">          forecast (the forecasting model&#39;s historical forecasts are only generated once for efficiency).</span>
<span class="sd">        - For multi-horizon forecasts, the above is applied for each step in the horizon separately.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model</span>
<span class="sd">            A pre-trained global forecasting model. See the list of models</span>
<span class="sd">            `here &lt;https://unit8co.github.io/darts/#forecasting-models&gt;`_.</span>
<span class="sd">        quantiles</span>
<span class="sd">            A list of quantiles centered around the median `q=0.5` to use. For example quantiles</span>
<span class="sd">            [0.1, 0.2, 0.5, 0.8 0.9] correspond to two intervals with (0.9 - 0.1) = 80%, and (0.8 - 0.2) 60% coverage</span>
<span class="sd">            around the median (model forecast).</span>
<span class="sd">        symmetric</span>
<span class="sd">            Whether to use symmetric non-conformity scores. If `False`, uses asymmetric scores (individual scores</span>
<span class="sd">            for lower- and upper quantile interval bounds).</span>
<span class="sd">        cal_length</span>
<span class="sd">            The number of past forecast errors / non-conformity scores to use as calibration for each conformal</span>
<span class="sd">            forecast (and each step in the horizon). If `None`, considers all scores.</span>
<span class="sd">        cal_stride</span>
<span class="sd">            The stride to apply when computing the historical forecasts and non-conformity scores on the calibration</span>
<span class="sd">            set. The actual conformal forecasts can have a different stride given with parameter `stride` in downstream</span>
<span class="sd">            tasks (e.g. historical forecasts, backtest, ...)</span>
<span class="sd">        cal_num_samples</span>
<span class="sd">            The number of samples to generate for each calibration forecast (if `model` is a probabilistic forecasting</span>
<span class="sd">            model). The non-conformity scores are computed on the quantile values of these forecasts (using quantiles</span>
<span class="sd">            `quantiles`). Uses `1` for deterministic models. The actual conformal forecasts can have a different number</span>
<span class="sd">            of samples given with parameter `num_samples` in downstream tasks (e.g. predict, historical forecasts, ...).</span>
<span class="sd">        random_state</span>
<span class="sd">            Controls the randomness for reproducible forecasting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">GlobalForecastingModel</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">_fit_called</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`model` must be a pre-trained `GlobalForecastingModel`.&quot;</span><span class="p">),</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">_check_quantiles</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cal_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cal_length</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`cal_length` must be `&gt;=1` or `None`.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">cal_stride</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`cal_stride` must be `&gt;=1`.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cal_num_samples</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`cal_num_samples` must be `&gt;=1`.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">add_encoders</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># quantiles and interval setup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quantiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">quantiles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx_median</span> <span class="o">=</span> <span class="n">quantiles</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_interval</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">q_l</span><span class="p">,</span> <span class="n">q_h</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">q_l</span><span class="p">,</span> <span class="n">q_h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">quantiles</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_median</span><span class="p">],</span> <span class="n">quantiles</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx_median</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interval_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">q_high</span> <span class="o">-</span> <span class="n">q_low</span> <span class="k">for</span> <span class="n">q_low</span><span class="p">,</span> <span class="n">q_high</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_interval</span>
        <span class="p">])</span>

        <span class="k">if</span> <span class="n">symmetric</span><span class="p">:</span>
            <span class="c1"># symmetric considers both tails together</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interval_range_sym</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interval_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># asymmetric considers tails separately</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interval_range_sym</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval_range</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symmetric</span> <span class="o">=</span> <span class="n">symmetric</span>

        <span class="c1"># model setup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cal_length</span> <span class="o">=</span> <span class="n">cal_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cal_stride</span> <span class="o">=</span> <span class="n">cal_stride</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cal_num_samples</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">cal_num_samples</span> <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">supports_probabilistic_prediction</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood</span> <span class="o">=</span> <span class="n">Likelihood</span><span class="p">(</span>
            <span class="n">likelihood_type</span><span class="o">=</span><span class="n">LikelihoodType</span><span class="o">.</span><span class="n">Quantile</span><span class="p">,</span>
            <span class="n">parameter_names</span><span class="o">=</span><span class="n">quantile_names</span><span class="p">(</span><span class="n">quantiles</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_called</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="ConformalModel.fit"><a class="viewcode-back" href="../../../../generated_api/darts.models.forecasting.conformal_models.html#darts.models.forecasting.conformal_models.ConformalModel.fit">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">series</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
        <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ConformalModel&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit/train the underlying forecasting model on (potentially multiple) series.</span>

<span class="sd">        Optionally, one or multiple past and/or future covariates series can be provided as well, depending on the</span>
<span class="sd">        forecasting model used. The number of covariates series must match the number of target series.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Conformal Models do not require calling `fit()`, since they use pre-trained global forecasting models.</span>
<span class="sd">        You can call `predict()` directly. Also, make sure that the input series used in `predict()` corresponds to</span>
<span class="sd">        a calibration set, and not the same as used during training with `fit()`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        series</span>
<span class="sd">            One or several target time series. The model will be trained to forecast these time series.</span>
<span class="sd">            The series may or may not be multivariate, but if multiple series are provided</span>
<span class="sd">            they must have the same number of components.</span>
<span class="sd">        past_covariates</span>
<span class="sd">            One or several past-observed covariate time series. These time series will not be forecast, but can</span>
<span class="sd">            be used by some models as an input. The covariate(s) may or may not be multivariate, but if multiple</span>
<span class="sd">            covariates are provided they must have the same number of components. If `past_covariates` is provided,</span>
<span class="sd">            it must contain the same number of series as `series`.</span>
<span class="sd">        future_covariates</span>
<span class="sd">            One or several future-known covariate time series. These time series will not be forecast, but can</span>
<span class="sd">            be used by some models as an input. The covariate(s) may or may not be multivariate, but if multiple</span>
<span class="sd">            covariates are provided they must have the same number of components. If `future_covariates` is provided,</span>
<span class="sd">            it must contain the same number of series as `series`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Optional keyword arguments that will passed to the underlying forecasting model&#39;s `fit()` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self</span>
<span class="sd">            Fitted model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># does not have to be trained, but we allow it for unified API</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">,</span>
            <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
            <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ConformalModel.predict"><a class="viewcode-back" href="../../../../generated_api/darts.models.forecasting.conformal_models.html#darts.models.forecasting.conformal_models.ConformalModel.predict">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">predict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">series</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">predict_likelihood_parameters</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">show_warnings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Forecasts calibrated quantile intervals (or samples from calibrated intervals) for `n` time steps after the</span>
<span class="sd">        end of the `series`.</span>

<span class="sd">        It is important that the input series for prediction correspond to a calibration set - a set different to the</span>
<span class="sd">        series that the underlying forecasting `model` was trained on.</span>

<span class="sd">        Since it is a probabilistic model, you can generate forecasts in two ways:</span>

<span class="sd">        - Predict the calibrated quantile intervals directly: Pass parameters `predict_likelihood_parameters=True`, and</span>
<span class="sd">          `num_samples=1` to the forecast method.</span>
<span class="sd">        - Predict stochastic samples from the calibrated quantile intervals: Pass parameters</span>
<span class="sd">          `predict_likelihood_parameters=False`, and `num_samples&gt;&gt;1` to the forecast method.</span>

<span class="sd">        Under the hood, the simplified workflow to produce one calibrated forecast/prediction for every step in the</span>
<span class="sd">        horizon `n` is as follows (note: `cal_length` and `cal_stride` can be set at model creation):</span>

<span class="sd">        - Extract a calibration set: The calibration set for each conformal forecast is automatically extracted from</span>
<span class="sd">          the most recent past of your input series relative to the forecast start point. The number of calibration</span>
<span class="sd">          examples (forecast errors / non-conformity scores) to consider can be defined at model creation</span>
<span class="sd">          with parameter `cal_length`. Note that when using `cal_stride&gt;1`, a longer history is required since</span>
<span class="sd">          the calibration examples are generated with stridden historical forecasts.</span>
<span class="sd">        - Generate historical forecasts on the calibration set (using the forecasting model) with a stride `cal_stride`.</span>
<span class="sd">        - Compute the errors/non-conformity scores (specific to each conformal model) on these historical forecasts</span>
<span class="sd">        - Compute the quantile values from the errors / non-conformity scores (using our desired quantiles set at model</span>
<span class="sd">          creation with parameter `quantiles`).</span>
<span class="sd">        - Compute the conformal prediction: Using these quantile values, add calibrated intervals to (or adjust the</span>
<span class="sd">          existing intervals of) the forecasting model&#39;s predictions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n</span>
<span class="sd">            Forecast horizon - the number of time steps after the end of the series for which to produce predictions.</span>
<span class="sd">        series</span>
<span class="sd">            A series or sequence of series, representing the history of the target series whose future is to be</span>
<span class="sd">            predicted. Will use the past of this series for calibration. The series should not have any overlap with</span>
<span class="sd">            the series used to train the forecasting model.</span>
<span class="sd">        past_covariates</span>
<span class="sd">            Optionally, a (sequence of) past-observed covariate time series for every input time series in `series`.</span>
<span class="sd">            Their dimension must match that of the past covariates used for training. Will use this series for</span>
<span class="sd">            calibration.</span>
<span class="sd">        future_covariates</span>
<span class="sd">            Optionally, a (sequence of) future-known covariate time series for every input time series in `series`.</span>
<span class="sd">            Their dimension must match that of the past covariates used for training. Will use this series for</span>
<span class="sd">            calibration.</span>
<span class="sd">        num_samples</span>
<span class="sd">            Number of times a prediction is sampled from the calibrated quantile predictions using linear</span>
<span class="sd">            interpolation in-between the quantiles. For larger values, the sample distribution approximates the</span>
<span class="sd">            calibrated quantile predictions.</span>
<span class="sd">        verbose</span>
<span class="sd">            Whether to print the progress.</span>
<span class="sd">        predict_likelihood_parameters</span>
<span class="sd">            If set to `True`, generates the quantile predictions directly. Only supported with `num_samples = 1`.</span>
<span class="sd">        show_warnings</span>
<span class="sd">            Whether to show warnings related auto-regression and past covariates usage.</span>
<span class="sd">        random_state</span>
<span class="sd">            Controls the randomness of probabilistic predictions.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Optional keyword arguments that will passed to the underlying forecasting model&#39;s `predict()` and</span>
<span class="sd">            `historical_forecasts()` methods.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[TimeSeries, Sequence[TimeSeries]]</span>
<span class="sd">            If `series` is not specified, this function returns a single time series containing the `n`</span>
<span class="sd">            next points after then end of the training series.</span>
<span class="sd">            If `series` is given and is a simple ``TimeSeries``, this function returns the `n` next points</span>
<span class="sd">            after the end of `series`.</span>
<span class="sd">            If `series` is given and is a sequence of several time series, this function returns</span>
<span class="sd">            a sequence where each element contains the corresponding `n` points forecasts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># call predict to verify that all series have required input times</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
            <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
            <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">,</span>
            <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
            <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
            <span class="n">num_samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cal_num_samples</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">predict_likelihood_parameters</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">show_warnings</span><span class="o">=</span><span class="n">show_warnings</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">series</span> <span class="o">=</span> <span class="n">series</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">training_series</span>
        <span class="n">called_with_single_series</span> <span class="o">=</span> <span class="n">get_series_seq_type</span><span class="p">(</span><span class="n">series</span><span class="p">)</span> <span class="o">==</span> <span class="n">SeriesType</span><span class="o">.</span><span class="n">SINGLE</span>
        <span class="n">series</span> <span class="o">=</span> <span class="n">series2seq</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>

        <span class="c1"># generate only the required forecasts for calibration (including the last forecast which is the output of</span>
        <span class="c1"># `predict()`)</span>
        <span class="n">cal_start</span><span class="p">,</span> <span class="n">cal_start_format</span> <span class="o">=</span> <span class="n">_get_calibration_hfc_start</span><span class="p">(</span>
            <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">,</span>
            <span class="n">horizon</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
            <span class="n">output_chunk_shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_shift</span><span class="p">,</span>
            <span class="n">cal_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cal_length</span><span class="p">,</span>
            <span class="n">cal_stride</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cal_stride</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="s2">&quot;end&quot;</span><span class="p">,</span>
            <span class="n">start_format</span><span class="o">=</span><span class="s2">&quot;position&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">cal_hfcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">historical_forecasts</span><span class="p">(</span>
            <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">,</span>
            <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
            <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
            <span class="n">forecast_horizon</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
            <span class="n">num_samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cal_num_samples</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">cal_start</span><span class="p">,</span>
            <span class="n">start_format</span><span class="o">=</span><span class="n">cal_start_format</span><span class="p">,</span>
            <span class="n">stride</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cal_stride</span><span class="p">,</span>
            <span class="n">retrain</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">overlap_end</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">last_points_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">show_warnings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">predict_likelihood_parameters</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">predict_kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">cal_preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calibrate_forecasts</span><span class="p">(</span>
            <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">,</span>
            <span class="n">forecasts</span><span class="o">=</span><span class="n">cal_hfcs</span><span class="p">,</span>
            <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="s2">&quot;end&quot;</span><span class="p">,</span>  <span class="c1"># uses last hist fc (output of `predict()`)</span>
            <span class="n">start_format</span><span class="o">=</span><span class="s2">&quot;position&quot;</span><span class="p">,</span>
            <span class="n">forecast_horizon</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
            <span class="n">stride</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cal_stride</span><span class="p">,</span>
            <span class="n">overlap_end</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">last_points_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">show_warnings</span><span class="o">=</span><span class="n">show_warnings</span><span class="p">,</span>
            <span class="n">predict_likelihood_parameters</span><span class="o">=</span><span class="n">predict_likelihood_parameters</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># convert historical forecasts output to simple forecast / prediction</span>
        <span class="k">if</span> <span class="n">called_with_single_series</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cal_preds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">cp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">cal_preds</span><span class="p">]</span></div>

<div class="viewcode-block" id="ConformalModel.historical_forecasts"><a class="viewcode-back" href="../../../../generated_api/darts.models.forecasting.conformal_models.html#darts.models.forecasting.conformal_models.ConformalModel.historical_forecasts">[docs]</a>    <span class="nd">@_with_sanity_checks</span><span class="p">(</span><span class="s2">&quot;_historical_forecasts_sanity_checks&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">historical_forecasts</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">series</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
        <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">forecast_horizon</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">train_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_format</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span>
        <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">retrain</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">overlap_end</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">last_points_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">show_warnings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">predict_likelihood_parameters</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">enable_optimization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">data_transformers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">BaseDataTransformer</span><span class="p">,</span> <span class="n">Pipeline</span><span class="p">]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fit_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">predict_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sample_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generates calibrated historical forecasts by simulating predictions at various points in time throughout the</span>
<span class="sd">        history of the provided (potentially multiple) `series`. This process involves retrospectively applying the</span>
<span class="sd">        model to different time steps, as if the forecasts were made in real-time at those specific moments. This</span>
<span class="sd">        allows for an evaluation of the model&#39;s performance over the entire duration of the series, providing insights</span>
<span class="sd">        into its predictive accuracy and robustness across different historical periods.</span>

<span class="sd">        Currently, conformal models only support the pre-trained historical forecasts mode (`retrain=False`).</span>
<span class="sd">        Parameters `retrain` and `train_length` are ignored.</span>

<span class="sd">        **Pre-trained Mode:** First, all historical forecasts are generated using the underlying pre-trained global</span>
<span class="sd">        forecasting model (see :meth:`ForecastingModel.historical_forecasts()</span>
<span class="sd">        &lt;darts.models.forecasting.forecasting_model.ForecastingModel.historical_forecasts&gt;` for more info). Then it</span>
<span class="sd">        repeatedly builds a calibration set by either expanding from the beginning of the historical forecasts or by</span>
<span class="sd">        using a fixed-length moving window with length `cal_length` (the start point can also be configured with</span>
<span class="sd">        `start` and `start_format`).</span>
<span class="sd">        The next forecast of length `forecast_horizon` is then calibrated on this calibration set. Subsequently, the</span>
<span class="sd">        end of the calibration set is moved forward by `stride` time steps, and the process is repeated.</span>

<span class="sd">        By default, with `last_points_only=True`, this method returns a single time series (or a sequence of time</span>
<span class="sd">        series when `series` is also a sequence of series) composed of the last point from each calibrated historical</span>
<span class="sd">        forecast. This time series will thus have a frequency of `series.freq * stride`.</span>
<span class="sd">        If `last_points_only=False`, it will instead return a list (or a sequence of lists) with all calibrated</span>
<span class="sd">        historical forecasts of length `forecast_horizon` and frequency `series.freq`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        series</span>
<span class="sd">            A (sequence of) target time series used to successively compute the historical forecasts. Will use the past</span>
<span class="sd">            of this series for calibration. The series should not have any overlap with the series used to train the</span>
<span class="sd">            forecasting model.</span>
<span class="sd">        past_covariates</span>
<span class="sd">            Optionally, a (sequence of) past-observed covariate time series for every input time series in `series`.</span>
<span class="sd">            Their dimension must match that of the past covariates used for training. Will use this series for</span>
<span class="sd">            calibration.</span>
<span class="sd">        future_covariates</span>
<span class="sd">            Optionally, a (sequence of) future-known covariate time series for every input time series in `series`.</span>
<span class="sd">            Their dimension must match that of the past covariates used for training. Will use this series for</span>
<span class="sd">            calibration.</span>
<span class="sd">        forecast_horizon</span>
<span class="sd">            The forecast horizon for the predictions.</span>
<span class="sd">        num_samples</span>
<span class="sd">            Number of times a prediction is sampled from the calibrated quantile predictions using linear</span>
<span class="sd">            interpolation in-between the quantiles. For larger values, the sample distribution approximates the</span>
<span class="sd">            calibrated quantile predictions.</span>
<span class="sd">        train_length</span>
<span class="sd">            Currently ignored by conformal models.</span>
<span class="sd">        start</span>
<span class="sd">            Optionally, the first point in time at which a prediction is computed. This parameter supports:</span>
<span class="sd">            ``int``, ``pandas.Timestamp``, and ``None``.</span>
<span class="sd">            If an ``int``, it is either the index position of the first prediction point for `series` with a</span>
<span class="sd">            `pd.DatetimeIndex`, or the index value for `series` with a `pd.RangeIndex`. The latter can be changed to</span>
<span class="sd">            the index position with `start_format=&quot;position&quot;`.</span>
<span class="sd">            If a ``pandas.Timestamp``, it is the time stamp of the first prediction point.</span>
<span class="sd">            If ``None``, the first prediction point will automatically be set to:</span>

<span class="sd">            - the first predictable point if `retrain` is ``False``, or `retrain` is a Callable and the first</span>
<span class="sd">              predictable point is earlier than the first trainable point.</span>
<span class="sd">            - the first trainable point if `retrain` is ``True`` or ``int`` (given `train_length`),</span>
<span class="sd">              or `retrain` is a ``Callable`` and the first trainable point is earlier than the first predictable point.</span>
<span class="sd">            - the first trainable point (given `train_length`) otherwise</span>

<span class="sd">            Note: If the model uses a shifted output (`output_chunk_shift &gt; 0`), then the first predicted point is also</span>
<span class="sd">            shifted by `output_chunk_shift` points into the future.</span>
<span class="sd">            Note: Raises a ValueError if `start` yields a time outside the time index of `series`.</span>
<span class="sd">            Note: If `start` is outside the possible historical forecasting times, will ignore the parameter</span>
<span class="sd">            (default behavior with ``None``) and start at the first trainable/predictable point.</span>
<span class="sd">        start_format</span>
<span class="sd">            Defines the `start` format.</span>
<span class="sd">            If set to ``&#39;position&#39;``, `start` corresponds to the index position of the first predicted point and can</span>
<span class="sd">            range from `(-len(series), len(series) - 1)`.</span>
<span class="sd">            If set to ``&#39;value&#39;``, `start` corresponds to the index value/label of the first predicted point. Will raise</span>
<span class="sd">            an error if the value is not in `series`&#39; index. Default: ``&#39;value&#39;``.</span>
<span class="sd">        stride</span>
<span class="sd">            The number of time steps between two consecutive predictions. Must be a round-multiple of `cal_stride`</span>
<span class="sd">            (set at model creation) and `&gt;=cal_stride`.</span>
<span class="sd">        retrain</span>
<span class="sd">            Currently ignored by conformal models.</span>
<span class="sd">        overlap_end</span>
<span class="sd">            Whether the returned forecasts can go beyond the series&#39; end or not.</span>
<span class="sd">        last_points_only</span>
<span class="sd">            Whether to return only the last point of each historical forecast. If set to ``True``, the method returns a</span>
<span class="sd">            single ``TimeSeries`` (for each time series in `series`) containing the successive point forecasts.</span>
<span class="sd">            Otherwise, returns a list of historical ``TimeSeries`` forecasts.</span>
<span class="sd">        verbose</span>
<span class="sd">            Whether to print the progress.</span>
<span class="sd">        show_warnings</span>
<span class="sd">            Whether to show warnings related to historical forecasts optimization, or parameters `start` and</span>
<span class="sd">            `train_length`.</span>
<span class="sd">        predict_likelihood_parameters</span>
<span class="sd">            If set to `True`, generates the quantile predictions directly. Only supported with `num_samples = 1`.</span>
<span class="sd">        enable_optimization</span>
<span class="sd">            Whether to use the optimized version of `historical_forecasts` when supported and available.</span>
<span class="sd">            Default: ``True``.</span>
<span class="sd">        data_transformers</span>
<span class="sd">            Optionally, a dictionary of `BaseDataTransformer` or `Pipeline` to apply to the corresponding series</span>
<span class="sd">            (possibles keys; &quot;series&quot;, &quot;past_covariates&quot;, &quot;future_covariates&quot;). If provided, all input series must be</span>
<span class="sd">            in the un-transformed space. For fittable transformer / pipeline:</span>

<span class="sd">            - if `retrain=True`, the data transformer re-fit on the training data at each historical forecast step</span>
<span class="sd">              (currently ignored by conformal models).</span>
<span class="sd">            - if `retrain=False`, the data transformer transforms the series once before all the forecasts.</span>

<span class="sd">            The fitted transformer is used to transform the input during both training and prediction.</span>
<span class="sd">            If the transformation is invertible, the forecasts will be inverse-transformed.</span>
<span class="sd">        fit_kwargs</span>
<span class="sd">            Currently ignored by conformal models.</span>
<span class="sd">        predict_kwargs</span>
<span class="sd">            Optionally, some additional arguments passed to the model `predict()` method.</span>
<span class="sd">        sample_weight</span>
<span class="sd">            Currently ignored by conformal models.</span>
<span class="sd">        random_state</span>
<span class="sd">            Controls the randomness of probabilistic predictions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A single historical forecast for a single `series` and `last_points_only=True`: it contains only the</span>
<span class="sd">            predictions at step `forecast_horizon` from all historical forecasts.</span>
<span class="sd">        list[TimeSeries]</span>
<span class="sd">            A list of historical forecasts for:</span>

<span class="sd">            - a sequence (list) of `series` and `last_points_only=True`: for each series, it contains only the</span>
<span class="sd">              predictions at step `forecast_horizon` from all historical forecasts.</span>
<span class="sd">            - a single `series` and `last_points_only=False`: for each historical forecast, it contains the entire</span>
<span class="sd">              horizon `forecast_horizon`.</span>
<span class="sd">        list[list[TimeSeries]]</span>
<span class="sd">            A list of lists of historical forecasts for a sequence of `series` and `last_points_only=False`. For each</span>
<span class="sd">            series, and historical forecast, it contains the entire horizon `forecast_horizon`. The outer list</span>
<span class="sd">            is over the series provided in the input sequence, and the inner lists contain the historical forecasts for</span>
<span class="sd">            each series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">called_with_single_series</span> <span class="o">=</span> <span class="n">get_series_seq_type</span><span class="p">(</span><span class="n">series</span><span class="p">)</span> <span class="o">==</span> <span class="n">SeriesType</span><span class="o">.</span><span class="n">SINGLE</span>
        <span class="n">series</span> <span class="o">=</span> <span class="n">series2seq</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
        <span class="n">past_covariates</span> <span class="o">=</span> <span class="n">series2seq</span><span class="p">(</span><span class="n">past_covariates</span><span class="p">)</span>
        <span class="n">future_covariates</span> <span class="o">=</span> <span class="n">series2seq</span><span class="p">(</span><span class="n">future_covariates</span><span class="p">)</span>

        <span class="c1"># generate only the required forecasts (if `start` is given, we have to start earlier to satisfy the</span>
        <span class="c1"># calibration set requirements)</span>
        <span class="n">cal_start</span><span class="p">,</span> <span class="n">cal_start_format</span> <span class="o">=</span> <span class="n">_get_calibration_hfc_start</span><span class="p">(</span>
            <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">,</span>
            <span class="n">horizon</span><span class="o">=</span><span class="n">forecast_horizon</span><span class="p">,</span>
            <span class="n">output_chunk_shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_shift</span><span class="p">,</span>
            <span class="n">cal_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cal_length</span><span class="p">,</span>
            <span class="n">cal_stride</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cal_stride</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
            <span class="n">start_format</span><span class="o">=</span><span class="n">start_format</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">hfcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">historical_forecasts</span><span class="p">(</span>
            <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">,</span>
            <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
            <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
            <span class="n">forecast_horizon</span><span class="o">=</span><span class="n">forecast_horizon</span><span class="p">,</span>
            <span class="n">num_samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cal_num_samples</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">cal_start</span><span class="p">,</span>
            <span class="n">start_format</span><span class="o">=</span><span class="n">cal_start_format</span><span class="p">,</span>
            <span class="n">stride</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cal_stride</span><span class="p">,</span>
            <span class="n">retrain</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">overlap_end</span><span class="o">=</span><span class="n">overlap_end</span><span class="p">,</span>
            <span class="n">last_points_only</span><span class="o">=</span><span class="n">last_points_only</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">show_warnings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">predict_likelihood_parameters</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">enable_optimization</span><span class="o">=</span><span class="n">enable_optimization</span><span class="p">,</span>
            <span class="n">data_transformers</span><span class="o">=</span><span class="n">data_transformers</span><span class="p">,</span>
            <span class="n">fit_kwargs</span><span class="o">=</span><span class="n">fit_kwargs</span><span class="p">,</span>
            <span class="n">predict_kwargs</span><span class="o">=</span><span class="n">predict_kwargs</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">calibrated_forecasts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calibrate_forecasts</span><span class="p">(</span>
            <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">,</span>
            <span class="n">forecasts</span><span class="o">=</span><span class="n">hfcs</span><span class="p">,</span>
            <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
            <span class="n">start_format</span><span class="o">=</span><span class="n">start_format</span><span class="p">,</span>
            <span class="n">forecast_horizon</span><span class="o">=</span><span class="n">forecast_horizon</span><span class="p">,</span>
            <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span>
            <span class="n">overlap_end</span><span class="o">=</span><span class="n">overlap_end</span><span class="p">,</span>
            <span class="n">last_points_only</span><span class="o">=</span><span class="n">last_points_only</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">show_warnings</span><span class="o">=</span><span class="n">show_warnings</span><span class="p">,</span>
            <span class="n">predict_likelihood_parameters</span><span class="o">=</span><span class="n">predict_likelihood_parameters</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">calibrated_forecasts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">called_with_single_series</span>
            <span class="k">else</span> <span class="n">calibrated_forecasts</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ConformalModel.backtest"><a class="viewcode-back" href="../../../../generated_api/darts.models.forecasting.conformal_models.html#darts.models.forecasting.conformal_models.ConformalModel.backtest">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">backtest</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">series</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
        <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">historical_forecasts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">forecast_horizon</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">train_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_format</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span>
        <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">retrain</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">overlap_end</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">last_points_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">metric</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">METRIC_TYPE</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">METRIC_TYPE</span><span class="p">]]</span> <span class="o">=</span> <span class="n">metrics</span><span class="o">.</span><span class="n">mape</span><span class="p">,</span>
        <span class="n">reduction</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">show_warnings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">predict_likelihood_parameters</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">enable_optimization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">data_transformers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">BaseDataTransformer</span><span class="p">,</span> <span class="n">Pipeline</span><span class="p">]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metric_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fit_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">predict_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sample_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute error values that the model produced for historical forecasts on (potentially multiple) `series`.</span>

<span class="sd">        If `historical_forecasts` are provided, the metric(s) (given by the `metric` function) is evaluated directly on</span>
<span class="sd">        all forecasts and actual values. The same `series` and `last_points_only` value must be passed that were used</span>
<span class="sd">        to generate the historical forecasts. Finally, the method returns an optional `reduction` (the mean by default)</span>
<span class="sd">        of all these metric scores.</span>

<span class="sd">        If `historical_forecasts` is ``None``, it first generates the historical forecasts with the parameters given</span>
<span class="sd">        below (see :meth:`ConformalModel.historical_forecasts()</span>
<span class="sd">        &lt;darts.models.forecasting.conformal_models.ConformalModel.historical_forecasts&gt;` for more info) and then</span>
<span class="sd">        evaluates as described above.</span>

<span class="sd">        The metric(s) can be further customized `metric_kwargs` (e.g. control the aggregation over components, time</span>
<span class="sd">        steps, multiple series, other required arguments such as `q` for quantile metrics, ...).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Darts has several metrics to evaluate probabilistic forecasts. For conformal models, we recommend using</span>
<span class="sd">        quantile interval metrics (see `here &lt;https://unit8co.github.io/darts/generated_api/darts.metrics.html&gt;`_).</span>
<span class="sd">        You can specify which intervals to evaluate by setting `metric_kwargs={&#39;q_interval&#39;: my_intervals}`. To check</span>
<span class="sd">        all intervals used by your conformal model `my_model`, you can set ``{&#39;q_interval&#39;: my_model.q_interval}``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        series</span>
<span class="sd">            A (sequence of) target time series used to successively compute the historical forecasts. Will use the past</span>
<span class="sd">            of this series for calibration. The series should not have any overlap with the series used to train the</span>
<span class="sd">            forecasting model.</span>
<span class="sd">        past_covariates</span>
<span class="sd">            Optionally, a (sequence of) past-observed covariate time series for every input time series in `series`.</span>
<span class="sd">            Their dimension must match that of the past covariates used for training. Will use this series for</span>
<span class="sd">            calibration.</span>
<span class="sd">        future_covariates</span>
<span class="sd">            Optionally, a (sequence of) future-known covariate time series for every input time series in `series`.</span>
<span class="sd">            Their dimension must match that of the past covariates used for training. Will use this series for</span>
<span class="sd">            calibration.</span>
<span class="sd">        historical_forecasts</span>
<span class="sd">            Optionally, the (or a sequence of / a sequence of sequences of) historical forecasts time series to be</span>
<span class="sd">            evaluated. Corresponds to the output of :meth:`historical_forecasts()</span>
<span class="sd">            &lt;darts.models.forecasting.conformal_models.ConformalModel.historical_forecasts&gt;`. The same `series` and</span>
<span class="sd">            `last_points_only` values must be passed that were used to generate the historical forecasts. If provided,</span>
<span class="sd">            will skip historical forecasting and ignore all parameters except `series`, `last_points_only`, `metric`,</span>
<span class="sd">            and `reduction`.</span>
<span class="sd">        forecast_horizon</span>
<span class="sd">            The forecast horizon for the predictions.</span>
<span class="sd">        num_samples</span>
<span class="sd">            Number of times a prediction is sampled from the calibrated quantile predictions using linear</span>
<span class="sd">            interpolation in-between the quantiles. For larger values, the sample distribution approximates the</span>
<span class="sd">            calibrated quantile predictions.</span>
<span class="sd">        train_length</span>
<span class="sd">            Currently ignored by conformal models.</span>
<span class="sd">        start</span>
<span class="sd">            Optionally, the first point in time at which a prediction is computed. This parameter supports:</span>
<span class="sd">            ``int``, ``pandas.Timestamp``, and ``None``.</span>
<span class="sd">            If an ``int``, it is either the index position of the first prediction point for `series` with a</span>
<span class="sd">            `pd.DatetimeIndex`, or the index value for `series` with a `pd.RangeIndex`. The latter can be changed to</span>
<span class="sd">            the index position with `start_format=&quot;position&quot;`.</span>
<span class="sd">            If a ``pandas.Timestamp``, it is the time stamp of the first prediction point.</span>
<span class="sd">            If ``None``, the first prediction point will automatically be set to:</span>

<span class="sd">            - the first predictable point if `retrain` is ``False``, or `retrain` is a Callable and the first</span>
<span class="sd">              predictable point is earlier than the first trainable point.</span>
<span class="sd">            - the first trainable point if `retrain` is ``True`` or ``int`` (given `train_length`),</span>
<span class="sd">              or `retrain` is a ``Callable`` and the first trainable point is earlier than the first predictable point.</span>
<span class="sd">            - the first trainable point (given `train_length`) otherwise</span>

<span class="sd">            Note: If the model uses a shifted output (`output_chunk_shift &gt; 0`), then the first predicted point is also</span>
<span class="sd">            shifted by `output_chunk_shift` points into the future.</span>
<span class="sd">            Note: Raises a ValueError if `start` yields a time outside the time index of `series`.</span>
<span class="sd">            Note: If `start` is outside the possible historical forecasting times, will ignore the parameter</span>
<span class="sd">            (default behavior with ``None``) and start at the first trainable/predictable point.</span>
<span class="sd">        start_format</span>
<span class="sd">            Defines the `start` format.</span>
<span class="sd">            If set to ``&#39;position&#39;``, `start` corresponds to the index position of the first predicted point and can</span>
<span class="sd">            range from `(-len(series), len(series) - 1)`.</span>
<span class="sd">            If set to ``&#39;value&#39;``, `start` corresponds to the index value/label of the first predicted point. Will raise</span>
<span class="sd">            an error if the value is not in `series`&#39; index. Default: ``&#39;value&#39;``.</span>
<span class="sd">        stride</span>
<span class="sd">            The number of time steps between two consecutive predictions.</span>
<span class="sd">        retrain</span>
<span class="sd">            Currently ignored by conformal models.</span>
<span class="sd">        overlap_end</span>
<span class="sd">            Whether the returned forecasts can go beyond the series&#39; end or not.</span>
<span class="sd">        last_points_only</span>
<span class="sd">            Whether to return only the last point of each historical forecast. If set to ``True``, the method returns a</span>
<span class="sd">            single ``TimeSeries`` (for each time series in `series`) containing the successive point forecasts.</span>
<span class="sd">            Otherwise, returns a list of historical ``TimeSeries`` forecasts.</span>
<span class="sd">        metric</span>
<span class="sd">            A metric function or a list of metric functions. Each metric must either be a Darts metric (see `here</span>
<span class="sd">            &lt;https://unit8co.github.io/darts/generated_api/darts.metrics.html&gt;`_), or a custom metric that has an</span>
<span class="sd">            identical signature as Darts&#39; metrics, uses decorators :func:`~darts.metrics.metrics.multi_ts_support` and</span>
<span class="sd">            :func:`~darts.metrics.metrics.multi_ts_support`, and returns the metric score.</span>
<span class="sd">        reduction</span>
<span class="sd">            A function used to combine the individual error scores obtained when `last_points_only` is set to `False`.</span>
<span class="sd">            When providing several metric functions, the function will receive the argument `axis = 1` to obtain single</span>
<span class="sd">            value for each metric function.</span>
<span class="sd">            If explicitly set to `None`, the method will return a list of the individual error scores instead.</span>
<span class="sd">            Set to ``np.mean`` by default.</span>
<span class="sd">        verbose</span>
<span class="sd">            Whether to print the progress.</span>
<span class="sd">        show_warnings</span>
<span class="sd">            Whether to show warnings related to historical forecasts optimization, or parameters `start` and</span>
<span class="sd">            `train_length`.</span>
<span class="sd">        predict_likelihood_parameters</span>
<span class="sd">            If set to `True`, generates the quantile predictions directly. Only supported with `num_samples = 1`.</span>
<span class="sd">        enable_optimization</span>
<span class="sd">            Whether to use the optimized version of `historical_forecasts` when supported and available.</span>
<span class="sd">            Default: ``True``.</span>
<span class="sd">        data_transformers</span>
<span class="sd">            Optionally, a dictionary of `BaseDataTransformer` or `Pipeline` to apply to the corresponding series</span>
<span class="sd">            (possibles keys; &quot;series&quot;, &quot;past_covariates&quot;, &quot;future_covariates&quot;). If provided, all input series must be</span>
<span class="sd">            in the un-transformed space. For fittable transformer / pipeline:</span>

<span class="sd">            - if `retrain=True`, the data transformer re-fit on the training data at each historical forecast step</span>
<span class="sd">              (currently ignored by conformal models).</span>
<span class="sd">            - if `retrain=False`, the data transformer transforms the series once before all the forecasts.</span>

<span class="sd">            The fitted transformer is used to transform the input during both training and prediction.</span>
<span class="sd">            If the transformation is invertible, the forecasts will be inverse-transformed.</span>
<span class="sd">            Only effective when `historical_forecasts=None`.</span>
<span class="sd">        metric_kwargs</span>
<span class="sd">            Additional arguments passed to `metric()`, such as `&#39;n_jobs&#39;` for parallelization, `&#39;component_reduction&#39;`</span>
<span class="sd">            for reducing the component wise metrics, seasonality `&#39;m&#39;` for scaled metrics, etc. Will pass arguments to</span>
<span class="sd">            each metric separately and only if they are present in the corresponding metric signature. Parameter</span>
<span class="sd">            `&#39;insample&#39;` for scaled metrics (e.g. mase`, `rmsse`, ...) is ignored, as it is handled internally.</span>
<span class="sd">        fit_kwargs</span>
<span class="sd">            Currently ignored by conformal models.</span>
<span class="sd">        predict_kwargs</span>
<span class="sd">            Optionally, some additional arguments passed to the model `predict()` method.</span>
<span class="sd">        sample_weight</span>
<span class="sd">            Currently ignored by conformal models.</span>
<span class="sd">        random_state</span>
<span class="sd">            Controls the randomness of probabilistic predictions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            A single backtest score for single uni/multivariate series, a single `metric` function and:</span>

<span class="sd">            - `historical_forecasts` generated with `last_points_only=True`</span>
<span class="sd">            - `historical_forecasts` generated with `last_points_only=False` and using a backtest `reduction`</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            An numpy array of backtest scores. For single series and one of:</span>

<span class="sd">            - a single `metric` function, `historical_forecasts` generated with `last_points_only=False`</span>
<span class="sd">              and backtest `reduction=None`. The output has shape (n forecasts, *).</span>
<span class="sd">            - multiple `metric` functions and `historical_forecasts` generated with `last_points_only=False`.</span>
<span class="sd">              The output has shape (*, n metrics) when using a backtest `reduction`, and (n forecasts, *, n metrics)</span>
<span class="sd">              when `reduction=None`</span>
<span class="sd">            - multiple uni/multivariate series including `series_reduction` and at least one of</span>
<span class="sd">              `component_reduction=None` or `time_reduction=None` for &quot;per time step metrics&quot;</span>
<span class="sd">        list[float]</span>
<span class="sd">            Same as for type `float` but for a sequence of series. The returned metric list has length</span>
<span class="sd">            `len(series)` with the `float` metric for each input `series`.</span>
<span class="sd">        list[np.ndarray]</span>
<span class="sd">            Same as for type `np.ndarray` but for a sequence of series. The returned metric list has length</span>
<span class="sd">            `len(series)` with the `np.ndarray` metrics for each input `series`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">backtest</span><span class="p">(</span>
            <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">,</span>
            <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
            <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
            <span class="n">historical_forecasts</span><span class="o">=</span><span class="n">historical_forecasts</span><span class="p">,</span>
            <span class="n">forecast_horizon</span><span class="o">=</span><span class="n">forecast_horizon</span><span class="p">,</span>
            <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">,</span>
            <span class="n">train_length</span><span class="o">=</span><span class="n">train_length</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
            <span class="n">start_format</span><span class="o">=</span><span class="n">start_format</span><span class="p">,</span>
            <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span>
            <span class="n">retrain</span><span class="o">=</span><span class="n">retrain</span><span class="p">,</span>
            <span class="n">overlap_end</span><span class="o">=</span><span class="n">overlap_end</span><span class="p">,</span>
            <span class="n">last_points_only</span><span class="o">=</span><span class="n">last_points_only</span><span class="p">,</span>
            <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
            <span class="n">reduction</span><span class="o">=</span><span class="n">reduction</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">show_warnings</span><span class="o">=</span><span class="n">show_warnings</span><span class="p">,</span>
            <span class="n">predict_likelihood_parameters</span><span class="o">=</span><span class="n">predict_likelihood_parameters</span><span class="p">,</span>
            <span class="n">enable_optimization</span><span class="o">=</span><span class="n">enable_optimization</span><span class="p">,</span>
            <span class="n">data_transformers</span><span class="o">=</span><span class="n">data_transformers</span><span class="p">,</span>
            <span class="n">metric_kwargs</span><span class="o">=</span><span class="n">metric_kwargs</span><span class="p">,</span>
            <span class="n">fit_kwargs</span><span class="o">=</span><span class="n">fit_kwargs</span><span class="p">,</span>
            <span class="n">predict_kwargs</span><span class="o">=</span><span class="n">predict_kwargs</span><span class="p">,</span>
            <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ConformalModel.residuals"><a class="viewcode-back" href="../../../../generated_api/darts.models.forecasting.conformal_models.html#darts.models.forecasting.conformal_models.ConformalModel.residuals">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">residuals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">series</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
        <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">historical_forecasts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">forecast_horizon</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">train_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_format</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span>
        <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">retrain</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">overlap_end</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">last_points_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">metric</span><span class="p">:</span> <span class="n">METRIC_TYPE</span> <span class="o">=</span> <span class="n">metrics</span><span class="o">.</span><span class="n">err</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">show_warnings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">predict_likelihood_parameters</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">enable_optimization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">data_transformers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">BaseDataTransformer</span><span class="p">,</span> <span class="n">Pipeline</span><span class="p">]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metric_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fit_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">predict_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sample_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">values_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the residuals that the model produced for historical forecasts on (potentially multiple) `series`.</span>

<span class="sd">        This function computes the difference (or one of Darts&#39; &quot;per time step&quot; metrics) between the actual</span>
<span class="sd">        observations from `series` and the fitted values obtained by training the model on `series` (or using a</span>
<span class="sd">        pre-trained model with `retrain=False`). Not all models support fitted values, so we use historical forecasts</span>
<span class="sd">        as an approximation for them.</span>

<span class="sd">        In sequence this method performs:</span>

<span class="sd">        - use pre-computed `historical_forecasts` or compute historical forecasts for each series (see</span>
<span class="sd">          :meth:`~darts.models.forecasting.conformal_models.ConformalModel.historical_forecasts` for more details).</span>
<span class="sd">          How the historical forecasts are generated can be configured with parameters `num_samples`, `train_length`,</span>
<span class="sd">          `start`, `start_format`, `forecast_horizon`, `stride`, `retrain`, `last_points_only`, `fit_kwargs`, and</span>
<span class="sd">          `predict_kwargs`.</span>
<span class="sd">        - compute a backtest using a &quot;per time step&quot; `metric` between the historical forecasts and `series` per</span>
<span class="sd">          component/column and time step (see</span>
<span class="sd">          :meth:`~darts.models.forecasting.conformal_models.ConformalModel.backtest` for more details). By default,</span>
<span class="sd">          uses the residuals :func:`~darts.metrics.metrics.err` (error) as a `metric`.</span>
<span class="sd">        - create and return `TimeSeries` (or simply a np.ndarray with `values_only=True`) with the time index from</span>
<span class="sd">          historical forecasts, and values from the metrics per component and time step.</span>

<span class="sd">        This method works for single or multiple univariate or multivariate series.</span>
<span class="sd">        It uses the median prediction (when dealing with stochastic forecasts).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Darts has several metrics to evaluate probabilistic forecasts. For conformal models, we recommend using</span>
<span class="sd">        &quot;per time step&quot; quantile interval metrics (see `here</span>
<span class="sd">        &lt;https://unit8co.github.io/darts/generated_api/darts.metrics.html&gt;`_). You can specify which intervals to</span>
<span class="sd">        evaluate by setting `metric_kwargs={&#39;q_interval&#39;: my_intervals}`. To check all intervals used by your conformal</span>
<span class="sd">        model `my_model`, you can set ``{&#39;q_interval&#39;: my_model.q_interval}``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        series</span>
<span class="sd">            A (sequence of) target time series used to successively compute the historical forecasts. Will use the past</span>
<span class="sd">            of this series for calibration. The series should not have any overlap with the series used to train the</span>
<span class="sd">            forecasting model.</span>
<span class="sd">        past_covariates</span>
<span class="sd">            Optionally, a (sequence of) past-observed covariate time series for every input time series in `series`.</span>
<span class="sd">            Their dimension must match that of the past covariates used for training. Will use this series for</span>
<span class="sd">            calibration.</span>
<span class="sd">        future_covariates</span>
<span class="sd">            Optionally, a (sequence of) future-known covariate time series for every input time series in `series`.</span>
<span class="sd">            Their dimension must match that of the past covariates used for training. Will use this series for</span>
<span class="sd">            calibration.</span>
<span class="sd">        historical_forecasts</span>
<span class="sd">            Optionally, the (or a sequence of / a sequence of sequences of) historical forecasts time series to be</span>
<span class="sd">            evaluated. Corresponds to the output of :meth:`historical_forecasts()</span>
<span class="sd">            &lt;darts.models.forecasting.conformal_models.ConformalModel.historical_forecasts&gt;`. The same `series` and</span>
<span class="sd">            `last_points_only` values must be passed that were used to generate the historical forecasts. If provided,</span>
<span class="sd">            will skip historical forecasting and ignore all parameters except `series`, `last_points_only`, `metric`,</span>
<span class="sd">            and `reduction`.</span>
<span class="sd">        forecast_horizon</span>
<span class="sd">            The forecast horizon for the predictions.</span>
<span class="sd">        num_samples</span>
<span class="sd">            Number of times a prediction is sampled from the calibrated quantile predictions using linear</span>
<span class="sd">            interpolation in-between the quantiles. For larger values, the sample distribution approximates the</span>
<span class="sd">            calibrated quantile predictions.</span>
<span class="sd">        train_length</span>
<span class="sd">            Currently ignored by conformal models.</span>
<span class="sd">        start</span>
<span class="sd">            Optionally, the first point in time at which a prediction is computed. This parameter supports:</span>
<span class="sd">            ``int``, ``pandas.Timestamp``, and ``None``.</span>
<span class="sd">            If an ``int``, it is either the index position of the first prediction point for `series` with a</span>
<span class="sd">            `pd.DatetimeIndex`, or the index value for `series` with a `pd.RangeIndex`. The latter can be changed to</span>
<span class="sd">            the index position with `start_format=&quot;position&quot;`.</span>
<span class="sd">            If a ``pandas.Timestamp``, it is the time stamp of the first prediction point.</span>
<span class="sd">            If ``None``, the first prediction point will automatically be set to:</span>

<span class="sd">            - the first predictable point if `retrain` is ``False``, or `retrain` is a Callable and the first</span>
<span class="sd">              predictable point is earlier than the first trainable point.</span>
<span class="sd">            - the first trainable point if `retrain` is ``True`` or ``int`` (given `train_length`),</span>
<span class="sd">              or `retrain` is a ``Callable`` and the first trainable point is earlier than the first predictable point.</span>
<span class="sd">            - the first trainable point (given `train_length`) otherwise</span>

<span class="sd">            Note: If the model uses a shifted output (`output_chunk_shift &gt; 0`), then the first predicted point is also</span>
<span class="sd">            shifted by `output_chunk_shift` points into the future.</span>
<span class="sd">            Note: Raises a ValueError if `start` yields a time outside the time index of `series`.</span>
<span class="sd">            Note: If `start` is outside the possible historical forecasting times, will ignore the parameter</span>
<span class="sd">            (default behavior with ``None``) and start at the first trainable/predictable point.</span>
<span class="sd">        start_format</span>
<span class="sd">            Defines the `start` format.</span>
<span class="sd">            If set to ``&#39;position&#39;``, `start` corresponds to the index position of the first predicted point and can</span>
<span class="sd">            range from `(-len(series), len(series) - 1)`.</span>
<span class="sd">            If set to ``&#39;value&#39;``, `start` corresponds to the index value/label of the first predicted point. Will raise</span>
<span class="sd">            an error if the value is not in `series`&#39; index. Default: ``&#39;value&#39;``.</span>
<span class="sd">        stride</span>
<span class="sd">            The number of time steps between two consecutive predictions.</span>
<span class="sd">        retrain</span>
<span class="sd">            Currently ignored by conformal models.</span>
<span class="sd">        overlap_end</span>
<span class="sd">            Whether the returned forecasts can go beyond the series&#39; end or not.</span>
<span class="sd">        last_points_only</span>
<span class="sd">            Whether to return only the last point of each historical forecast. If set to ``True``, the method returns a</span>
<span class="sd">            single ``TimeSeries`` (for each time series in `series`) containing the successive point forecasts.</span>
<span class="sd">            Otherwise, returns a list of historical ``TimeSeries`` forecasts.</span>
<span class="sd">        metric</span>
<span class="sd">            Either one of Darts&#39; &quot;per time step&quot; metrics (see `here</span>
<span class="sd">            &lt;https://unit8co.github.io/darts/generated_api/darts.metrics.html&gt;`_), or a custom metric that has an</span>
<span class="sd">            identical signature as Darts&#39; &quot;per time step&quot; metrics, uses decorators</span>
<span class="sd">            :func:`~darts.metrics.metrics.multi_ts_support` and :func:`~darts.metrics.metrics.multi_ts_support`,</span>
<span class="sd">            and returns one value per time step.</span>
<span class="sd">        verbose</span>
<span class="sd">            Whether to print the progress.</span>
<span class="sd">        show_warnings</span>
<span class="sd">            Whether to show warnings related to historical forecasts optimization, or parameters `start` and</span>
<span class="sd">            `train_length`.</span>
<span class="sd">        predict_likelihood_parameters</span>
<span class="sd">            If set to `True`, generates the quantile predictions directly. Only supported with `num_samples = 1`.</span>
<span class="sd">        enable_optimization</span>
<span class="sd">            Whether to use the optimized version of `historical_forecasts` when supported and available.</span>
<span class="sd">            Default: ``True``.</span>
<span class="sd">        data_transformers</span>
<span class="sd">            Optionally, a dictionary of `BaseDataTransformer` or `Pipeline` to apply to the corresponding series</span>
<span class="sd">            (possibles keys; &quot;series&quot;, &quot;past_covariates&quot;, &quot;future_covariates&quot;). If provided, all input series must be</span>
<span class="sd">            in the un-transformed space. For fittable transformer / pipeline:</span>

<span class="sd">            - if `retrain=True`, the data transformer re-fit on the training data at each historical forecast step</span>
<span class="sd">              (currently ignored by conformal models).</span>
<span class="sd">            - if `retrain=False`, the data transformer transforms the series once before all the forecasts.</span>

<span class="sd">            The fitted transformer is used to transform the input during both training and prediction.</span>
<span class="sd">            If the transformation is invertible, the forecasts will be inverse-transformed.</span>
<span class="sd">            Only effective when `historical_forecasts=None`.</span>
<span class="sd">        metric_kwargs</span>
<span class="sd">            Additional arguments passed to `metric()`, such as `&#39;n_jobs&#39;` for parallelization, `&#39;m&#39;` for scaled</span>
<span class="sd">            metrics, etc. Will pass arguments only if they are present in the corresponding metric signature. Ignores</span>
<span class="sd">            reduction arguments `&quot;series_reduction&quot;, &quot;component_reduction&quot;, &quot;time_reduction&quot;`, and parameter</span>
<span class="sd">            `&#39;insample&#39;` for scaled metrics (e.g. mase`, `rmsse`, ...), as they are handled internally.</span>
<span class="sd">        fit_kwargs</span>
<span class="sd">            Currently ignored by conformal models.</span>
<span class="sd">        predict_kwargs</span>
<span class="sd">            Optionally, some additional arguments passed to the model `predict()` method.</span>
<span class="sd">        sample_weight</span>
<span class="sd">            Currently ignored by conformal models.</span>
<span class="sd">        values_only</span>
<span class="sd">            Whether to return the residuals as `np.ndarray`. If `False`, returns residuals as `TimeSeries`.</span>
<span class="sd">        random_state</span>
<span class="sd">            Controls the randomness of probabilistic predictions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            Residual `TimeSeries` for a single `series` and `historical_forecasts` generated with</span>
<span class="sd">            `last_points_only=True`.</span>
<span class="sd">        list[TimeSeries]</span>
<span class="sd">            A list of residual `TimeSeries` for a sequence (list) of `series` with `last_points_only=True`.</span>
<span class="sd">            The residual list has length `len(series)`.</span>
<span class="sd">        list[list[TimeSeries]]</span>
<span class="sd">            A list of lists of residual `TimeSeries` for a sequence of `series` with `last_points_only=False`.</span>
<span class="sd">            The outer residual list has length `len(series)`. The inner lists consist of the residuals from</span>
<span class="sd">            all possible series-specific historical forecasts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">residuals</span><span class="p">(</span>
            <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">,</span>
            <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
            <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
            <span class="n">historical_forecasts</span><span class="o">=</span><span class="n">historical_forecasts</span><span class="p">,</span>
            <span class="n">forecast_horizon</span><span class="o">=</span><span class="n">forecast_horizon</span><span class="p">,</span>
            <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">,</span>
            <span class="n">train_length</span><span class="o">=</span><span class="n">train_length</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
            <span class="n">start_format</span><span class="o">=</span><span class="n">start_format</span><span class="p">,</span>
            <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span>
            <span class="n">retrain</span><span class="o">=</span><span class="n">retrain</span><span class="p">,</span>
            <span class="n">overlap_end</span><span class="o">=</span><span class="n">overlap_end</span><span class="p">,</span>
            <span class="n">last_points_only</span><span class="o">=</span><span class="n">last_points_only</span><span class="p">,</span>
            <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">show_warnings</span><span class="o">=</span><span class="n">show_warnings</span><span class="p">,</span>
            <span class="n">predict_likelihood_parameters</span><span class="o">=</span><span class="n">predict_likelihood_parameters</span><span class="p">,</span>
            <span class="n">enable_optimization</span><span class="o">=</span><span class="n">enable_optimization</span><span class="p">,</span>
            <span class="n">data_transformers</span><span class="o">=</span><span class="n">data_transformers</span><span class="p">,</span>
            <span class="n">metric_kwargs</span><span class="o">=</span><span class="n">metric_kwargs</span><span class="p">,</span>
            <span class="n">fit_kwargs</span><span class="o">=</span><span class="n">fit_kwargs</span><span class="p">,</span>
            <span class="n">predict_kwargs</span><span class="o">=</span><span class="n">predict_kwargs</span><span class="p">,</span>
            <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">,</span>
            <span class="n">values_only</span><span class="o">=</span><span class="n">values_only</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="nd">@random_method</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_calibrate_forecasts</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">series</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
        <span class="n">forecasts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
        <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_format</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span>
        <span class="n">forecast_horizon</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">overlap_end</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">last_points_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">show_warnings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">predict_likelihood_parameters</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate calibrated historical forecasts.</span>

<span class="sd">        In general the workflow of the models to produce one calibrated forecast/prediction per step in the horizon</span>
<span class="sd">        is as follows:</span>

<span class="sd">        - Generate historical forecasts for `series` with stride `cal_stride` (using the forecasting model)</span>
<span class="sd">        - Extract a calibration set: The forecasts from the most recent past to use as calibration for one conformal</span>
<span class="sd">          prediction. The number of examples to use can be defined at model creation with parameter `cal_length`. It</span>
<span class="sd">          automatically extracts the calibration set from the most recent past of your input series (`series`,</span>
<span class="sd">          `past_covariates`, ...).</span>
<span class="sd">        - Compute the errors/non-conformity scores (specific to each conformal model) on these historical forecasts</span>
<span class="sd">        - Compute the quantile values from the errors / non-conformity scores (using our desired quantiles set at model</span>
<span class="sd">          creation with parameter `quantiles`).</span>
<span class="sd">        - Compute the conformal prediction: Using these quantile values, add calibrated intervals to (or adjust the</span>
<span class="sd">          existing intervals of) the forecasting model&#39;s predictions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cal_stride</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cal_stride</span>
        <span class="n">cal_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cal_length</span>
        <span class="n">metric</span><span class="p">,</span> <span class="n">metric_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_residuals_metric</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">residuals</span><span class="p">(</span>
            <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">,</span>
            <span class="n">historical_forecasts</span><span class="o">=</span><span class="n">forecasts</span><span class="p">,</span>
            <span class="n">overlap_end</span><span class="o">=</span><span class="n">overlap_end</span><span class="p">,</span>
            <span class="n">last_points_only</span><span class="o">=</span><span class="n">last_points_only</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">show_warnings</span><span class="o">=</span><span class="n">show_warnings</span><span class="p">,</span>
            <span class="n">values_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
            <span class="n">metric_kwargs</span><span class="o">=</span><span class="n">metric_kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">outer_iterator</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">forecasts</span><span class="p">,</span> <span class="n">residuals</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Use tqdm on the outer loop only if there&#39;s more than one series to iterate over</span>
            <span class="c1"># (otherwise use tqdm on the inner loop).</span>
            <span class="n">outer_iterator</span> <span class="o">=</span> <span class="n">_build_tqdm_iterator</span><span class="p">(</span>
                <span class="n">outer_iterator</span><span class="p">,</span>
                <span class="n">verbose</span><span class="p">,</span>
                <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">),</span>
                <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;conformal forecasts&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">cp_hfcs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">series_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">series_</span><span class="p">,</span> <span class="n">s_hfcs</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span> <span class="ow">in</span> <span class="n">outer_iterator</span><span class="p">:</span>
            <span class="n">cp_preds</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># no historical forecasts were generated</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">s_hfcs</span><span class="p">:</span>
                <span class="n">cp_hfcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp_preds</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">last_hfc</span> <span class="o">=</span> <span class="n">s_hfcs</span> <span class="k">if</span> <span class="n">last_points_only</span> <span class="k">else</span> <span class="n">s_hfcs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># compute the minimum required number of useful calibration residuals</span>
            <span class="c1"># at least one or `cal_length` examples</span>
            <span class="n">min_n_cal</span> <span class="o">=</span> <span class="n">cal_length</span> <span class="ow">or</span> <span class="mi">1</span>
            <span class="c1"># `last_points_only=False` requires additional examples to use most recent information</span>
            <span class="c1"># from all steps in the horizon</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">last_points_only</span><span class="p">:</span>
                <span class="n">min_n_cal</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">forecast_horizon</span> <span class="o">/</span> <span class="n">cal_stride</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># determine first forecast index for conformal prediction</span>
            <span class="c1"># we need at least one residual per point in the horizon prior to the first conformal forecast</span>
            <span class="n">horizon_ocs</span> <span class="o">=</span> <span class="n">forecast_horizon</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_shift</span>
            <span class="n">first_idx_train</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">horizon_ocs</span> <span class="o">/</span> <span class="n">cal_stride</span><span class="p">)</span>

            <span class="c1"># plus some additional examples based on `cal_length`</span>
            <span class="k">if</span> <span class="n">cal_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">first_idx_train</span> <span class="o">+=</span> <span class="n">cal_length</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># check if later we need to drop some residuals without useful information (unknown residuals)</span>
            <span class="k">if</span> <span class="n">overlap_end</span><span class="p">:</span>
                <span class="n">delta_end</span> <span class="o">=</span> <span class="n">n_steps_between</span><span class="p">(</span>
                    <span class="n">end</span><span class="o">=</span><span class="n">last_hfc</span><span class="o">.</span><span class="n">end_time</span><span class="p">(),</span>
                    <span class="n">start</span><span class="o">=</span><span class="n">series_</span><span class="o">.</span><span class="n">end_time</span><span class="p">(),</span>
                    <span class="n">freq</span><span class="o">=</span><span class="n">series_</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">delta_end</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># ignore residuals without useful information</span>
            <span class="k">if</span> <span class="n">last_points_only</span> <span class="ow">and</span> <span class="n">delta_end</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># useful residual information only up until the forecast *ending* at the last time step in `series`</span>
                <span class="n">ignore_n_residuals</span> <span class="o">=</span> <span class="n">delta_end</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">last_points_only</span> <span class="ow">and</span> <span class="n">delta_end</span> <span class="o">&gt;=</span> <span class="n">forecast_horizon</span><span class="p">:</span>
                <span class="c1"># useful residual information only up until the forecast *starting* at the last time step in `series`</span>
                <span class="n">ignore_n_residuals</span> <span class="o">=</span> <span class="n">delta_end</span> <span class="o">-</span> <span class="n">forecast_horizon</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># ignore at least one forecast residuals from the end, since we can only use prior residuals</span>
                <span class="n">ignore_n_residuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_shift</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="c1"># with last points only, ignore the last `horizon` residuals to avoid look-ahead bias</span>
                <span class="k">if</span> <span class="n">last_points_only</span><span class="p">:</span>
                    <span class="n">ignore_n_residuals</span> <span class="o">+=</span> <span class="n">forecast_horizon</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># get the last index respecting `cal_stride`</span>
            <span class="n">last_res_idx</span> <span class="o">=</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">ignore_n_residuals</span> <span class="o">/</span> <span class="n">cal_stride</span><span class="p">)</span>
            <span class="c1"># get only useful residuals</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="p">[:</span><span class="n">last_res_idx</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">first_idx_train</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_hfcs</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_n_cal</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Could not build the minimum required calibration input with the provided &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;`series` and `*_covariates` at series index: </span><span class="si">{</span><span class="n">series_idx</span><span class="si">}</span><span class="s2">. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Expected to generate at least `</span><span class="si">{</span><span class="n">min_n_cal</span><span class="si">}</span><span class="s2">` calibration forecasts with known residuals &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;before the first conformal forecast, but could only generate `</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="si">}</span><span class="s2">`.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># adjust first index based on `start`</span>
            <span class="n">first_idx_start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="s2">&quot;end&quot;</span><span class="p">:</span>
                <span class="c1"># called from `predict()`; start at the last forecast</span>
                <span class="n">first_idx_start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_hfcs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># called from `historical_forecasts()`: use user-defined start</span>
                <span class="c1"># the conformal forecastable index ranges from the start of the first valid historical</span>
                <span class="c1"># forecast until the start of the last historical forecast</span>
                <span class="n">historical_forecasts_time_index</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">s_hfcs</span><span class="p">[</span><span class="n">first_idx_train</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span><span class="p">(),</span>
                    <span class="n">s_hfcs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span><span class="p">(),</span>
                <span class="p">)</span>
                <span class="c1"># adjust forecast start points in case of output shift or `last_points_only=True`</span>
                <span class="n">adjust_idx</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_shift</span>
                    <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">last_points_only</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">forecast_horizon</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span> <span class="o">*</span> <span class="n">series_</span><span class="o">.</span><span class="n">freq</span>
                <span class="n">historical_forecasts_time_index</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">historical_forecasts_time_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">adjust_idx</span><span class="p">,</span>
                    <span class="n">historical_forecasts_time_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">adjust_idx</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># adjust forecastable times based on user start, assuming hfcs were generated with `stride=1`</span>
                <span class="n">first_start_time</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_adjust_historical_forecasts_time_index</span><span class="p">(</span>
                    <span class="n">series</span><span class="o">=</span><span class="n">series_</span><span class="p">,</span>
                    <span class="n">series_idx</span><span class="o">=</span><span class="n">series_idx</span><span class="p">,</span>
                    <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
                    <span class="n">start_format</span><span class="o">=</span><span class="n">start_format</span><span class="p">,</span>
                    <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span>
                    <span class="n">historical_forecasts_time_index</span><span class="o">=</span><span class="n">historical_forecasts_time_index</span><span class="p">,</span>
                    <span class="n">show_warnings</span><span class="o">=</span><span class="n">show_warnings</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># find position relative to start</span>
                <span class="n">first_idx_start</span> <span class="o">=</span> <span class="n">n_steps_between</span><span class="p">(</span>
                    <span class="n">first_start_time</span> <span class="o">+</span> <span class="n">adjust_idx</span><span class="p">,</span>
                    <span class="n">s_hfcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span><span class="p">(),</span>
                    <span class="n">freq</span><span class="o">=</span><span class="n">series_</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># adjust by stride</span>
                <span class="n">first_idx_start</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">first_idx_start</span> <span class="o">/</span> <span class="n">cal_stride</span><span class="p">)</span>

            <span class="c1"># get final first index</span>
            <span class="n">first_fc_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">first_idx_train</span><span class="p">,</span> <span class="n">first_idx_start</span><span class="p">])</span>
            <span class="c1"># bring `res` from shape (forecasting steps, n components, n past residuals) into</span>
            <span class="c1"># shape (forecasting steps, n components, n past residuals)</span>
            <span class="k">if</span> <span class="n">last_points_only</span><span class="p">:</span>
                <span class="c1"># -&gt; (1, n components, n samples * n past residuals)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># rearrange the residuals to avoid look-ahead bias and to have the same number of examples per</span>
                <span class="c1"># point in the horizon. We want the most recent residuals in the past for each step in the horizon.</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

                <span class="c1"># go through each step in the horizon, use all useful information from the end (most recent values),</span>
                <span class="c1"># and skip information at beginning (most distant past);</span>
                <span class="c1"># -&gt; (forecast horizon, n components, n past residuals)</span>
                <span class="n">res_</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">idx_horizon</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">forecast_horizon</span><span class="p">):</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">idx_horizon</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="c1"># ignore residuals at beginning</span>
                    <span class="n">idx_fc_start</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">forecast_horizon</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">cal_stride</span><span class="p">)</span>
                    <span class="c1"># keep as many residuals as possible from end</span>
                    <span class="n">idx_fc_end</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span>
                        <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">forecast_horizon</span> <span class="o">/</span> <span class="n">cal_stride</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">idx_fc_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">res_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">idx_fc_start</span> <span class="p">:</span> <span class="n">idx_fc_end</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">,</span> <span class="n">idx_horizon</span><span class="p">])</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">res_</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

            <span class="c1"># get the last conformal forecast index (exclusive) based on the residual examples</span>
            <span class="n">last_fc_idx</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">horizon_ocs</span> <span class="o">/</span> <span class="n">cal_stride</span><span class="p">)</span>

            <span class="c1"># forecasts are stridden, so stride must be relative</span>
            <span class="n">rel_stride</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">stride</span> <span class="o">/</span> <span class="n">cal_stride</span><span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">conformal_predict</span><span class="p">(</span><span class="n">idx_</span><span class="p">,</span> <span class="n">pred_vals_</span><span class="p">):</span>
                <span class="c1"># get the last residual index for calibration, `cal_end` is exclusive</span>
                <span class="c1"># to avoid look-ahead bias, use only residuals from before the conformal forecast start point;</span>
                <span class="c1"># for `last_points_only=True`, the last residual historically available at the forecasting</span>
                <span class="c1"># point is `horizon_ocs - 1` steps before. The same applies to `last_points_only=False` thanks to</span>
                <span class="c1"># the residual rearrangement</span>
                <span class="n">cal_end</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">first_fc_idx</span>
                    <span class="o">+</span> <span class="n">idx_</span> <span class="o">*</span> <span class="n">rel_stride</span>
                    <span class="o">-</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">horizon_ocs</span> <span class="o">/</span> <span class="n">cal_stride</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="c1"># optionally, use only `cal_length` residuals</span>
                <span class="n">cal_start</span> <span class="o">=</span> <span class="n">cal_end</span> <span class="o">-</span> <span class="n">cal_length</span> <span class="k">if</span> <span class="n">cal_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

                <span class="c1"># calibrate and apply interval to the forecasts</span>
                <span class="n">q_hat_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calibrate_interval</span><span class="p">(</span><span class="n">res</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">cal_start</span><span class="p">:</span><span class="n">cal_end</span><span class="p">])</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_interval</span><span class="p">(</span><span class="n">pred_vals_</span><span class="p">,</span> <span class="n">q_hat_</span><span class="p">)</span>

                <span class="c1"># optionally, generate samples from the intervals</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">predict_likelihood_parameters</span><span class="p">:</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">sample_from_quantiles</span><span class="p">(</span>
                        <span class="n">vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantiles</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="n">vals</span>

            <span class="c1"># historical conformal prediction</span>
            <span class="c1"># for each forecast, compute calibrated quantile intervals based on past residuals</span>
            <span class="k">if</span> <span class="n">last_points_only</span><span class="p">:</span>
                <span class="n">inner_iterator</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="n">s_hfcs</span><span class="o">.</span><span class="n">all_values</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="n">first_fc_idx</span><span class="p">:</span><span class="n">last_fc_idx</span><span class="p">:</span><span class="n">rel_stride</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inner_iterator</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s_hfcs</span><span class="p">[</span><span class="n">first_fc_idx</span><span class="p">:</span><span class="n">last_fc_idx</span><span class="p">:</span><span class="n">rel_stride</span><span class="p">])</span>

            <span class="n">comp_names_out</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">likelihood</span><span class="o">.</span><span class="n">component_names</span><span class="p">(</span><span class="n">series</span><span class="o">=</span><span class="n">series_</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">predict_likelihood_parameters</span>
                <span class="k">else</span> <span class="kc">None</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># only use progress bar if there&#39;s no outer loop</span>
                <span class="n">inner_iterator</span> <span class="o">=</span> <span class="n">_build_tqdm_iterator</span><span class="p">(</span>
                    <span class="n">inner_iterator</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="p">,</span>
                    <span class="n">total</span><span class="o">=</span><span class="p">(</span><span class="n">last_fc_idx</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">first_fc_idx</span><span class="p">)</span> <span class="o">//</span> <span class="n">rel_stride</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;conformal forecasts&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">last_points_only</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pred_vals</span> <span class="ow">in</span> <span class="n">inner_iterator</span><span class="p">:</span>
                    <span class="n">pred_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">pred_vals</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">cp_pred</span> <span class="o">=</span> <span class="n">conformal_predict</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">pred_vals</span><span class="p">)</span>
                    <span class="n">cp_preds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp_pred</span><span class="p">)</span>
                <span class="n">cp_preds</span> <span class="o">=</span> <span class="n">_build_forecast_series</span><span class="p">(</span>
                    <span class="n">points_preds</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">cp_preds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                    <span class="n">input_series</span><span class="o">=</span><span class="n">series_</span><span class="p">,</span>
                    <span class="n">custom_columns</span><span class="o">=</span><span class="n">comp_names_out</span><span class="p">,</span>
                    <span class="n">time_index</span><span class="o">=</span><span class="n">generate_index</span><span class="p">(</span>
                        <span class="n">start</span><span class="o">=</span><span class="n">s_hfcs</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="n">first_fc_idx</span><span class="p">],</span>
                        <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">cp_preds</span><span class="p">),</span>
                        <span class="n">freq</span><span class="o">=</span><span class="n">series_</span><span class="o">.</span><span class="n">freq</span> <span class="o">*</span> <span class="n">stride</span><span class="p">,</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">series_</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="p">),</span>
                    <span class="n">with_static_covs</span><span class="o">=</span><span class="ow">not</span> <span class="n">predict_likelihood_parameters</span><span class="p">,</span>
                    <span class="n">with_hierarchy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pred</span> <span class="ow">in</span> <span class="n">inner_iterator</span><span class="p">:</span>
                    <span class="n">pred_vals</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">all_values</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">cp_pred</span> <span class="o">=</span> <span class="n">conformal_predict</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">pred_vals</span><span class="p">)</span>
                    <span class="n">cp_pred</span> <span class="o">=</span> <span class="n">_build_forecast_series</span><span class="p">(</span>
                        <span class="n">points_preds</span><span class="o">=</span><span class="n">cp_pred</span><span class="p">,</span>
                        <span class="n">input_series</span><span class="o">=</span><span class="n">series_</span><span class="p">,</span>
                        <span class="n">custom_columns</span><span class="o">=</span><span class="n">comp_names_out</span><span class="p">,</span>
                        <span class="n">time_index</span><span class="o">=</span><span class="n">pred</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
                        <span class="n">with_static_covs</span><span class="o">=</span><span class="ow">not</span> <span class="n">predict_likelihood_parameters</span><span class="p">,</span>
                        <span class="n">with_hierarchy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">cp_preds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp_pred</span><span class="p">)</span>
            <span class="n">cp_hfcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp_preds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cp_hfcs</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_clean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cleans the model and sub-model.&quot;&quot;&quot;</span>
        <span class="n">cleaned_model</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_clean</span><span class="p">()</span>
        <span class="n">cleaned_model</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">cleaned_model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_clean</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cleaned_model</span>

<div class="viewcode-block" id="ConformalModel.save"><a class="viewcode-back" href="../../../../generated_api/darts.models.forecasting.conformal_models.html#darts.models.forecasting.conformal_models.ConformalModel.save">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span><span class="p">,</span> <span class="n">BinaryIO</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">clean</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">pkl_kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves the conformal model under a given path or file handle.</span>

<span class="sd">        Additionally, two files are stored if `self.model` is a `TorchForecastingModel`.</span>

<span class="sd">        Example for saving and loading a :class:`ConformalNaiveModel`:</span>

<span class="sd">            .. highlight:: python</span>
<span class="sd">            .. code-block:: python</span>

<span class="sd">                from darts.datasets import AirPassengersDataset</span>
<span class="sd">                from darts.models import ConformalNaiveModel, LinearRegressionModel</span>

<span class="sd">                series = AirPassengersDataset().load()</span>
<span class="sd">                forecasting_model = LinearRegressionModel(lags=4).fit(series)</span>

<span class="sd">                model = ConformalNaiveModel(</span>
<span class="sd">                    model=forecasting_model,</span>
<span class="sd">                    quantiles=[0.1, 0.5, 0.9],</span>
<span class="sd">                )</span>

<span class="sd">                model.save(&quot;my_model.pkl&quot;)</span>
<span class="sd">                model_loaded = ConformalNaiveModel.load(&quot;my_model.pkl&quot;)</span>
<span class="sd">            ..</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path</span>
<span class="sd">            Path or file handle under which to save the ensemble model at its current state. If no path is specified,</span>
<span class="sd">            the ensemble model is automatically saved under ``&quot;{ConformalNaiveModel}_{YYYY-mm-dd_HH_MM_SS}.pkl&quot;``.</span>
<span class="sd">            If the forecasting model is a `TorchForecastingModel`, two files (model object and checkpoint) are saved</span>
<span class="sd">            under ``&quot;{path}.{ModelClass}.pt&quot;`` and ``&quot;{path}.{ModelClass}.ckpt&quot;``.</span>
<span class="sd">        clean</span>
<span class="sd">            Whether to store a cleaned version of the model. If `True`, the training series and covariates are removed.</span>
<span class="sd">            If the underlying forecasting `model` is a `TorchForecastingModel`, will additionally remove all Lightning</span>
<span class="sd">            Trainer-related parameters.</span>

<span class="sd">            Note: After loading a model stored with `clean=True`, a `series` must be passed &#39;predict()&#39;,</span>
<span class="sd">            `historical_forecasts()` and other forecasting methods.</span>
<span class="sd">        pkl_kwargs</span>
<span class="sd">            Keyword arguments passed to `pickle.dump()`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># default path</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_save_path</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;.pkl&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="n">clean</span><span class="p">,</span> <span class="o">**</span><span class="n">pkl_kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">TORCH_AVAILABLE</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">),</span> <span class="n">TorchForecastingModel</span><span class="p">):</span>
            <span class="n">path_tfm</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.pt&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">path_tfm</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="n">clean</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConformalModel.load"><a class="viewcode-back" href="../../../../generated_api/darts.models.forecasting.conformal_models.html#darts.models.forecasting.conformal_models.ConformalModel.load">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load</span><span class="p">(</span>
        <span class="n">path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span><span class="p">,</span> <span class="n">BinaryIO</span><span class="p">],</span>
        <span class="n">pl_trainer_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ConformalModel&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads a model from a given path or file handle.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path</span>
<span class="sd">            Path or file handle from which to load the model.</span>
<span class="sd">        pl_trainer_kwargs</span>
<span class="sd">            Only effective if the underlying forecasting model is a `TorchForecastingModel`.</span>
<span class="sd">            Optionally, a set of kwargs to create a new Lightning Trainer used to configure the model for downstream</span>
<span class="sd">            tasks (e.g. prediction).</span>
<span class="sd">            Some examples include specifying the batch size or moving the model to CPU/GPU(s). Check the</span>
<span class="sd">            `Lightning Trainer documentation &lt;https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html&gt;`_</span>
<span class="sd">            for more information about the supported kwargs.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Only effective if the underlying forecasting model is a `TorchForecastingModel`.</span>
<span class="sd">            Additional kwargs for PyTorch Lightning&#39;s :func:`LightningModule.load_from_checkpoint()` method,</span>
<span class="sd">            For more information, read the `official documentation &lt;https://pytorch-lightning.readthedocs.io/en/stable/</span>
<span class="sd">            common/lightning_module.html#load-from-checkpoint&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">ConformalModel</span> <span class="o">=</span> <span class="n">GlobalForecastingModel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">TORCH_AVAILABLE</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">model</span><span class="p">),</span> <span class="n">TorchForecastingModel</span><span class="p">):</span>
            <span class="n">path_tfm</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.pt&quot;</span>
            <span class="n">model</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">TorchForecastingModel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
                <span class="n">path_tfm</span><span class="p">,</span>
                <span class="n">pl_trainer_kwargs</span><span class="o">=</span><span class="n">pl_trainer_kwargs</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">model</span></div>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_calibrate_interval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">residuals</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the lower and upper calibrated forecast intervals based on residuals.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        residuals</span>
<span class="sd">            The residuals are expected to have shape (horizon, n components, n historical forecasts * n samples)</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pred</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">q_hat</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Applies the calibrated interval to the predicted quantiles. Returns an array with `len(quantiles)`</span>
<span class="sd">        conformalized quantile predictions (lower quantiles, model forecast, upper quantiles) per component.</span>

<span class="sd">        E.g. output is `(target1_q1, target1_pred, target1_q2, target2_q1, ...)`</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_residuals_metric</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">METRIC_TYPE</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives the &quot;per time step&quot; metric and optional metric kwargs used to compute residuals /</span>
<span class="sd">        non-conformity scores.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_historical_forecasts_sanity_checks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_historical_forecasts_sanity_checks</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">is_conformal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">output_chunk_length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># conformal models can predict any horizon if the calibration set is large enough</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">output_chunk_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">output_chunk_shift</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_model_encoder_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not supported by `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">extreme_lags</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="nb">int</span><span class="p">,</span>
        <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not supported by `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">min_train_series_length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not supported by `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">min_train_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not supported by `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">supports_multivariate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">supports_multivariate</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">supports_past_covariates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">supports_past_covariates</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">supports_future_covariates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">supports_future_covariates</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">supports_static_covariates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">supports_static_covariates</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">supports_sample_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">supports_sample_weight</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">supports_likelihood_parameter_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">supports_probabilistic_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">uses_past_covariates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">uses_past_covariates</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">uses_future_covariates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">uses_future_covariates</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">uses_static_covariates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">uses_static_covariates</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">considers_static_covariates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">considers_static_covariates</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">likelihood</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Likelihood</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_likelihood</span></div>


<div class="viewcode-block" id="ConformalNaiveModel"><a class="viewcode-back" href="../../../../generated_api/darts.models.forecasting.conformal_models.html#darts.models.forecasting.conformal_models.ConformalNaiveModel">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">ConformalNaiveModel</span><span class="p">(</span><span class="n">ConformalModel</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">GlobalForecastingModel</span><span class="p">,</span>
        <span class="n">quantiles</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">symmetric</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">cal_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cal_stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">cal_num_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Naive Conformal Prediction Model.</span>

<span class="sd">        A probabilistic model that adds calibrated intervals around the median forecast from a pre-trained</span>
<span class="sd">        global forecasting model. It does not have to be trained and can generated calibrated forecasts</span>
<span class="sd">        directly using the underlying trained forecasting model. It supports two symmetry modes:</span>

<span class="sd">        - `symmetric=True`:</span>
<span class="sd">            - The lower and upper interval bounds are calibrated with the same magnitude.</span>
<span class="sd">            - Non-conformity scores: uses metric `ae()` (see absolute error :func:`~darts.metrics.metrics.ae`) to</span>
<span class="sd">              compute the non-conformity scores on the calibration set.</span>
<span class="sd">        - `symmetric=False`</span>
<span class="sd">            - The lower and upper interval bounds are calibrated separately.</span>
<span class="sd">            - Non-conformity scores: uses metric `err()` (see error :func:`~darts.metrics.metrics.err`) to compute the</span>
<span class="sd">              non-conformity scores on the calibration set for the upper bounds, an `-err()` for the lower bounds.</span>

<span class="sd">        Since it is a probabilistic model, you can generate forecasts in two ways (when calling `predict()`,</span>
<span class="sd">        `historical_forecasts()`, ...):</span>

<span class="sd">        - Predict the calibrated quantile intervals directly: Pass parameters `predict_likelihood_parameters=True`, and</span>
<span class="sd">          `num_samples=1` to the forecast method.</span>
<span class="sd">        - Predict stochastic samples from the calibrated quantile intervals: Pass parameters</span>
<span class="sd">          `predict_likelihood_parameters=False`, and `num_samples&gt;&gt;1` to the forecast method.</span>

<span class="sd">        Conformal models can be applied to any of Darts&#39; global forecasting model, as long as the model has been</span>
<span class="sd">        fitted before. In general the workflow of the models to produce one calibrated forecast/prediction is as</span>
<span class="sd">        follows:</span>

<span class="sd">        - Extract a calibration set: The calibration set for each conformal forecast is automatically extracted from</span>
<span class="sd">          the most recent past of your input series relative to the forecast start point. The number of calibration</span>
<span class="sd">          examples (forecast errors / non-conformity scores) to consider can be defined at model creation</span>
<span class="sd">          with parameter `cal_length`. Note that when using `cal_stride&gt;1`, a longer history is required since</span>
<span class="sd">          the calibration examples are generated with stridden historical forecasts.</span>
<span class="sd">        - Generate historical forecasts on the calibration set (using the forecasting model) with a stride `cal_stride`.</span>
<span class="sd">        - Compute the errors/non-conformity scores (as defined above) on these historical forecasts</span>
<span class="sd">        - Compute the quantile values from the errors / non-conformity scores (using our desired quantiles set at model</span>
<span class="sd">          creation with parameter `quantiles`).</span>
<span class="sd">        - Compute the conformal prediction: Using these quantile values, add calibrated intervals to the forecasting</span>
<span class="sd">          model&#39;s predictions.</span>

<span class="sd">        Some notes:</span>

<span class="sd">        - When computing `historical_forecasts()`, `backtest()`, `residuals()`, ... the above is applied for each</span>
<span class="sd">          forecast (the forecasting model&#39;s historical forecasts are only generated once for efficiency).</span>
<span class="sd">        - For multi-horizon forecasts, the above is applied for each step in the horizon separately.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model</span>
<span class="sd">            A pre-trained global forecasting model. See the list of models</span>
<span class="sd">            `here &lt;https://unit8co.github.io/darts/#forecasting-models&gt;`_.</span>
<span class="sd">        quantiles</span>
<span class="sd">            A list of quantiles centered around the median `q=0.5` to use. For example quantiles</span>
<span class="sd">            [0.1, 0.2, 0.5, 0.8 0.9] correspond to two intervals with (0.9 - 0.1) = 80%, and (0.8 - 0.2) 60% coverage</span>
<span class="sd">            around the median (model forecast).</span>
<span class="sd">        symmetric</span>
<span class="sd">            Whether to use symmetric non-conformity scores. If `True`, uses metric `ae()` (see</span>
<span class="sd">            :func:`~darts.metrics.metrics.ae`) to compute the non-conformity scores. If `False`, uses metric `-err()`</span>
<span class="sd">            (see :func:`~darts.metrics.metrics.err`) for the lower, and `err()` for the upper quantile interval bound.</span>
<span class="sd">        cal_length</span>
<span class="sd">            The number of past forecast errors / non-conformity scores to use as calibration for each conformal</span>
<span class="sd">            forecast (and each step in the horizon). If `None`, considers all scores.</span>
<span class="sd">        cal_stride</span>
<span class="sd">            The stride to apply when computing the historical forecasts and non-conformity scores on the calibration</span>
<span class="sd">            set. The actual conformal forecasts can have a different stride given with parameter `stride` in downstream</span>
<span class="sd">            tasks (e.g. historical forecasts, backtest, ...)</span>
<span class="sd">        cal_num_samples</span>
<span class="sd">            The number of samples to generate for each calibration forecast (if `model` is a probabilistic forecasting</span>
<span class="sd">            model). The non-conformity scores are computed on the quantile values of these forecasts (using quantiles</span>
<span class="sd">            `quantiles`). Uses `1` for deterministic models. The actual conformal forecasts can have a different number</span>
<span class="sd">            of samples given with parameter `num_samples` in downstream tasks (e.g. predict, historical forecasts, ...).</span>
<span class="sd">        random_state</span>
<span class="sd">            Control the randomness of probabilistic conformal forecasts (sample generation) across different runs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
            <span class="n">quantiles</span><span class="o">=</span><span class="n">quantiles</span><span class="p">,</span>
            <span class="n">symmetric</span><span class="o">=</span><span class="n">symmetric</span><span class="p">,</span>
            <span class="n">cal_length</span><span class="o">=</span><span class="n">cal_length</span><span class="p">,</span>
            <span class="n">cal_num_samples</span><span class="o">=</span><span class="n">cal_num_samples</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">cal_stride</span><span class="o">=</span><span class="n">cal_stride</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calibrate_interval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">residuals</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">q_hat_from_residuals</span><span class="p">(</span><span class="n">residuals_</span><span class="p">):</span>
            <span class="c1"># compute quantiles of shape (forecast horizon, n components, n quantile intervals)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span>
                <span class="n">residuals_</span><span class="p">,</span>
                <span class="n">q</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interval_range_sym</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;higher&quot;</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="c1"># residuals shape (horizon, n components, n past forecasts)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetric</span><span class="p">:</span>
            <span class="c1"># symmetric (from metric `ae()`)</span>
            <span class="n">q_hat</span> <span class="o">=</span> <span class="n">q_hat_from_residuals</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">q_hat</span><span class="p">,</span> <span class="n">q_hat</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># asymmetric (from metric `err()`)</span>
            <span class="n">q_hat</span> <span class="o">=</span> <span class="n">q_hat_from_residuals</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="o">-</span><span class="n">residuals</span><span class="p">,</span> <span class="n">residuals</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">n_comps</span> <span class="o">=</span> <span class="n">residuals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">q_hat</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n_comps</span><span class="p">,</span> <span class="p">:],</span> <span class="n">q_hat</span><span class="p">[:,</span> <span class="n">n_comps</span><span class="p">:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pred</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">q_hat</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
        <span class="c1"># convert stochastic predictions to median</span>
        <span class="k">if</span> <span class="n">pred</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># shape (forecast horizon, n components, n quantiles)</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pred</span> <span class="o">+</span> <span class="n">q_hat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pred</span><span class="p">,</span> <span class="n">pred</span> <span class="o">+</span> <span class="n">q_hat</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># -&gt; (forecast horizon, n components * n quantiles)</span>
        <span class="k">return</span> <span class="n">pred</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pred</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_residuals_metric</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">METRIC_TYPE</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">metrics</span><span class="o">.</span><span class="n">ae</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetric</span> <span class="k">else</span> <span class="n">metrics</span><span class="o">.</span><span class="n">err</span><span class="p">),</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="ConformalQRModel"><a class="viewcode-back" href="../../../../generated_api/darts.models.forecasting.conformal_models.html#darts.models.forecasting.conformal_models.ConformalQRModel">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">ConformalQRModel</span><span class="p">(</span><span class="n">ConformalModel</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">GlobalForecastingModel</span><span class="p">,</span>
        <span class="n">quantiles</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">symmetric</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">cal_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cal_stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">cal_num_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Conformalized Quantile Regression Model.</span>

<span class="sd">        A probabilistic model that calibrates the quantile predictions from a pre-trained probabilistic global</span>
<span class="sd">        forecasting model. It does not have to be trained and can generated calibrated forecasts</span>
<span class="sd">        directly using the underlying trained forecasting model. It supports two symmetry modes:</span>

<span class="sd">        - `symmetric=True`:</span>
<span class="sd">            - The lower and upper quantile predictions are calibrated with the same magnitude.</span>
<span class="sd">            - Non-conformity scores: uses metric `incs_qr(symmetric=True)` (see Non-Conformity Score for Quantile</span>
<span class="sd">              Regression :func:`~darts.metrics.metrics.incs_qr`) to compute the non-conformity scores on the calibration</span>
<span class="sd">              set.</span>
<span class="sd">        - `symmetric=False`</span>
<span class="sd">            - The lower and upper quantile predictions are calibrated separately.</span>
<span class="sd">            - Non-conformity scores: uses metric `incs_qr(symmetric=False)` (see Non-Conformity Score for Quantile</span>
<span class="sd">              Regression :func:`~darts.metrics.metrics.incs_qr`) to compute the non-conformity scores for the upper and</span>
<span class="sd">              lower bound separately.</span>

<span class="sd">        Since it is a probabilistic model, you can generate forecasts in two ways (when calling `predict()`,</span>
<span class="sd">        `historical_forecasts()`, ...):</span>

<span class="sd">        - Predict the calibrated quantile intervals directly: Pass parameters `predict_likelihood_parameters=True`, and</span>
<span class="sd">          `num_samples=1` to the forecast method.</span>
<span class="sd">        - Predict stochastic samples from the calibrated quantile intervals: Pass parameters</span>
<span class="sd">          `predict_likelihood_parameters=False`, and `num_samples&gt;&gt;1` to the forecast method.</span>

<span class="sd">        Conformal models can be applied to any of Darts&#39; global forecasting model, as long as the model has been</span>
<span class="sd">        fitted before. In general the workflow of the models to produce one calibrated forecast/prediction is as</span>
<span class="sd">        follows:</span>

<span class="sd">        - Extract a calibration set: The calibration set for each conformal forecast is automatically extracted from</span>
<span class="sd">          the most recent past of your input series relative to the forecast start point. The number of calibration</span>
<span class="sd">          examples (forecast errors / non-conformity scores) to consider can be defined at model creation with</span>
<span class="sd">          parameter `cal_length`. Note that when using `cal_stride&gt;1`, a longer history is required since the</span>
<span class="sd">          calibration examples are generated with stridden historical forecasts.</span>
<span class="sd">        - Generate historical forecasts (quantile predictions) on the calibration set (using the forecasting model)</span>
<span class="sd">          with a stride `cal_stride`.</span>
<span class="sd">        - Compute the errors/non-conformity scores (as defined above) on these historical quantile predictions</span>
<span class="sd">        - Compute the quantile values from the errors / non-conformity scores (using our desired quantiles set at model</span>
<span class="sd">          creation with parameter `quantiles`).</span>
<span class="sd">        - Compute the conformal prediction: Using these quantile values, calibrate the predicted quantiles from the</span>
<span class="sd">          forecasting model&#39;s predictions.</span>

<span class="sd">        Some notes:</span>

<span class="sd">        - When computing `historical_forecasts()`, `backtest()`, `residuals()`, ... the above is applied for each</span>
<span class="sd">          forecast (the forecasting model&#39;s historical forecasts are only generated once for efficiency).</span>
<span class="sd">        - For multi-horizon forecasts, the above is applied for each step in the horizon separately.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model</span>
<span class="sd">            A pre-trained global forecasting model. See the list of models</span>
<span class="sd">            `here &lt;https://unit8co.github.io/darts/#forecasting-models&gt;`_.</span>
<span class="sd">        quantiles</span>
<span class="sd">            A list of quantiles centered around the median `q=0.5` to use. For example quantiles</span>
<span class="sd">            [0.1, 0.2, 0.5, 0.8 0.9] correspond to two intervals with (0.9 - 0.1) = 80%, and (0.8 - 0.2) 60% coverage</span>
<span class="sd">            around the median (model forecast).</span>
<span class="sd">        symmetric</span>
<span class="sd">            Whether to use symmetric non-conformity scores. If `True`, uses symmetric metric</span>
<span class="sd">            `incs_qr(..., symmetric=True)` (see :func:`~darts.metrics.metrics.incs_qr`) to compute the non-conformity</span>
<span class="sd">            scores. If `False`, uses asymmetric metric `incs_qr(..., symmetric=False)` with individual scores for the</span>
<span class="sd">            lower- and upper quantile interval bounds.</span>
<span class="sd">        cal_length</span>
<span class="sd">            The number of past forecast errors / non-conformity scores to use as calibration for each conformal</span>
<span class="sd">            forecast (and each step in the horizon). If `None`, considers all scores.</span>
<span class="sd">        cal_stride</span>
<span class="sd">            The stride to apply when computing the historical forecasts and non-conformity scores on the calibration</span>
<span class="sd">            set. The actual conformal forecasts can have a different stride given with parameter `stride` in downstream</span>
<span class="sd">            tasks (e.g. historical forecasts, backtest, ...)</span>
<span class="sd">        cal_num_samples</span>
<span class="sd">            The number of samples to generate for each calibration forecast (if `model` is a probabilistic forecasting</span>
<span class="sd">            model). The non-conformity scores are computed on the quantile values of these forecasts (using quantiles</span>
<span class="sd">            `quantiles`). Uses `1` for deterministic models. The actual conformal forecasts can have a different number</span>
<span class="sd">            of samples given with parameter `num_samples` in downstream tasks (e.g. predict, historical forecasts, ...).</span>
<span class="sd">        random_state</span>
<span class="sd">            Control the randomness of probabilistic conformal forecasts (sample generation) across different runs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">supports_probabilistic_prediction</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;`model` must support probabilistic forecasting. Consider using a `likelihood` at &quot;</span>
                    <span class="s2">&quot;forecasting model creation, or use another conformal model.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
            <span class="n">quantiles</span><span class="o">=</span><span class="n">quantiles</span><span class="p">,</span>
            <span class="n">symmetric</span><span class="o">=</span><span class="n">symmetric</span><span class="p">,</span>
            <span class="n">cal_length</span><span class="o">=</span><span class="n">cal_length</span><span class="p">,</span>
            <span class="n">cal_num_samples</span><span class="o">=</span><span class="n">cal_num_samples</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
            <span class="n">cal_stride</span><span class="o">=</span><span class="n">cal_stride</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calibrate_interval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">residuals</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">n_comps</span> <span class="o">=</span> <span class="n">residuals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interval_range</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetric</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">n_intervals</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interval_range</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">q_hat_from_residuals</span><span class="p">(</span><span class="n">residuals_</span><span class="p">):</span>
            <span class="c1"># TODO: is there a more efficient way?</span>
            <span class="c1"># compute quantiles with shape (horizon, n components, n quantile intervals)</span>
            <span class="c1"># over all past residuals</span>
            <span class="n">q_hat_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span>
                <span class="n">residuals_</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interval_range_sym</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;higher&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">q_hat_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">residuals_</span><span class="p">),</span> <span class="n">n_comps</span><span class="p">,</span> <span class="n">n_intervals</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_intervals</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_comps</span><span class="p">):</span>
                    <span class="n">q_hat_</span><span class="p">[:,</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">q_hat_tmp</span><span class="p">[:,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">n_intervals</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">q_hat_</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetric</span><span class="p">:</span>
            <span class="c1"># symmetric has one nc-score per interval (from metric `incs_qr(symmetric=True)`)</span>
            <span class="c1"># residuals shape (horizon, n components * n intervals, n past forecasts)</span>
            <span class="n">q_hat</span> <span class="o">=</span> <span class="n">q_hat_from_residuals</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">q_hat</span><span class="p">,</span> <span class="n">q_hat</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># asymmetric has two nc-score per interval (for lower and upper quantiles, from metric</span>
            <span class="c1"># `incs_qr(symmetric=False)`)</span>
            <span class="c1"># lower and upper residuals are concatenated along axis=1;</span>
            <span class="c1"># residuals shape (horizon, n components * n intervals * 2, n past forecasts)</span>
            <span class="n">half_idx</span> <span class="o">=</span> <span class="n">residuals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">q_hat_lo</span> <span class="o">=</span> <span class="n">q_hat_from_residuals</span><span class="p">(</span><span class="n">residuals</span><span class="p">[:,</span> <span class="p">:</span><span class="n">half_idx</span><span class="p">])</span>
            <span class="n">q_hat_hi</span> <span class="o">=</span> <span class="n">q_hat_from_residuals</span><span class="p">(</span><span class="n">residuals</span><span class="p">[:,</span> <span class="n">half_idx</span><span class="p">:])</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">q_hat_lo</span><span class="p">,</span> <span class="n">q_hat_hi</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pred</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">q_hat</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
        <span class="c1"># get quantile predictions with shape (n times, n components, n quantiles)</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantiles</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="c1"># shape (forecast horizon, n components, n quantiles)</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">pred</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_median</span><span class="p">]</span> <span class="o">+</span> <span class="n">q_hat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># lower quantiles</span>
                <span class="n">pred</span><span class="p">[:,</span> <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_median</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_median</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1"># model forecast</span>
                <span class="n">pred</span><span class="p">[:,</span> <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_median</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">q_hat</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># upper quantiles</span>
            <span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># -&gt; (forecast horizon, n components * n quantiles)</span>
        <span class="k">return</span> <span class="n">pred</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pred</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_residuals_metric</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">METRIC_TYPE</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="n">metrics</span><span class="o">.</span><span class="n">incs_qr</span><span class="p">,</span> <span class="p">{</span>
            <span class="s2">&quot;q_interval&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_interval</span><span class="p">,</span>
            <span class="s2">&quot;symmetric&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetric</span><span class="p">,</span>
        <span class="p">}</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_calibration_hfc_start</span><span class="p">(</span>
    <span class="n">series</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
    <span class="n">horizon</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">output_chunk_shift</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">cal_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">cal_stride</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]]],</span>
    <span class="n">start_format</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">]],</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the calibration start point (CSP) (for historical forecasts on calibration set).</span>

<span class="sd">    - If `start=None`, the CSP is also `None` (all possible hfcs).</span>
<span class="sd">    - If `start=&quot;end&quot;` (when calling `predict()`), returns the CSP as a positional index relative to the end of the</span>
<span class="sd">      series (&lt;0).</span>
<span class="sd">    - Otherwise (when calling `historical_forecasts()`), the CSP is the start value (`start_format=&quot;value&quot;`) or start</span>
<span class="sd">      position (`start_format=&quot;position&quot;`) adjusted by the positions computed for the case above.</span>

<span class="sd">    If this function is called from `historical_forecasts`, the sanity checks guarantee the following:</span>

<span class="sd">    - `start` cannot be a `float`</span>
<span class="sd">    - when `start_format=&#39;value&#39;`, all `series` have the same frequency</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">start_format</span>

    <span class="n">cal_start_format</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">]</span>
    <span class="n">horizon_ocs</span> <span class="o">=</span> <span class="n">horizon</span> <span class="o">+</span> <span class="n">output_chunk_shift</span>
    <span class="k">if</span> <span class="n">cal_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># we only need `cal_length` forecasts with stride `cal_stride` before the `predict()` start point;</span>
        <span class="c1"># the last valid calibration forecast must start at least `horizon_ocs` before `predict()` start</span>
        <span class="n">add_steps</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">horizon_ocs</span> <span class="o">/</span> <span class="n">cal_stride</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">start_idx_rel</span> <span class="o">=</span> <span class="o">-</span><span class="n">cal_stride</span> <span class="o">*</span> <span class="p">(</span><span class="n">cal_length</span> <span class="o">+</span> <span class="n">add_steps</span><span class="p">)</span>
        <span class="n">cal_start_format</span> <span class="o">=</span> <span class="s2">&quot;position&quot;</span>
    <span class="k">elif</span> <span class="n">cal_stride</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># we need all forecasts with stride `cal_stride` before the `predict()` start point</span>
        <span class="n">max_len_series</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">series_</span><span class="p">)</span> <span class="k">for</span> <span class="n">series_</span> <span class="ow">in</span> <span class="n">series</span><span class="p">)</span>
        <span class="n">start_idx_rel</span> <span class="o">=</span> <span class="o">-</span><span class="n">cal_stride</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_len_series</span> <span class="o">/</span> <span class="n">cal_stride</span><span class="p">)</span>
        <span class="n">cal_start_format</span> <span class="o">=</span> <span class="s2">&quot;position&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># we need all possible forecasts with `cal_stride=1`</span>
        <span class="n">start_idx_rel</span><span class="p">,</span> <span class="n">cal_start_format</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span>

    <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="s2">&quot;end&quot;</span><span class="p">:</span>
        <span class="c1"># `predict()` is relative to the end</span>
        <span class="k">return</span> <span class="n">start_idx_rel</span><span class="p">,</span> <span class="n">cal_start_format</span>

    <span class="c1"># `historical_forecasts()` is relative to `start`</span>
    <span class="n">start_is_position</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span>
        <span class="n">start_format</span> <span class="o">==</span> <span class="s2">&quot;position&quot;</span> <span class="ow">or</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_has_datetime_index</span>
    <span class="p">)</span>
    <span class="n">cal_start_format</span> <span class="o">=</span> <span class="n">start_format</span>
    <span class="k">if</span> <span class="n">start_idx_rel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cal_start</span> <span class="o">=</span> <span class="n">start_idx_rel</span>
    <span class="k">elif</span> <span class="n">start_is_position</span><span class="p">:</span>
        <span class="n">cal_start</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">start_idx_rel</span>
        <span class="c1"># if start switches sign, it would be relative to the end;</span>
        <span class="c1"># correct it to be positive (relative to beginning)</span>
        <span class="k">if</span> <span class="n">cal_start</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
            <span class="n">cal_start</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">cal_start</span><span class="p">)</span> <span class="o">/</span> <span class="n">cal_stride</span><span class="p">)</span> <span class="o">*</span> <span class="n">cal_stride</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cal_start</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">start_idx_rel</span> <span class="o">*</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">freq</span>
    <span class="k">return</span> <span class="n">cal_start</span><span class="p">,</span> <span class="n">cal_start_format</span>
</pre></div>

              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../../../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2020 - 2025, Unit8 SA (Apache 2.0 License).<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.0.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>