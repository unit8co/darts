
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>darts.utils.data.tabularization.tabularization &#8212; darts  documentation</title>
    
  <link href="../../../../../_static/css/theme.css" rel="stylesheet">
  <link href="../../../../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/css/blank.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/graphviz.css" />
    
  <link rel="preload" as="script" href="../../../../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js"></script>
    <script src="../../../../../_static/jquery.js"></script>
    <script src="../../../../../_static/underscore.js"></script>
    <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <link rel="shortcut icon" href="../../../../../_static/docs-favicon.ico"/>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../../../index.html">
  <img src="../../../../../_static/darts-logo-trim.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../../README.html">
  Home
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../../quickstart/00-quickstart.html">
  Quickstart
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../../userguide.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../../generated_api/darts.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../../examples.html">
  Examples
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../../release_notes/RELEASE_NOTES.html">
  Release Notes
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/unit8co/darts" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/unit8co" rel="noopener" target="_blank" title="Twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for darts.utils.data.tabularization.tabularization</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">inf</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.lib.stride_tricks</span><span class="w"> </span><span class="kn">import</span> <span class="n">as_strided</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">darts</span><span class="w"> </span><span class="kn">import</span> <span class="n">TimeSeries</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">darts.logging</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_logger</span><span class="p">,</span> <span class="n">raise_log</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">darts.utils.data.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">_process_sample_weight</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">darts.utils.ts_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_single_series</span><span class="p">,</span> <span class="n">series2seq</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">darts.utils.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">n_steps_between</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">NP_2_OR_ABOVE</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="n">STABLE_SORT_KWARGS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stable&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span> <span class="k">if</span> <span class="n">NP_2_OR_ABOVE</span> <span class="k">else</span> <span class="p">{</span><span class="s2">&quot;kind&quot;</span><span class="p">:</span> <span class="s2">&quot;stable&quot;</span><span class="p">}</span>

<span class="n">ArrayOrArraySequence</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span>


<div class="viewcode-block" id="create_lagged_data"><a class="viewcode-back" href="../../../../../generated_api/darts.utils.data.tabularization.tabularization.html#darts.utils.data.tabularization.tabularization.create_lagged_data">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">create_lagged_data</span><span class="p">(</span>
    <span class="n">target_series</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">lags</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">lags_past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">lags_future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">output_chunk_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">output_chunk_shift</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">uses_static_covariates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">last_static_covariates_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_samples_per_ts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">multi_models</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">check_inputs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">use_moving_windows</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">is_training</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">concatenate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">sample_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">show_warnings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
    <span class="n">ArrayOrArraySequence</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">ArrayOrArraySequence</span><span class="p">],</span>
    <span class="n">Sequence</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">],</span>
    <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayOrArraySequence</span><span class="p">],</span>
<span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates the features array `X` and labels array `y` to train a lagged-variables `SKLearnModel` when</span>
<span class="sd">    `is_training = True`; alternatively, creates the features array `X` to produce a series of prediction from an</span>
<span class="sd">    already-trained model when `is_training = False`. In both cases, a list of time indices corresponding to</span>
<span class="sd">    each generated observation is also returned.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Instead of calling `create_lagged_data` directly, it is instead recommended that:</span>
<span class="sd">        - `create_lagged_training_data` be called if one wishes to create the `X` and `y` arrays</span>
<span class="sd">        to train an `SKLearnModel`.</span>
<span class="sd">        - `create_lagged_prediction_data` be called if one wishes to create the `X` array required</span>
<span class="sd">        to generate a prediction from an already-trained `SKLearnModel`.</span>
<span class="sd">    This is because even though both of these functions are merely wrappers around `create_lagged_data`, their</span>
<span class="sd">    call signatures are more easily interpreted than `create_lagged_data`. For example,</span>
<span class="sd">    `create_lagged_prediction_data` does not accept `output_chunk_length` nor `multi_models` as inputs, since</span>
<span class="sd">    these inputs are not used when constructing prediction data. Similarly, `create_lagged_prediction_data`</span>
<span class="sd">    returns only `X` and `times` as outputs, as opposed to returning `y` as `None` along with `X` and `times`.</span>

<span class="sd">    The `X` array is constructed from the lagged values of up to three separate timeseries:</span>
<span class="sd">        1. The `target_series`, which contains the values we&#39;re trying to predict. An `SKLearnModel` that</span>
<span class="sd">        uses previous values of the target its predicting is referred to as *autoregressive*; please refer to</span>
<span class="sd">        [1]_ for further details about autoregressive timeseries models.</span>
<span class="sd">        2. The past covariates series, which contains values that are *not* known into the future. Unlike</span>
<span class="sd">        the target series, however, past covariates are *not* to be predicted by the `SKLearnModel`.</span>
<span class="sd">        3. The future covariates (AKA &#39;exogenous&#39; covariates) series, which contains values that are known</span>
<span class="sd">        into the future, even beyond the data in `target_series` and `past_covariates`.</span>
<span class="sd">    See [2]_ for a more detailed discussion about target, past, and future covariates. Conversely, `y` is</span>
<span class="sd">    comprised only of the lagged values of `target_series`.</span>

<span class="sd">    The shape of `X` is:</span>
<span class="sd">        `X.shape = (n_observations, n_lagged_features, n_samples)`,</span>
<span class="sd">    where `n_observations` equals either the number of time points shared between all specified series,</span>
<span class="sd">    or `max_samples_per_ts`, whichever is smallest.</span>
<span class="sd">    The shape of `y` is:</span>
<span class="sd">        `y.shape = (n_observations, output_chunk_length, n_samples)`,</span>
<span class="sd">    if `multi_models = True`, otherwise:</span>
<span class="sd">        `y.shape = (n_observations, 1, n_samples)`.</span>

<span class="sd">    Along the `n_lagged_features` axis, `X` has the following structure (for `*_lags=[-2,-1]` and</span>
<span class="sd">    `*_series.n_components = 2`):</span>
<span class="sd">        lagged_target | lagged_past_covariates | lagged_future_covariates</span>
<span class="sd">    where each `lagged_*` has the following structure:</span>
<span class="sd">        lag_-2_comp_1_* | lag_-2_comp_2_* | lag_-1_comp_1_* | lag_-1_comp_2_*</span>

<span class="sd">    Along the `n_lagged_labels` axis, `y` has the following structure (for `output_chunk_length=4` and</span>
<span class="sd">    `target_series.n_components=2`):</span>
<span class="sd">        lag_+0_comp_1_target | lag_+0_comp_2_target | ... | lag_+3_comp_1_target | lag_+3_comp_2_target</span>

<span class="sd">    The `lags` and `lags_past_covariates` must contain only values less than or equal to -1. In other words, one</span>
<span class="sd">    cannot use the value of either of these series at time `t` to predict the value of the target series at the</span>
<span class="sd">    same time `t`; this is because the values of `target_series` and `past_covariates` at time `t` aren&#39;t available</span>
<span class="sd">    at prediction time, by definition. Conversely, since the values of `future_covariates` are known into the future,</span>
<span class="sd">    `lags_future_covariates` can contain negative, positive, and/or zero lag values (i.e. we *can* use the values of</span>
<span class="sd">    `future_covariates` at time `t` or beyond to predict the value of `target_series` at time `t`).</span>

<span class="sd">    The exact method used to construct `X` and `y` depends on whether all specified timeseries are</span>
<span class="sd">    of the same frequency or not:</span>
<span class="sd">        - If all specified timeseries are of the same frequency, `strided_moving_window` is used to extract</span>
<span class="sd">        contiguous time blocks from each timeseries; the lagged variables are then extracted from each window.</span>
<span class="sd">        - If all specified timeseries are *not* of the same frequency, then `find_shared_times` is first used</span>
<span class="sd">        to find those times common to all three timeseries, after which the lagged features are extracted by</span>
<span class="sd">        offsetting the time indices of these common times by the requested lags.</span>
<span class="sd">    In cases where it can be validly applied, the &#39;moving window&#39; method is expected to be faster than the</span>
<span class="sd">    &#39;intersecting time&#39; method. However, in exceptional cases where only a small number of lags are being</span>
<span class="sd">    extracted, but the difference between the lag values is large (e.g. `lags = [-1, -1000]`), the &#39;moving</span>
<span class="sd">    window&#39; method is expected to consume significantly more memory, since it extracts all series values</span>
<span class="sd">    between the maximum and minimum lags as &#39;windows&#39;, before actually extracting the specific requested lag values.</span>

<span class="sd">    In order for the lagged features of a series to be added to `X`, *both* that series and the corresponding lags</span>
<span class="sd">    must be specified; if a series is specified without the corresponding lags, that series will be ignored and not</span>
<span class="sd">    added to `X`. `X` and `y` arrays are constructed independently over the samples dimension (i.e. the second axis)</span>
<span class="sd">    of each series.</span>

<span class="sd">    If the provided series are stochastic (i.e. `series.n_components &gt; 1`), then an `X` and `y` array will be</span>
<span class="sd">    constructed for each sample; the arrays corresponding to each sample are concatenated together along the `2`nd</span>
<span class="sd">    axis of `X` and `y`. In other words, `create_lagged_data` is vectorized over the sample axis of the `target_series`,</span>
<span class="sd">    `past_covariates`, and `future_covariates` inputs. Importantly, if stochastic series are provided, each series must</span>
<span class="sd">    have the same number of samples, otherwise an error will be thrown.</span>

<span class="sd">    Each series input (i.e. `target_series`, `past_covariates`, and `future_covariates`) can be specified either as</span>
<span class="sd">    a single `TimeSeries`, or as a `Sequence` of `TimeSeries`; the specified series must all be of the same type,</span>
<span class="sd">    however (i.e. either all `TimeSeries` or all `Sequence[TimeSeries]`). If `Sequence[TimeSeries]` are specified,</span>
<span class="sd">    then a feature matrix `X` and labels array `y` will be constructed using the corresponding `TimeSeries` in</span>
<span class="sd">    each `Sequence` (i.e. the first `TimeSeries` in each `Sequence` are used to create an `X` and `y`, then</span>
<span class="sd">    the second `TimeSeries` in each `Sequence` are used to create an `X` and `y`, etc.). If `concatenate = True`,</span>
<span class="sd">    these `X`&#39;s and `y`&#39;s will be concatenated along the `0`th axis; otherwise, a list of `X` and `y` array will</span>
<span class="sd">    be returned. Note that `times` is always returned as a `Sequence[pd.Index]`, however, even when</span>
<span class="sd">    `concatenate = True`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target_series</span>
<span class="sd">        Optionally, the series for the `SKLearnModel` to predict. Must be specified if `is_training = True`.</span>
<span class="sd">        Can be specified as either a `TimeSeries` or as a `Sequence[TimeSeries]`.</span>
<span class="sd">    past_covariates</span>
<span class="sd">        Optionally, the past covariates series that the `SKLearnModel` will use as inputs. Unlike the</span>
<span class="sd">        `target_series`, `past_covariates` are *not* to be predicted by the `SKLearnModel`. Can be</span>
<span class="sd">        specified as either a `TimeSeries` or as a `Sequence[TimeSeries]`.</span>
<span class="sd">    future_covariates</span>
<span class="sd">        Optionally, the future covariates (i.e. exogenous covariates) series that the `SKLearnModel` will</span>
<span class="sd">        use as inputs. Can be specified as either a `TimeSeries` or as a `Sequence[TimeSeries]`.</span>
<span class="sd">    lags</span>
<span class="sd">        Optionally, the lags of the target series to be used as (autoregressive) features. If not specified,</span>
<span class="sd">        autoregressive features will *not* be added to `X`. Each lag value is assumed to be negative (e.g.</span>
<span class="sd">        `lags = [-3, -1]` will extract `target_series` values which are 3 time steps and 1 time step away from</span>
<span class="sd">        the current value). If the lags are provided as a dictionary, the lags values are specific to each</span>
<span class="sd">        component in the target series.</span>
<span class="sd">    lags_past_covariates</span>
<span class="sd">        Optionally, the lags of `past_covariates` to be used as features. Like `lags`, each lag value is assumed to</span>
<span class="sd">        be less than or equal to -1. If the lags are provided as a dictionary, the lags values are specific to each</span>
<span class="sd">        component in the past covariates series.</span>
<span class="sd">    lags_future_covariates</span>
<span class="sd">        Optionally, the lags of `future_covariates` to be used as features. Unlike `lags` and</span>
<span class="sd">        `lags_past_covariates`, `lags_future_covariates` values can be positive (i.e. use values *after* time `t`</span>
<span class="sd">        to predict target at time `t`), zero (i.e. use values *at* time `t` to predict target at time `t`), and/or</span>
<span class="sd">        negative (i.e. use values *before* time `t` to predict target at time `t`). If `output_chunk_shift &gt; 0`, the</span>
<span class="sd">        lags are relative to the first time step of the shifted output chunk. If the lags are provided as</span>
<span class="sd">        a dictionary, the lags values are specific to each component in the future covariates series.</span>
<span class="sd">    output_chunk_length</span>
<span class="sd">        Optionally, the number of time steps ahead into the future the `SKLearnModel` is to predict. Must</span>
<span class="sd">        best specified if `is_training = True`.</span>
<span class="sd">    output_chunk_shift</span>
<span class="sd">        Optionally, the number of time steps to shift the output chunk ahead into the future.</span>
<span class="sd">    uses_static_covariates</span>
<span class="sd">        Whether the model uses/expects static covariates. If `True`, it enforces that static covariates must</span>
<span class="sd">        have identical shapes across all target series.</span>
<span class="sd">    last_static_covariates_shape</span>
<span class="sd">        Optionally, the last observed shape of the static covariates. This is ``None`` before fitting, or when</span>
<span class="sd">        `uses_static_covariates` is ``False``.</span>
<span class="sd">    max_samples_per_ts</span>
<span class="sd">        Optionally, the maximum number of samples to be drawn for training/validation; only the most recent</span>
<span class="sd">        samples are kept. In theory, specifying a smaller `max_samples_per_ts` should reduce computation time,</span>
<span class="sd">        especially in cases where many observations could be generated.</span>
<span class="sd">    multi_models</span>
<span class="sd">        Optionally, specifies whether the `SKLearnModel` predicts multiple time steps into the future. If `True`,</span>
<span class="sd">        then the `SKLearnModel` is assumed to predict all time steps from time `t` to `t+output_chunk_length`.</span>
<span class="sd">        If `False`, then the `SKLearnModel` is assumed to predict *only* the time step at `t+output_chunk_length`.</span>
<span class="sd">        This input is ignored if `is_training = False`.</span>
<span class="sd">    check_inputs</span>
<span class="sd">        Optionally, specifies that the `lags_*` and `series_*` inputs should be checked for validity. Should be set</span>
<span class="sd">        to `False` if inputs have already been checked for validity (e.g. inside the `__init__` of a class), otherwise</span>
<span class="sd">        should be set to `True`.</span>
<span class="sd">    use_moving_windows</span>
<span class="sd">        Optionally, specifies that the &#39;moving window&#39; method should be used to construct `X` and `y` if all</span>
<span class="sd">        provided series are of the same frequency. If `use_moving_windows = False`, the &#39;time intersection&#39; method</span>
<span class="sd">        will always be used, even when all provided series are of the same frequency. In general, setting</span>
<span class="sd">        to `True` results in faster tabularization at the potential cost of higher memory usage. See Notes for further</span>
<span class="sd">        details.</span>
<span class="sd">    is_training</span>
<span class="sd">        Optionally, specifies whether the constructed lagged data are to be used for training an `SKLearnModel`</span>
<span class="sd">        (i.e. `is_training = True`), or for generating predictions from an already-trained `SKLearnModel` (i.e.</span>
<span class="sd">        `is_training = False`). If `is_training = True`, `target_series` and `output_chunk_length` must be specified,</span>
<span class="sd">        the `multi_models` input is utilised, and a label array `y` is returned. Conversely, if `is_training = False`,</span>
<span class="sd">        then `target_series` and `output_chunk_length` do not need to be specified, the `multi_models` input is ignored,</span>
<span class="sd">        and the returned `y` value is `None`.</span>
<span class="sd">    concatenate</span>
<span class="sd">        Optionally, specifies that `X` and `y` should both be returned as single `np.ndarray`s, instead of as</span>
<span class="sd">        a `Sequence[np.ndarray]`. If each series input is specified as a `Sequence[TimeSeries]` and</span>
<span class="sd">        `concatenate = False`, `X` and `y` will be lists whose `i`th element corresponds to the feature matrix or label</span>
<span class="sd">        array formed by the `i`th `TimeSeries` in each `Sequence[TimeSeries]` input. Conversely, if `concatenate = True`</span>
<span class="sd">        when `Sequence[TimeSeries]` are provided, then `X` and `y` will be arrays created by concatenating all</span>
<span class="sd">        feature/label arrays formed by each `TimeSeries` along the `0`th axis. Note that `times` is still returned as</span>
<span class="sd">        `Sequence[pd.Index]`, even when `concatenate = True`.</span>
<span class="sd">    sample_weight</span>
<span class="sd">        Optionally, some sample weights to apply to the target `series` labels. They are applied per observation,</span>
<span class="sd">        per label (each step in `output_chunk_length`), and per component.</span>
<span class="sd">        If a series or sequence of series, then those weights are used. If the weight series only have a single</span>
<span class="sd">        component / column, then the weights are applied globally to all components in `series`. Otherwise, for</span>
<span class="sd">        component-specific weights, the number of components must match those of `series`.</span>
<span class="sd">        If a string, then the weights are generated using built-in weighting functions. The available options are</span>
<span class="sd">        `&quot;linear&quot;` or `&quot;exponential&quot;` decay - the further in the past, the lower the weight. The weights are</span>
<span class="sd">        computed globally based on the length of the longest series in `series`. Then for each series, the weights</span>
<span class="sd">        are extracted from the end of the global weights. This gives a common time weighting across all series.</span>
<span class="sd">    stride</span>
<span class="sd">        The number of time steps between consecutive samples, applied starting from the end of the series. This should</span>
<span class="sd">        be used with caution as it might introduce bias in the forecasts.</span>
<span class="sd">    show_warnings</span>
<span class="sd">        Whether to show warnings.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X</span>
<span class="sd">        The constructed features array(s), with shape `(n_observations, n_lagged_features, n_samples)`.</span>
<span class="sd">        If the series inputs were specified as `Sequence[TimeSeries]` and `concatenate = False`, then `X`</span>
<span class="sd">        is returned as a `Sequence[np.array]`; otherwise, `X` is returned as a single `np.array`.</span>
<span class="sd">    y</span>
<span class="sd">        The constructed labels array. If `multi_models = True`, then `y` is a</span>
<span class="sd">        `(n_observations, output_chunk_length, n_samples)`-shaped array; conversely, if</span>
<span class="sd">        `multi_models =  False`, then `y` is a `(n_observations, 1, n_samples)`-shaped array.</span>
<span class="sd">        If the series inputs were specified as `Sequence[TimeSeries]` and `concatenate = False`, then `y`</span>
<span class="sd">        is returned as a `Sequence[np.array]`; otherwise, `y` is returned as a single `np.array`.</span>
<span class="sd">    times</span>
<span class="sd">        The `time_index` of each observation in `X` and `y`, returned as a `Sequence` of `pd.Index`es.</span>
<span class="sd">        If the series inputs were specified as `Sequence[TimeSeries]`, then the `i`th list element</span>
<span class="sd">        gives the times of those observations formed using the `i`th `TimeSeries` object in each</span>
<span class="sd">        `Sequence`. Otherwise, if the series inputs were specified as `TimeSeries`, the only</span>
<span class="sd">        element is the times of those observations formed from the lone `TimeSeries` inputs.</span>
<span class="sd">    last_static_covariates_shape</span>
<span class="sd">        The last observed shape of the static covariates. This is ``None`` when `uses_static_covariates`</span>
<span class="sd">        is ``False``.</span>
<span class="sd">    sample_weight</span>
<span class="sd">        The weights to apply to each observation in `X` and output step `y`, returned as a `Sequence` of `np.ndarray`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the specified time series do not share any times for which features (and labels if `is_training = True`) can</span>
<span class="sd">        be constructed.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If no lags are specified, or if any of the specified lag values are non-negative.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If any of the series are too short to create features and/or labels for the requested lags and</span>
<span class="sd">        `output_chunk_length` values.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `target_series` and/or `output_chunk_length` are *not* specified when `is_training = True`.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the provided series do not share the same type of `time_index` (e.g. `target_series` uses a</span>
<span class="sd">        pd.RangeIndex, but `future_covariates` uses a `pd.DatetimeIndex`).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://otexts.com/fpp2/AR.html#AR</span>
<span class="sd">    .. [2] https://unit8.com/resources/time-series-forecasting-using-past-and-future-external-data-with-darts/</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">        tabularization.create_lagged_component_names : return the lagged features names as a list of strings.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_training</span> <span class="ow">and</span> <span class="p">(</span><span class="n">target_series</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">raise_log</span><span class="p">(</span>
            <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must specify `target_series` if `is_training = True`.&quot;</span><span class="p">),</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># ensure list of TimeSeries format</span>
    <span class="n">target_series</span> <span class="o">=</span> <span class="n">series2seq</span><span class="p">(</span><span class="n">target_series</span><span class="p">)</span>
    <span class="n">past_covariates</span> <span class="o">=</span> <span class="n">series2seq</span><span class="p">(</span><span class="n">past_covariates</span><span class="p">)</span>
    <span class="n">future_covariates</span> <span class="o">=</span> <span class="n">series2seq</span><span class="p">(</span><span class="n">future_covariates</span><span class="p">)</span>

    <span class="n">seq_ts_lens</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">seq_ts</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">seq_ts</span> <span class="ow">in</span> <span class="p">(</span><span class="n">target_series</span><span class="p">,</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">seq_ts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="p">]</span>
    <span class="n">seq_ts_lens</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">seq_ts_lens</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq_ts_lens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">raise_log</span><span class="p">(</span>
            <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Must specify the same number of `TimeSeries` for each series input.&quot;</span>
            <span class="p">),</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># process / check sample weight and generate series in case of built-in weight generator</span>
    <span class="n">sample_weight</span> <span class="o">=</span> <span class="n">_process_sample_weight</span><span class="p">(</span><span class="n">sample_weight</span><span class="p">,</span> <span class="n">target_series</span><span class="p">)</span>

    <span class="n">lags_passed_as_dict</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">lags_</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">lags_</span> <span class="ow">in</span> <span class="p">[</span><span class="n">lags</span><span class="p">,</span> <span class="n">lags_past_covariates</span><span class="p">,</span> <span class="n">lags_future_covariates</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">use_moving_windows</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lags_passed_as_dict</span><span class="p">:</span>
        <span class="n">raise_log</span><span class="p">(</span>
            <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`use_moving_windows=False` is not supported when any of the lags is provided as a dictionary. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Received: </span><span class="si">{</span><span class="p">[</span><span class="n">lags</span><span class="p">,</span><span class="w"> </span><span class="n">lags_past_covariates</span><span class="p">,</span><span class="w"> </span><span class="n">lags_future_covariates</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">),</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">max_samples_per_ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_samples_per_ts</span> <span class="o">=</span> <span class="n">inf</span>

    <span class="c1"># lags are identical for multiple series: pre-compute lagged features and reordered lagged features</span>
    <span class="n">lags_extract</span><span class="p">,</span> <span class="n">lags_order</span> <span class="o">=</span> <span class="n">_get_lagged_indices</span><span class="p">(</span>
        <span class="n">lags</span><span class="p">,</span>
        <span class="n">lags_past_covariates</span><span class="p">,</span>
        <span class="n">lags_future_covariates</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">sample_weights</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">seq_ts_lens</span><span class="p">)):</span>
        <span class="n">target_i</span> <span class="o">=</span> <span class="n">target_series</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">target_series</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">past_i</span> <span class="o">=</span> <span class="n">past_covariates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">past_covariates</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">future_i</span> <span class="o">=</span> <span class="n">future_covariates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">future_covariates</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">sample_weight_i</span> <span class="o">=</span> <span class="n">sample_weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">sample_weight</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">series_equal_freq</span> <span class="o">=</span> <span class="n">_all_equal_freq</span><span class="p">(</span><span class="n">target_i</span><span class="p">,</span> <span class="n">past_i</span><span class="p">,</span> <span class="n">future_i</span><span class="p">)</span>
        <span class="c1"># component-wise lags extraction is not support with times intersection at the moment</span>
        <span class="k">if</span> <span class="n">use_moving_windows</span> <span class="ow">and</span> <span class="n">lags_passed_as_dict</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">series_equal_freq</span><span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot create tabularized data for the </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">th series because target and covariates don&#39;t have &quot;</span>
                    <span class="s2">&quot;the same frequency and some of the lags are provided as a dictionary. Either resample the &quot;</span>
                    <span class="s2">&quot;series or change the lags definition.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">use_moving_windows</span> <span class="ow">and</span> <span class="n">series_equal_freq</span><span class="p">:</span>
            <span class="n">X_i</span><span class="p">,</span> <span class="n">y_i</span><span class="p">,</span> <span class="n">times_i</span><span class="p">,</span> <span class="n">weights_i</span> <span class="o">=</span> <span class="n">_create_lagged_data_by_moving_window</span><span class="p">(</span>
                <span class="n">target_series</span><span class="o">=</span><span class="n">target_i</span><span class="p">,</span>
                <span class="n">output_chunk_length</span><span class="o">=</span><span class="n">output_chunk_length</span><span class="p">,</span>
                <span class="n">output_chunk_shift</span><span class="o">=</span><span class="n">output_chunk_shift</span><span class="p">,</span>
                <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_i</span><span class="p">,</span>
                <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_i</span><span class="p">,</span>
                <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight_i</span><span class="p">,</span>
                <span class="n">lags</span><span class="o">=</span><span class="n">lags</span><span class="p">,</span>
                <span class="n">lags_past_covariates</span><span class="o">=</span><span class="n">lags_past_covariates</span><span class="p">,</span>
                <span class="n">lags_future_covariates</span><span class="o">=</span><span class="n">lags_future_covariates</span><span class="p">,</span>
                <span class="n">lags_extract</span><span class="o">=</span><span class="n">lags_extract</span><span class="p">,</span>
                <span class="n">lags_order</span><span class="o">=</span><span class="n">lags_order</span><span class="p">,</span>
                <span class="n">max_samples_per_ts</span><span class="o">=</span><span class="n">max_samples_per_ts</span><span class="p">,</span>
                <span class="n">multi_models</span><span class="o">=</span><span class="n">multi_models</span><span class="p">,</span>
                <span class="n">check_inputs</span><span class="o">=</span><span class="n">check_inputs</span><span class="p">,</span>
                <span class="n">is_training</span><span class="o">=</span><span class="n">is_training</span><span class="p">,</span>
                <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span>
                <span class="n">show_warnings</span><span class="o">=</span><span class="n">show_warnings</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">X_i</span><span class="p">,</span> <span class="n">y_i</span><span class="p">,</span> <span class="n">times_i</span><span class="p">,</span> <span class="n">weights_i</span> <span class="o">=</span> <span class="n">_create_lagged_data_by_intersecting_times</span><span class="p">(</span>
                <span class="n">target_series</span><span class="o">=</span><span class="n">target_i</span><span class="p">,</span>
                <span class="n">output_chunk_length</span><span class="o">=</span><span class="n">output_chunk_length</span><span class="p">,</span>
                <span class="n">output_chunk_shift</span><span class="o">=</span><span class="n">output_chunk_shift</span><span class="p">,</span>
                <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_i</span><span class="p">,</span>
                <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_i</span><span class="p">,</span>
                <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight_i</span><span class="p">,</span>
                <span class="n">lags</span><span class="o">=</span><span class="n">lags</span><span class="p">,</span>
                <span class="n">lags_past_covariates</span><span class="o">=</span><span class="n">lags_past_covariates</span><span class="p">,</span>
                <span class="n">lags_future_covariates</span><span class="o">=</span><span class="n">lags_future_covariates</span><span class="p">,</span>
                <span class="n">max_samples_per_ts</span><span class="o">=</span><span class="n">max_samples_per_ts</span><span class="p">,</span>
                <span class="n">multi_models</span><span class="o">=</span><span class="n">multi_models</span><span class="p">,</span>
                <span class="n">check_inputs</span><span class="o">=</span><span class="n">check_inputs</span><span class="p">,</span>
                <span class="n">is_training</span><span class="o">=</span><span class="n">is_training</span><span class="p">,</span>
                <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span>
                <span class="n">show_warnings</span><span class="o">=</span><span class="n">show_warnings</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">X_i</span><span class="p">,</span> <span class="n">last_static_covariates_shape</span> <span class="o">=</span> <span class="n">add_static_covariates_to_lagged_data</span><span class="p">(</span>
            <span class="n">features</span><span class="o">=</span><span class="n">X_i</span><span class="p">,</span>
            <span class="n">target_series</span><span class="o">=</span><span class="n">target_i</span><span class="p">,</span>
            <span class="n">uses_static_covariates</span><span class="o">=</span><span class="n">uses_static_covariates</span><span class="p">,</span>
            <span class="n">last_shape</span><span class="o">=</span><span class="n">last_static_covariates_shape</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_i</span><span class="p">)</span>
        <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_i</span><span class="p">)</span>
        <span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">times_i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weights_i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weights_i</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">concatenate</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_training</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">concatenate</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sample_weights</span> <span class="ow">and</span> <span class="n">concatenate</span><span class="p">:</span>
        <span class="n">sample_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">sample_weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">sample_weights</span><span class="p">:</span>
        <span class="n">sample_weights</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">last_static_covariates_shape</span><span class="p">,</span> <span class="n">sample_weights</span></div>


<div class="viewcode-block" id="create_lagged_training_data"><a class="viewcode-back" href="../../../../../generated_api/darts.utils.data.tabularization.tabularization.html#darts.utils.data.tabularization.tabularization.create_lagged_training_data">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">create_lagged_training_data</span><span class="p">(</span>
    <span class="n">target_series</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
    <span class="n">output_chunk_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">output_chunk_shift</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">lags</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">lags_past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">lags_future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">uses_static_covariates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">last_static_covariates_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_samples_per_ts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">multi_models</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">check_inputs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">use_moving_windows</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">concatenate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">sample_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
    <span class="n">ArrayOrArraySequence</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">ArrayOrArraySequence</span><span class="p">],</span>
    <span class="n">Sequence</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">],</span>
    <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayOrArraySequence</span><span class="p">],</span>
<span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates the features array `X` and labels array `y` to train a lagged-variables `SKLearnModel` (e.g. an</span>
<span class="sd">    `sklearn` model); the time index values of each observation is also returned.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is simply a wrapper around `create_lagged_data`; for further details on the structure of `X`, please</span>
<span class="sd">    refer to `help(create_lagged_data)`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target_series</span>
<span class="sd">        The series for the `SKLearnModel` to predict.</span>
<span class="sd">    output_chunk_length</span>
<span class="sd">        The number of time steps ahead into the future the `SKLearnModel` is to predict.</span>
<span class="sd">    output_chunk_shift</span>
<span class="sd">        Optionally, the number of time steps to shift the output chunk ahead into the future.</span>
<span class="sd">    past_covariates</span>
<span class="sd">        Optionally, the past covariates series that the `SKLearnModel` will use as inputs. Unlike the</span>
<span class="sd">        `target_series`, `past_covariates` are *not* to be predicted by the `SKLearnModel`.</span>
<span class="sd">    future_covariates</span>
<span class="sd">        Optionally, the future covariates (i.e. exogenous covariates) series that the `SKLearnModel` will</span>
<span class="sd">        use as inputs.</span>
<span class="sd">    lags</span>
<span class="sd">        Optionally, the lags of the target series to be used as (autoregressive) features. If not specified,</span>
<span class="sd">        autoregressive features will *not* be added to `X`. Each lag value is assumed to be negative (e.g.</span>
<span class="sd">        `lags = [-3, -1]` will extract `target_series` values which are 3 time steps and 1 time step away from</span>
<span class="sd">        the current value). If the lags are provided as a dictionary, the lags values are specific to each</span>
<span class="sd">        component in the target series.</span>
<span class="sd">    lags_past_covariates</span>
<span class="sd">        Optionally, the lags of `past_covariates` to be used as features. Like `lags`, each lag value is assumed to</span>
<span class="sd">        be less than or equal to -1. If the lags are provided as a dictionary, the lags values are specific to each</span>
<span class="sd">        component in the past covariates series.</span>
<span class="sd">    lags_future_covariates</span>
<span class="sd">        Optionally, the lags of `future_covariates` to be used as features. Unlike `lags` and `lags_past_covariates`,</span>
<span class="sd">        `lags_future_covariates` values can be positive (i.e. use values *after* time `t` to predict target at</span>
<span class="sd">        time `t`), zero (i.e. use values *at* time `t` to predict target at time `t`), and/or negative (i.e. use values</span>
<span class="sd">        *before* time `t` to predict target at time `t`). If the lags are provided as a dictionary, the lags values</span>
<span class="sd">        are specific to each component in the future covariates series.</span>
<span class="sd">    uses_static_covariates</span>
<span class="sd">        Whether the model uses/expects static covariates. If `True`, it enforces that static covariates must</span>
<span class="sd">        have identical shapes across all target series.</span>
<span class="sd">    last_static_covariates_shape</span>
<span class="sd">        Optionally, the last observed shape of the static covariates. This is ``None`` before fitting, or when</span>
<span class="sd">        `uses_static_covariates` is ``False``.</span>
<span class="sd">    max_samples_per_ts</span>
<span class="sd">        Optionally, the maximum number of samples to be drawn for training/validation; only the most recent</span>
<span class="sd">        samples are kept. In theory, specifying a smaller `max_samples_per_ts` should reduce computation time,</span>
<span class="sd">        especially in cases where many observations could be generated.</span>
<span class="sd">    multi_models</span>
<span class="sd">        Optionally, specifies whether the `SKLearnModel` predicts multiple time steps into the future. If `True`,</span>
<span class="sd">        then the `SKLearnModel` is assumed to predict all time steps from time `t` to `t+output_chunk_length`.</span>
<span class="sd">        If `False`, then the `SKLearnModel` is assumed to predict *only* the time step at `t+output_chunk_length`.</span>
<span class="sd">    check_inputs</span>
<span class="sd">        Optionally, specifies that the `lags_*` and `series_*` inputs should be checked for validity. Should be set</span>
<span class="sd">        to `False` if inputs have already been checked for validity (e.g. inside the `__init__` of a class), otherwise</span>
<span class="sd">        should be set to `True`.</span>
<span class="sd">    use_moving_windows</span>
<span class="sd">        Optionally, specifies that the &#39;moving window&#39; method should be used to construct `X` and `y` if all</span>
<span class="sd">        provided series are of the same frequency. If `use_moving_windows = False`, the &#39;time intersection&#39; method</span>
<span class="sd">        will always be used, even when all provided series are of the same frequency. In general, setting</span>
<span class="sd">        to `True` results in faster tabularization at the potential cost of higher memory usage. See Notes for further</span>
<span class="sd">        details.</span>
<span class="sd">    concatenate</span>
<span class="sd">        Optionally, specifies that `X` and `y` should both be returned as single `np.ndarray`s, instead of as</span>
<span class="sd">        a `Sequence[np.ndarray]`. If each series input is specified as a `Sequence[TimeSeries]` and</span>
<span class="sd">        `concatenate = False`, `X` and `y` will be lists whose `i`th element corresponds to the feature matrix or label</span>
<span class="sd">        array formed by the `i`th `TimeSeries` in each `Sequence[TimeSeries]` input. Conversely, if `concatenate = True`</span>
<span class="sd">        when `Sequence[TimeSeries]` are provided, then `X` and `y` will be arrays created by concatenating all</span>
<span class="sd">        feature/label arrays formed by each `TimeSeries` along the `0`th axis. Note that `times` is still returned as</span>
<span class="sd">        `Sequence[pd.Index]`, even when `concatenate = True`.</span>
<span class="sd">    stride</span>
<span class="sd">        The number of time steps between consecutive samples, applied starting from the end of the series. This should</span>
<span class="sd">        be used with caution as it might introduce bias in the forecasts.</span>
<span class="sd">    sample_weight</span>
<span class="sd">        Optionally, some sample weights to apply to the target `series` labels. They are applied per observation,</span>
<span class="sd">        per label (each step in `output_chunk_length`), and per component.</span>
<span class="sd">        If a series or sequence of series, then those weights are used. If the weight series only have a single</span>
<span class="sd">        component / column, then the weights are applied globally to all components in `series`. Otherwise, for</span>
<span class="sd">        component-specific weights, the number of components must match those of `series`.</span>
<span class="sd">        If a string, then the weights are generated using built-in weighting functions. The available options are</span>
<span class="sd">        `&quot;linear&quot;` or `&quot;exponential&quot;` decay - the further in the past, the lower the weight. The weights are</span>
<span class="sd">        computed globally based on the length of the longest series in `series`. Then for each series, the weights</span>
<span class="sd">        are extracted from the end of the global weights. This gives a common time weighting across all series.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X</span>
<span class="sd">        The constructed features array(s), with shape `(n_observations, n_lagged_features, n_samples)`.</span>
<span class="sd">        If the series inputs were specified as `Sequence[TimeSeries]` and `concatenate = False`, then `X`</span>
<span class="sd">        is returned as a `Sequence[np.array]`; otherwise, `X` is returned as a single `np.array`.</span>
<span class="sd">    y</span>
<span class="sd">        The constructed labels array. If `multi_models = True`, then `y` is a</span>
<span class="sd">        `(n_observations, output_chunk_length, n_samples)`-shaped array; conversely, if</span>
<span class="sd">        `multi_models =  False`, then `y` is a `(n_observations, 1, n_samples)`-shaped array.</span>
<span class="sd">        If the series inputs were specified as `Sequence[TimeSeries]` and `concatenate = False`, then `y`</span>
<span class="sd">        is returned as a `Sequence[np.array]`; otherwise, `y` is returned as a single `np.array`.</span>
<span class="sd">    times</span>
<span class="sd">        The `time_index` of each observation in `X` and `y`, returned as a `Sequence` of `pd.Index`es.</span>
<span class="sd">        If the series inputs were specified as `Sequence[TimeSeries]`, then the `i`th list element</span>
<span class="sd">        gives the times of those observations formed using the `i`th `TimeSeries` object in each</span>
<span class="sd">        `Sequence`. Otherwise, if the series inputs were specified as `TimeSeries`, the only</span>
<span class="sd">        element is the times of those observations formed from the lone `TimeSeries` inputs.</span>
<span class="sd">    sample_weight</span>
<span class="sd">        The weights to apply to each observation in `X` and output step `y`, returned as a `Sequence` of `np.ndarray`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the specified time series do not share any times for which features and labels can be constructed.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If no lags are specified, or if any of the specified lag values are non-negative.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If any of the series are too short to create features and labels for the requested lags and</span>
<span class="sd">        `output_chunk_length` values.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the provided series do not share the same type of `time_index` (e.g. `target_series` uses a</span>
<span class="sd">        pd.RangeIndex, but `future_covariates` uses a `pd.DatetimeIndex`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_lagged_data</span><span class="p">(</span>
        <span class="n">target_series</span><span class="o">=</span><span class="n">target_series</span><span class="p">,</span>
        <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
        <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
        <span class="n">lags</span><span class="o">=</span><span class="n">lags</span><span class="p">,</span>
        <span class="n">lags_past_covariates</span><span class="o">=</span><span class="n">lags_past_covariates</span><span class="p">,</span>
        <span class="n">lags_future_covariates</span><span class="o">=</span><span class="n">lags_future_covariates</span><span class="p">,</span>
        <span class="n">output_chunk_length</span><span class="o">=</span><span class="n">output_chunk_length</span><span class="p">,</span>
        <span class="n">output_chunk_shift</span><span class="o">=</span><span class="n">output_chunk_shift</span><span class="p">,</span>
        <span class="n">uses_static_covariates</span><span class="o">=</span><span class="n">uses_static_covariates</span><span class="p">,</span>
        <span class="n">last_static_covariates_shape</span><span class="o">=</span><span class="n">last_static_covariates_shape</span><span class="p">,</span>
        <span class="n">max_samples_per_ts</span><span class="o">=</span><span class="n">max_samples_per_ts</span><span class="p">,</span>
        <span class="n">multi_models</span><span class="o">=</span><span class="n">multi_models</span><span class="p">,</span>
        <span class="n">check_inputs</span><span class="o">=</span><span class="n">check_inputs</span><span class="p">,</span>
        <span class="n">use_moving_windows</span><span class="o">=</span><span class="n">use_moving_windows</span><span class="p">,</span>
        <span class="n">is_training</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">concatenate</span><span class="o">=</span><span class="n">concatenate</span><span class="p">,</span>
        <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span>
        <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="create_lagged_prediction_data"><a class="viewcode-back" href="../../../../../generated_api/darts.utils.data.tabularization.tabularization.html#darts.utils.data.tabularization.tabularization.create_lagged_prediction_data">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">create_lagged_prediction_data</span><span class="p">(</span>
    <span class="n">target_series</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">lags</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">lags_past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">lags_future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">uses_static_covariates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">last_static_covariates_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_samples_per_ts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">check_inputs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">use_moving_windows</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">concatenate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">show_warnings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ArrayOrArraySequence</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates the features array `X` to produce a series of prediction from an already-trained `SKLearnModel`; the</span>
<span class="sd">    time index values of each observation is also returned.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is simply a wrapper around `create_lagged_data`; for further details on the structure of `X`, please</span>
<span class="sd">    refer to `help(create_lagged_data)`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target_series</span>
<span class="sd">        Optionally, the series for the `SKLearnModel` to predict.</span>
<span class="sd">    past_covariates</span>
<span class="sd">        Optionally, the past covariates series that the `SKLearnModel` will use as inputs. Unlike the</span>
<span class="sd">        `target_series`, `past_covariates` are *not* to be predicted by the `SKLearnModel`.</span>
<span class="sd">    future_covariates</span>
<span class="sd">        Optionally, the future covariates (i.e. exogenous covariates) series that the `SKLearnModel` will</span>
<span class="sd">        use as inputs.</span>
<span class="sd">    lags</span>
<span class="sd">        Optionally, the lags of the target series to be used as (autoregressive) features. If not specified,</span>
<span class="sd">        autoregressive features will *not* be added to `X`. Each lag value is assumed to be negative (e.g.</span>
<span class="sd">        `lags = [-3, -1]` will extract `target_series` values which are 3 time steps and 1 time step away from</span>
<span class="sd">        the current value). If the lags are provided as a dictionary, the lags values are specific to each</span>
<span class="sd">        component in the target series.</span>
<span class="sd">    lags_past_covariates</span>
<span class="sd">        Optionally, the lags of `past_covariates` to be used as features. Like `lags`, each lag value is assumed to</span>
<span class="sd">        be less than or equal to -1. If the lags are provided as a dictionary, the lags values are specific to each</span>
<span class="sd">        component in the past covariates series.</span>
<span class="sd">    lags_future_covariates</span>
<span class="sd">        Optionally, the lags of `future_covariates` to be used as features. Unlike `lags` and `lags_past_covariates`,</span>
<span class="sd">        `lags_future_covariates` values can be positive (i.e. use values *after* time `t` to predict target at</span>
<span class="sd">        time `t`), zero (i.e. use values *at* time `t` to predict target at time `t`), and/or negative (i.e. use</span>
<span class="sd">        values *before* time `t` to predict target at time `t`). If the lags are provided as a dictionary, the lags</span>
<span class="sd">        values are specific to each component in the future covariates series.</span>
<span class="sd">    uses_static_covariates</span>
<span class="sd">        Whether the model uses/expects static covariates. If `True`, it enforces that static covariates must</span>
<span class="sd">        have identical shapes across all target series.</span>
<span class="sd">    last_static_covariates_shape</span>
<span class="sd">        Optionally, the last observed shape of the static covariates. This is ``None`` before fitting, or when</span>
<span class="sd">        `uses_static_covariates` is ``False``.</span>
<span class="sd">    max_samples_per_ts</span>
<span class="sd">        Optionally, the maximum number of samples to be drawn for training/validation; only the most recent</span>
<span class="sd">        samples are kept. In theory, specifying a smaller `max_samples_per_ts` should reduce computation time,</span>
<span class="sd">        especially in cases where many observations could be generated.</span>
<span class="sd">    check_inputs</span>
<span class="sd">        Optionally, specifies that the `lags_*` and `series_*` inputs should be checked for validity. Should be set</span>
<span class="sd">        to `False` if inputs have already been checked for validity (e.g. inside the `__init__` of a class), otherwise</span>
<span class="sd">        should be set to `True`.</span>
<span class="sd">    use_moving_windows</span>
<span class="sd">        Optionally, specifies that the &#39;moving window&#39; method should be used to construct `X` and `y` if all</span>
<span class="sd">        provided series are of the same frequency. If `use_moving_windows = False`, the &#39;time intersection&#39; method</span>
<span class="sd">        will always be used, even when all provided series are of the same frequency. In general, setting</span>
<span class="sd">        to `True` results in faster tabularization at the potential cost of higher memory usage. See Notes for further</span>
<span class="sd">        details.</span>
<span class="sd">    concatenate</span>
<span class="sd">        Optionally, specifies that `X` should be returned as a single `np.ndarray`, instead of as a</span>
<span class="sd">        `Sequence[np.ndarray]`. If each series input is specified as a `Sequence[TimeSeries]` and `concatenate = False`,</span>
<span class="sd">        `X` will be a list whose `i`th element corresponds to the feature matrix or label array formed by the `i`th</span>
<span class="sd">        `TimeSeries` in each `Sequence[TimeSeries]` input. Conversely, if `concatenate = True` when</span>
<span class="sd">        `Sequence[TimeSeries]` are provided, then `X` will be an array created by concatenating all feature</span>
<span class="sd">        arrays formed by each `TimeSeries` along the `0`th axis. Note that `times` is still returned as</span>
<span class="sd">        `Sequence[pd.Index]`, even when `concatenate = True`.</span>
<span class="sd">    stride</span>
<span class="sd">        The number of time steps between consecutive samples applied, starting from the end of the series. This should</span>
<span class="sd">        be used with caution as it will cause gaps in the forecasts.</span>
<span class="sd">    show_warnings</span>
<span class="sd">        Whether to show warnings.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X</span>
<span class="sd">        The constructed features array(s), with shape `(n_observations, n_lagged_features, n_samples)`.</span>
<span class="sd">        If the series inputs were specified as `Sequence[TimeSeries]` and `concatenate = False`, then `X`</span>
<span class="sd">        is returned as a `Sequence[np.array]`; otherwise, `X` is returned as a single `np.array`.</span>
<span class="sd">    times</span>
<span class="sd">        The `time_index` of each observation in `X` and `y`, returned as a `Sequence` of `pd.Index`es.</span>
<span class="sd">        If the series inputs were specified as `Sequence[TimeSeries]`, then the `i`th list element</span>
<span class="sd">        gives the times of those observations formed using the `i`th `TimeSeries` object in each</span>
<span class="sd">        `Sequence`. Otherwise, if the series inputs were specified as `TimeSeries`, the only</span>
<span class="sd">        element is the times of those observations formed from the lone `TimeSeries` inputs.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the specified time series do not share any times for which features can be constructed.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If no lags are specified, or if any of the specified lag values are non-negative.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If any of the series are too short to create features for the requested lag values.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the provided series do not share the same type of `time_index` (e.g. `target_series` uses a</span>
<span class="sd">        pd.RangeIndex, but `future_covariates` uses a `pd.DatetimeIndex`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">create_lagged_data</span><span class="p">(</span>
        <span class="n">target_series</span><span class="o">=</span><span class="n">target_series</span><span class="p">,</span>
        <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
        <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
        <span class="n">lags</span><span class="o">=</span><span class="n">lags</span><span class="p">,</span>
        <span class="n">lags_past_covariates</span><span class="o">=</span><span class="n">lags_past_covariates</span><span class="p">,</span>
        <span class="n">lags_future_covariates</span><span class="o">=</span><span class="n">lags_future_covariates</span><span class="p">,</span>
        <span class="n">uses_static_covariates</span><span class="o">=</span><span class="n">uses_static_covariates</span><span class="p">,</span>
        <span class="n">last_static_covariates_shape</span><span class="o">=</span><span class="n">last_static_covariates_shape</span><span class="p">,</span>
        <span class="n">max_samples_per_ts</span><span class="o">=</span><span class="n">max_samples_per_ts</span><span class="p">,</span>
        <span class="n">check_inputs</span><span class="o">=</span><span class="n">check_inputs</span><span class="p">,</span>
        <span class="n">use_moving_windows</span><span class="o">=</span><span class="n">use_moving_windows</span><span class="p">,</span>
        <span class="n">is_training</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">concatenate</span><span class="o">=</span><span class="n">concatenate</span><span class="p">,</span>
        <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span>
        <span class="n">show_warnings</span><span class="o">=</span><span class="n">show_warnings</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">times</span></div>


<div class="viewcode-block" id="add_static_covariates_to_lagged_data"><a class="viewcode-back" href="../../../../../generated_api/darts.utils.data.tabularization.tabularization.html#darts.utils.data.tabularization.tabularization.add_static_covariates_to_lagged_data">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">add_static_covariates_to_lagged_data</span><span class="p">(</span>
    <span class="n">features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
    <span class="n">target_series</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
    <span class="n">uses_static_covariates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">last_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add static covariates to the features&#39; table for SKLearnModels.</span>
<span class="sd">    If `uses_static_covariates=True`, all target series used in `fit()` and `predict()` must have static</span>
<span class="sd">    covariates with identical dimensionality. Otherwise, will not consider static covariates.</span>

<span class="sd">    The static covariates are added to the right of the lagged features following the convention:</span>
<span class="sd">    with a 2 component series, and 2 static covariates per component -&gt;</span>
<span class="sd">    scov_1_comp_1 | scov_1_comp_2 | scov_2_comp_1 | scov_2_comp_2</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    features</span>
<span class="sd">        The features&#39; numpy array(s) to which the static covariates will be added. Can either be a lone feature</span>
<span class="sd">        matrix or a `Sequence` of feature matrices; in the latter case, static covariates will be appended to</span>
<span class="sd">        each feature matrix in this `Sequence`.</span>
<span class="sd">    target_series</span>
<span class="sd">        The target series from which to read the static covariates.</span>
<span class="sd">    uses_static_covariates</span>
<span class="sd">        Whether the model uses/expects static covariates. If `True`, it enforces that static covariates must</span>
<span class="sd">        have identical shapes across all of target series.</span>
<span class="sd">    last_shape</span>
<span class="sd">        Optionally, the last observed shape of the static covariates. This is ``None`` before fitting, or when</span>
<span class="sd">        `uses_static_covariates` is ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (features, last_shape)</span>
<span class="sd">        The features&#39; array(s) with appended static covariates columns. If the `features` input was passed as a</span>
<span class="sd">        `Sequence` of `np.array`s, then a `Sequence` is also returned; if `features` was passed as an `np.array`,</span>
<span class="sd">        a `np.array` is returned.</span>
<span class="sd">        `last_shape` is the shape of the static covariates.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># uses_static_covariates=True enforces that all series must have static covs of same dimensionality</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">uses_static_covariates</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">features</span><span class="p">,</span> <span class="n">last_shape</span>

    <span class="n">input_not_list</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">input_not_list</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="n">features</span><span class="p">]</span>
    <span class="n">target_series</span> <span class="o">=</span> <span class="n">series2seq</span><span class="p">(</span><span class="n">target_series</span><span class="p">)</span>

    <span class="c1"># go through series, check static covariates, and stack them to the right of the lagged features</span>
    <span class="c1"># try to abort early in case there is a mismatch in static covariates</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">target_series</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ts</span><span class="o">.</span><span class="n">has_static_covariates</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Static covariates mismatch across the sequence of target series. Some of the series &quot;</span>
                    <span class="s2">&quot;contain static covariates and others do not.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">last_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">last_shape</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">static_covariates</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">static_covariates</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">last_shape</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Static covariates dimension mismatch across the sequence of target series. The static &quot;</span>
                        <span class="s2">&quot;covariates must have the same number of columns and rows across all target series.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="c1"># flatten static covariates along columns -&gt; results in [scov0_comp0, scov0_comp1, scov1_comp0, ...]</span>
            <span class="n">static_covs</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">static_covariates</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
            <span class="c1"># we stack the static covariates to the right of lagged features</span>
            <span class="c1"># the broadcasting repeats the static covariates along axis=0 to match the number of feature rows</span>
            <span class="n">shape_out</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">features</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">static_covs</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">features</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="k">else</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">features</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">static_covs</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">features</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span>
                <span class="n">features</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">static_covs</span><span class="p">,</span> <span class="n">shape_out</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape_out</span><span class="p">),</span>
            <span class="p">])</span>

    <span class="k">if</span> <span class="n">input_not_list</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">features</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">features</span><span class="p">,</span> <span class="n">last_shape</span></div>


<div class="viewcode-block" id="create_lagged_component_names"><a class="viewcode-back" href="../../../../../generated_api/darts.utils.data.tabularization.tabularization.html#darts.utils.data.tabularization.tabularization.create_lagged_component_names">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">create_lagged_component_names</span><span class="p">(</span>
    <span class="n">target_series</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">lags</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">lags_past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">lags_future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">output_chunk_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">concatenate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">use_static_covariates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function called to retrieve the name of the features and labels arrays created with</span>
<span class="sd">    `create_lagged_data()`. The order of the features is the following:</span>

<span class="sd">    Along the `n_lagged_features` axis, `X` has the following structure:</span>
<span class="sd">        lagged_target | lagged_past_covariates | lagged_future_covariates | static covariates</span>

<span class="sd">    For `*_lags=[-2,-1]` and `*_series.n_components = 2` (lags shared across all the components),</span>
<span class="sd">    each `lagged_*` has the following structure (grouped by lags):</span>
<span class="sd">        comp0_*_lag-2 | comp1_*_lag-2 | comp0_*_lag_-1 | comp1_*_lag-1</span>
<span class="sd">    For `*_lags={&#39;comp0&#39;:[-3, -1], &#39;comp1&#39;:[-5, -3]}` and `*_series.n_components = 2` (component-</span>
<span class="sd">    specific lags), each `lagged_*` has the following structure (sorted by lags, then by components):</span>
<span class="sd">        comp1_*_lag-5 | comp0_*_lag-3 | comp1_*_lag_-3 | comp0_*_lag-1</span>

<span class="sd">    and for static covariates (2 static covariates acting on 2 target components):</span>
<span class="sd">        cov0_*_target_comp0 | cov0_*_target_comp1 | cov1_*_target_comp0 | cov1_*_target_comp1</span>

<span class="sd">    Along the `n_lagged_labels` axis, `y` has the following structure (for `output_chunk_length=4` and</span>
<span class="sd">    `target_series.n_components=2`):</span>
<span class="sd">        comp0_target_lag0 | comp1_target_lag0 | ... | comp0_target_lag3 | comp1_target_lag3</span>

<span class="sd">    Note : will only use the component names of the first series from `target_series`, `past_covariates`,</span>
<span class="sd">    `future_covariates`, and static_covariates.</span>

<span class="sd">    The naming convention for target, past and future covariates lags is: ``&quot;{name}_{type}_lag{i}&quot;``, where:</span>

<span class="sd">        - ``{name}`` the component name of the (first) series</span>
<span class="sd">        - ``{type}`` is the feature type, one of &quot;target&quot;, &quot;pastcov&quot;, and &quot;futcov&quot;</span>
<span class="sd">        - ``{i}`` is the lag value</span>

<span class="sd">    The naming convention for static covariates is: ``&quot;{name}_statcov_target_{comp}&quot;``, where:</span>

<span class="sd">        - ``{name}`` the static covariate name of the (first) series</span>
<span class="sd">        - ``{comp}`` the target component name of the (first) that the static covariate act on. If the static</span>
<span class="sd">            covariate acts globally on a multivariate target series, will show &quot;global&quot;.</span>

<span class="sd">    The naming convention for labels is: ``&quot;{name}_target_hrz{i}&quot;``, where:</span>

<span class="sd">        - ``{name}`` the component name of the (first) series</span>
<span class="sd">        - ``{i}`` is the step in the forecast horizon</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    features_cols_name</span>
<span class="sd">        The names of the lagged features in the `X` array generated by `create_lagged_data()`</span>
<span class="sd">        as a `List[str]`. If `concatenate=True`, also contains the columns names for</span>
<span class="sd">        the `y` array (on the right).</span>
<span class="sd">    labels_cols_name</span>
<span class="sd">        The names of the lagged features in the `y` array generated by `create_lagged_data()`</span>
<span class="sd">         as a `List[str]`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">        tabularization.create_lagged_data : generate the lagged features and labels as (list of) Arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">target_series</span> <span class="o">=</span> <span class="n">series2seq</span><span class="p">(</span><span class="n">target_series</span><span class="p">)</span>
    <span class="n">past_covariates</span> <span class="o">=</span> <span class="n">series2seq</span><span class="p">(</span><span class="n">past_covariates</span><span class="p">)</span>
    <span class="n">future_covariates</span> <span class="o">=</span> <span class="n">series2seq</span><span class="p">(</span><span class="n">future_covariates</span><span class="p">)</span>

    <span class="n">lagged_feature_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">label_feature_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">variate</span><span class="p">,</span> <span class="n">variate_lags</span><span class="p">,</span> <span class="n">variate_type</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="p">[</span><span class="n">target_series</span><span class="p">,</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span><span class="p">],</span>
        <span class="p">[</span><span class="n">lags</span><span class="p">,</span> <span class="n">lags_past_covariates</span><span class="p">,</span> <span class="n">lags_future_covariates</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">,</span> <span class="s2">&quot;pastcov&quot;</span><span class="p">,</span> <span class="s2">&quot;futcov&quot;</span><span class="p">],</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">variate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">components</span> <span class="o">=</span> <span class="n">get_single_series</span><span class="p">(</span><span class="n">variate</span><span class="p">)</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># target labels</span>
        <span class="k">if</span> <span class="n">variate_type</span> <span class="o">==</span> <span class="s2">&quot;target&quot;</span><span class="p">:</span>
            <span class="n">label_feature_names</span> <span class="o">=</span> <span class="p">[</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_target_hrz</span><span class="si">{</span><span class="n">lag</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">lag</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">output_chunk_length</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">components</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">variate_lags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variate_lags</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="s2">&quot;default_lags&quot;</span> <span class="ow">in</span> <span class="n">variate_lags</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;All the lags must be explicitly defined, &#39;default_lags&#39; is not allowed in the &quot;</span>
                        <span class="s2">&quot;lags dictionary.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># combine all the lags and sort them in ascending order across all the components</span>
            <span class="n">comp_lags_reordered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">variate_lags</span><span class="p">[</span><span class="n">comp_name</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">comp_name</span> <span class="ow">in</span> <span class="n">components</span>
            <span class="p">])</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">**</span><span class="n">STABLE_SORT_KWARGS</span><span class="p">)</span>
            <span class="n">tmp_lagged_feats_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
                <span class="n">tmp_lagged_feats_names</span> <span class="o">+=</span> <span class="p">[</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">variate_type</span><span class="si">}</span><span class="s2">_lag</span><span class="si">{</span><span class="n">lag</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">lag</span> <span class="ow">in</span> <span class="n">variate_lags</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="p">]</span>

            <span class="c1"># adding feats names reordered across components</span>
            <span class="n">lagged_feature_names</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">tmp_lagged_feats_names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">comp_lags_reordered</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lagged_feature_names</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">variate_type</span><span class="si">}</span><span class="s2">_lag</span><span class="si">{</span><span class="n">lag</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">lag</span> <span class="ow">in</span> <span class="n">variate_lags</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">components</span>
            <span class="p">]</span>

    <span class="c1"># static covariates</span>
    <span class="k">if</span> <span class="n">use_static_covariates</span><span class="p">:</span>
        <span class="n">static_covs</span> <span class="o">=</span> <span class="n">get_single_series</span><span class="p">(</span><span class="n">target_series</span><span class="p">)</span><span class="o">.</span><span class="n">static_covariates</span>
        <span class="c1"># static covariate names</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">static_covs</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># target components that the static covariates reference to</span>
        <span class="n">comps</span> <span class="o">=</span> <span class="n">static_covs</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">lagged_feature_names</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_statcov_target_</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">comps</span>
        <span class="p">]</span>

    <span class="k">if</span> <span class="n">concatenate</span><span class="p">:</span>
        <span class="n">lagged_feature_names</span> <span class="o">+=</span> <span class="n">label_feature_names</span>

    <span class="k">return</span> <span class="n">lagged_feature_names</span><span class="p">,</span> <span class="n">label_feature_names</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_lagged_indices</span><span class="p">(</span>
    <span class="n">lags</span><span class="p">,</span>
    <span class="n">lags_past_covariates</span><span class="p">,</span>
    <span class="n">lags_future_covariates</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes and returns:</span>

<span class="sd">    - the lagged feature indices for extraction from windows</span>
<span class="sd">    - the reordered indices to apply after the window extraction (in case of component specific lags)</span>

<span class="sd">    Assumes that all input series share identical component order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lags_extract</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lags_order</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">lags_i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">lags</span><span class="p">,</span> <span class="n">lags_past_covariates</span><span class="p">,</span> <span class="n">lags_future_covariates</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">lags_i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lags_extract</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">lags_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Within each window, the `-1` indexed value (i.e. the value at the very end of</span>
        <span class="c1"># the window) corresponds to time `t - min_lag_i`. The negative index of the time</span>
        <span class="c1"># `t + lag_i` within this window is, therefore, `-1 + lag_i + min_lag_i`:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lags_i</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">lags_extract_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lags_i</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="c1"># Feats are already grouped by lags and ordered</span>
            <span class="n">lags_order_i</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume keys are in the same order as the series components</span>
            <span class="c1"># Lags are grouped by component, extracted from the same window</span>
            <span class="n">lags_extract_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c_lags</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">c_lags</span> <span class="ow">in</span> <span class="n">lags_i</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
            <span class="c1"># Sort the lags across the components in ascending order</span>
            <span class="n">lags_order_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">lags_extract_i</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">**</span><span class="n">STABLE_SORT_KWARGS</span><span class="p">)</span>
        <span class="n">lags_extract</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lags_extract_i</span><span class="p">)</span>
        <span class="n">lags_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lags_order_i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lags_extract</span><span class="p">,</span> <span class="n">lags_order</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_create_lagged_data_by_moving_window</span><span class="p">(</span>
    <span class="n">target_series</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
    <span class="n">output_chunk_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">output_chunk_shift</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
    <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
    <span class="n">sample_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
    <span class="n">lags</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]],</span>
    <span class="n">lags_past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]],</span>
    <span class="n">lags_future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]],</span>
    <span class="n">lags_extract</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
    <span class="n">lags_order</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
    <span class="n">max_samples_per_ts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">multi_models</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">check_inputs</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">is_training</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">show_warnings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function called by `create_lagged_data` that computes `X`, `y`, and `times` by</span>
<span class="sd">    extracting &#39;moving windows&#39; from each series using the `strided_moving_window`</span>
<span class="sd">    function. More specifically, to extract the features of a particular series for an</span>
<span class="sd">    arbitrary time `t`, a &#39;window&#39; between times `t - max_lag` and `t - min_lag` is</span>
<span class="sd">    extracted, where `max_lag` and `min_lag` are the largest and smallest magnitude lags</span>
<span class="sd">    requested for that particular series. After extracting this window, the requested lag</span>
<span class="sd">    values between these two minimum and maximum lag values can be extracted. Similarly,</span>
<span class="sd">    the labels for time `t` are formed simply by extracting a window between times `t`</span>
<span class="sd">    and `t + output_chunk_length - 1` from the target series. In both cases, the extracted</span>
<span class="sd">    windows can then be reshaped into the correct shape. This approach can only be used if</span>
<span class="sd">    we *can* assume that the specified series are all of the same frequency.</span>

<span class="sd">    Assumes that all the lags are sorted in ascending order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">feature_times</span><span class="p">,</span> <span class="n">min_lags</span><span class="p">,</span> <span class="n">max_lags</span> <span class="o">=</span> <span class="n">_get_feature_times</span><span class="p">(</span>
        <span class="n">target_series</span><span class="o">=</span><span class="n">target_series</span><span class="p">,</span>
        <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
        <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
        <span class="n">lags</span><span class="o">=</span><span class="n">lags</span><span class="p">,</span>
        <span class="n">lags_past_covariates</span><span class="o">=</span><span class="n">lags_past_covariates</span><span class="p">,</span>
        <span class="n">lags_future_covariates</span><span class="o">=</span><span class="n">lags_future_covariates</span><span class="p">,</span>
        <span class="n">output_chunk_length</span><span class="o">=</span><span class="n">output_chunk_length</span><span class="p">,</span>
        <span class="n">output_chunk_shift</span><span class="o">=</span><span class="n">output_chunk_shift</span><span class="p">,</span>
        <span class="n">is_training</span><span class="o">=</span><span class="n">is_training</span><span class="p">,</span>
        <span class="n">return_min_and_max_lags</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">check_inputs</span><span class="o">=</span><span class="n">check_inputs</span><span class="p">,</span>
        <span class="n">show_warnings</span><span class="o">=</span><span class="n">show_warnings</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">check_inputs</span><span class="p">:</span>
        <span class="n">series_and_lags_not_specified</span> <span class="o">=</span> <span class="p">[</span><span class="n">max_lag</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">max_lag</span> <span class="ow">in</span> <span class="n">max_lags</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">series_and_lags_not_specified</span><span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must specify at least one series-lags pair.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">stride</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`stride` must be a positive integer greater than 0.&quot;</span><span class="p">),</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="n">sample_weight_vals</span> <span class="o">=</span> <span class="n">_extract_sample_weight</span><span class="p">(</span><span class="n">sample_weight</span><span class="p">,</span> <span class="n">target_series</span><span class="p">)</span>

    <span class="n">time_bounds</span> <span class="o">=</span> <span class="n">get_shared_times_bounds</span><span class="p">(</span><span class="o">*</span><span class="n">feature_times</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">time_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">raise_log</span><span class="p">(</span>
            <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Specified series do not share any common times for which features can be created.&quot;</span>
            <span class="p">),</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">_get_freqs</span><span class="p">(</span><span class="n">target_series</span><span class="p">,</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># `stop` is exclusive, so need `+ freq` to include end-point:</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span>
            <span class="n">start</span><span class="o">=</span><span class="n">time_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stop</span><span class="o">=</span><span class="n">time_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">freq</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">freq</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">time_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="n">time_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">stride</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># calculate the starting index so that the last element is included after applying the stride</span>
        <span class="c1"># equivalent to times[::-stride][::-1]</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">stride</span> <span class="p">::</span> <span class="n">stride</span><span class="p">]</span>
    <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_samples</span> <span class="o">&gt;</span> <span class="n">max_samples_per_ts</span><span class="p">:</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="n">max_samples_per_ts</span><span class="p">:]</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="n">max_samples_per_ts</span>
    <span class="c1"># Time index of &#39;earliest&#39; constructed observation:</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Construct features array X:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">start_time_idx</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">target_start_time_idx</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">series_i</span><span class="p">,</span> <span class="n">lags_extract_i</span><span class="p">,</span> <span class="n">lags_order_i</span><span class="p">,</span> <span class="n">min_lag_i</span><span class="p">,</span> <span class="n">max_lag_i</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span>
            <span class="p">[</span><span class="n">target_series</span><span class="p">,</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span><span class="p">],</span>
            <span class="n">lags_extract</span><span class="p">,</span>
            <span class="n">lags_order</span><span class="p">,</span>
            <span class="n">min_lags</span><span class="p">,</span>
            <span class="n">max_lags</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">):</span>
        <span class="n">series_and_lags_specified</span> <span class="o">=</span> <span class="n">min_lag_i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">is_target_series</span> <span class="o">=</span> <span class="n">is_training</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_target_series</span> <span class="ow">or</span> <span class="n">series_and_lags_specified</span><span class="p">:</span>
            <span class="c1"># get the position of `start_time` relative to the beginning of the current series</span>
            <span class="n">start_time_idx</span> <span class="o">=</span> <span class="n">n_steps_between</span><span class="p">(</span>
                <span class="n">end</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">series_i</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq</span><span class="o">=</span><span class="n">series_i</span><span class="o">.</span><span class="n">freq</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">series_and_lags_specified</span><span class="p">:</span>
            <span class="c1"># Windows taken between times `t - max_lag_i` and `t - min_lag_i`</span>
            <span class="n">window_len</span> <span class="o">=</span> <span class="n">max_lag_i</span> <span class="o">-</span> <span class="n">min_lag_i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">first_window_start_idx</span> <span class="o">=</span> <span class="n">start_time_idx</span> <span class="o">-</span> <span class="n">max_lag_i</span>
            <span class="n">first_window_end_idx</span> <span class="o">=</span> <span class="n">first_window_start_idx</span> <span class="o">+</span> <span class="n">window_len</span>
            <span class="c1"># Other windows are formed by sequentially shifting first window forward</span>
            <span class="c1"># by `stride` position each time; to create `(num_samples - 1)` more windows</span>
            <span class="c1"># in addition to the first window, need to take `(num_samples - 1) * stride`</span>
            <span class="c1"># values after `first_window_end_idx`:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">series_i</span><span class="o">.</span><span class="n">all_values</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span>
                <span class="n">first_window_start_idx</span> <span class="p">:</span> <span class="n">first_window_end_idx</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">num_samples</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">stride</span><span class="p">,</span>
                <span class="p">:,</span>
                <span class="p">:,</span>
            <span class="p">]</span>
            <span class="n">windows</span> <span class="o">=</span> <span class="n">strided_moving_window</span><span class="p">(</span>
                <span class="n">x</span><span class="o">=</span><span class="n">vals</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="n">window_len</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">check_inputs</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

            <span class="c1"># Within each window, the `-1` indexed value (i.e. the value at the very end of</span>
            <span class="c1"># the window) corresponds to time `t - min_lag_i`. The negative index of the time</span>
            <span class="c1"># `t + lag_i` within this window is, therefore, `-1 + lag_i + min_lag_i`:</span>
            <span class="c1"># extract lagged values</span>
            <span class="n">lagged_vals</span> <span class="o">=</span> <span class="n">_extract_lagged_vals_from_windows</span><span class="p">(</span>
                <span class="n">windows</span><span class="p">,</span> <span class="n">lags_extract_i</span><span class="p">,</span> <span class="n">lags_shift</span><span class="o">=</span><span class="n">min_lag_i</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="c1"># extract and append the reordered lagged values</span>
            <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lagged_vals</span><span class="p">[:,</span> <span class="n">lags_order_i</span><span class="p">])</span>
        <span class="c1"># Cache `start_time_idx` for label creation:</span>
        <span class="k">if</span> <span class="n">is_target_series</span><span class="p">:</span>
            <span class="n">target_start_time_idx</span> <span class="o">=</span> <span class="n">start_time_idx</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Construct labels array `y`:</span>
    <span class="k">if</span> <span class="n">is_training</span><span class="p">:</span>
        <span class="c1"># All values between times `t` and `t + output_chunk_length` used as labels / weights:</span>
        <span class="c1"># Window taken between times `t` and `t + output_chunk_length - 1`:</span>
        <span class="n">first_window_start_idx</span> <span class="o">=</span> <span class="n">target_start_time_idx</span> <span class="o">+</span> <span class="n">output_chunk_shift</span>
        <span class="c1"># Add `+ 1` since end index is exclusive in Python:</span>
        <span class="n">first_window_end_idx</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">target_start_time_idx</span> <span class="o">+</span> <span class="n">output_chunk_length</span> <span class="o">+</span> <span class="n">output_chunk_shift</span>
        <span class="p">)</span>
        <span class="n">lags_to_extract</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">multi_models</span> <span class="k">else</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># extract target labels and sample weights</span>
        <span class="n">y_and_weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vals</span> <span class="ow">in</span> <span class="p">[</span><span class="n">target_series</span><span class="o">.</span><span class="n">all_values</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">sample_weight_vals</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">y_and_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># To create `(num_samples - 1)` other windows in addition to first window,</span>
            <span class="c1"># must take `(num_samples - 1) * stride` values ahead of `first_window_end_idx`</span>
            <span class="c1"># to also take the stride into consideration</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span>
                <span class="n">first_window_start_idx</span> <span class="p">:</span> <span class="n">first_window_end_idx</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">num_samples</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">stride</span><span class="p">,</span>
                <span class="p">:,</span>
                <span class="p">:,</span>
            <span class="p">]</span>
            <span class="n">windows</span> <span class="o">=</span> <span class="n">strided_moving_window</span><span class="p">(</span>
                <span class="n">x</span><span class="o">=</span><span class="n">vals</span><span class="p">,</span>
                <span class="n">window_len</span><span class="o">=</span><span class="n">output_chunk_length</span><span class="p">,</span>
                <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">check_inputs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Only values at times `t + output_chunk_length - 1` used as labels:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">_extract_lagged_vals_from_windows</span><span class="p">(</span><span class="n">windows</span><span class="p">,</span> <span class="n">lags_to_extract</span><span class="p">)</span>
            <span class="n">y_and_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>

        <span class="n">y</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">y_and_weights</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">weights</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_extract_lagged_vals_from_windows</span><span class="p">(</span>
    <span class="n">windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">lags_to_extract</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">lags_shift</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function called by `_create_lagged_data_by_moving_window` that</span>
<span class="sd">    reshapes the `windows` formed by `strided_moving_window` from the</span>
<span class="sd">    shape `(num_windows, num_components, num_series, window_len)` to the</span>
<span class="sd">    shape `(num_windows, num_components * window_len, num_series)`. This reshaping</span>
<span class="sd">    is done such that the order of elements along axis 1 matches the pattern</span>
<span class="sd">    described in the docstring of `create_lagged_data`.</span>

<span class="sd">    If `lags_to_extract` is not specified, all values within each window is extracted.</span>
<span class="sd">    If `lags_to_extract` is specified as an np.ndarray, then only those values within each window that</span>
<span class="sd">    are indexed by `lags_to_extract` will be returned. In such cases, the shape of the returned</span>
<span class="sd">    lagged values is `(num_windows, num_components * lags_to_extract.size, num_series)`. For example,</span>
<span class="sd">    if `lags_to_extract = [-2]`, only the second-to-last values within each window will be extracted.</span>
<span class="sd">    If `lags_to_extract` is specified as a list of np.ndarray, the values will be extracted using the</span>
<span class="sd">    lags provided for each component. In such cases, the shape of the returned lagged values is</span>
<span class="sd">    `(num_windows, sum([comp_lags.size for comp_lags in lags_to_extract]), num_series)`. For example,</span>
<span class="sd">    if `lags_to_extract = [[-2, -1], [-1]]`, the second-to-last and last values of the first component</span>
<span class="sd">    and the last values of the second component within each window will be extracted.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># windows.shape = (num_windows, num_components, num_samples, window_len):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lags_to_extract</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c1"># iterate over the components-specific lags</span>
        <span class="n">comp_windows</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">windows</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="n">comp_lags_to_extract</span> <span class="o">+</span> <span class="n">lags_shift</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">comp_lags_to_extract</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lags_to_extract</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># windows.shape = (sum(lags_len) across components, num_windows, num_samples):</span>
        <span class="n">windows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">comp_windows</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">lagged_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">windows</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lags_to_extract</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">windows</span> <span class="o">=</span> <span class="n">windows</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">lags_to_extract</span> <span class="o">+</span> <span class="n">lags_shift</span><span class="p">]</span>
        <span class="c1"># windows.shape = (num_windows, window_len, num_components, num_samples):</span>
        <span class="n">windows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">windows</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="c1"># lagged_vals.shape = (num_windows, num_components*window_len, num_samples):</span>
        <span class="n">lagged_vals</span> <span class="o">=</span> <span class="n">windows</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">lagged_vals</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_create_lagged_data_by_intersecting_times</span><span class="p">(</span>
    <span class="n">target_series</span><span class="p">:</span> <span class="n">TimeSeries</span><span class="p">,</span>
    <span class="n">output_chunk_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">output_chunk_shift</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
    <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
    <span class="n">sample_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
    <span class="n">lags</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">lags_past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">lags_future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">max_samples_per_ts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">multi_models</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">check_inputs</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">is_training</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">show_warnings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">],</span>
    <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
<span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function called by `_create_lagged_data` that computes `X`, `y`, and `times` by</span>
<span class="sd">    first finding the time points in each series that *could* be used to create features/labels,</span>
<span class="sd">    and then finding which of these &#39;available&#39; times is shared by all specified series. The lagged</span>
<span class="sd">    values are then extracted by finding the index of each of these &#39;shared times&#39; in each series,</span>
<span class="sd">    and then offsetting this index by the requested lag value (if constructing `X`) or the requested</span>
<span class="sd">    `output_chunk_length` (if constructing `y`). This approach is used if we *cannot* assume that the</span>
<span class="sd">    specified series are of the same frequency.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">feature_times</span><span class="p">,</span> <span class="n">min_lags</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_get_feature_times</span><span class="p">(</span>
        <span class="n">target_series</span><span class="o">=</span><span class="n">target_series</span><span class="p">,</span>
        <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
        <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
        <span class="n">lags</span><span class="o">=</span><span class="n">lags</span><span class="p">,</span>
        <span class="n">lags_past_covariates</span><span class="o">=</span><span class="n">lags_past_covariates</span><span class="p">,</span>
        <span class="n">lags_future_covariates</span><span class="o">=</span><span class="n">lags_future_covariates</span><span class="p">,</span>
        <span class="n">output_chunk_length</span><span class="o">=</span><span class="n">output_chunk_length</span><span class="p">,</span>
        <span class="n">output_chunk_shift</span><span class="o">=</span><span class="n">output_chunk_shift</span><span class="p">,</span>
        <span class="n">is_training</span><span class="o">=</span><span class="n">is_training</span><span class="p">,</span>
        <span class="n">return_min_and_max_lags</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">check_inputs</span><span class="o">=</span><span class="n">check_inputs</span><span class="p">,</span>
        <span class="n">show_warnings</span><span class="o">=</span><span class="n">show_warnings</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">check_inputs</span><span class="p">:</span>
        <span class="n">series_and_lags_not_specified</span> <span class="o">=</span> <span class="p">[</span><span class="n">min_lag</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">min_lag</span> <span class="ow">in</span> <span class="n">min_lags</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">series_and_lags_not_specified</span><span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must specify at least one series-lags pair.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">stride</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`stride` must be a positive integer greater than 0.&quot;</span><span class="p">),</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="n">sample_weight_vals</span> <span class="o">=</span> <span class="n">_extract_sample_weight</span><span class="p">(</span><span class="n">sample_weight</span><span class="p">,</span> <span class="n">target_series</span><span class="p">)</span>
    <span class="n">shared_times</span> <span class="o">=</span> <span class="n">get_shared_times</span><span class="p">(</span><span class="o">*</span><span class="n">feature_times</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shared_times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">raise_log</span><span class="p">(</span>
            <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Specified series do not share any common times for which features can be created.&quot;</span>
            <span class="p">),</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">stride</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># calculate the starting index so that the last element is included after applying the stride</span>
        <span class="c1"># equivalent to shared_times[::-stride][::-1]</span>
        <span class="n">shared_times</span> <span class="o">=</span> <span class="n">shared_times</span><span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="n">shared_times</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">stride</span> <span class="p">::</span> <span class="n">stride</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shared_times</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_samples_per_ts</span><span class="p">:</span>
        <span class="n">shared_times</span> <span class="o">=</span> <span class="n">shared_times</span><span class="p">[</span><span class="o">-</span><span class="n">max_samples_per_ts</span><span class="p">:]</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">shared_time_idx</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">label_shared_time_idx</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">series_i</span><span class="p">,</span> <span class="n">lags_i</span><span class="p">,</span> <span class="n">min_lag_i</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span>
            <span class="p">[</span><span class="n">target_series</span><span class="p">,</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span><span class="p">],</span>
            <span class="p">[</span><span class="n">lags</span><span class="p">,</span> <span class="n">lags_past_covariates</span><span class="p">,</span> <span class="n">lags_future_covariates</span><span class="p">],</span>
            <span class="n">min_lags</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">):</span>
        <span class="n">series_and_lags_specified</span> <span class="o">=</span> <span class="n">min_lag_i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">is_target_series</span> <span class="o">=</span> <span class="n">is_training</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">series_and_lags_specified</span> <span class="ow">or</span> <span class="n">is_target_series</span><span class="p">:</span>
            <span class="n">time_index_i</span> <span class="o">=</span> <span class="n">series_i</span><span class="o">.</span><span class="n">time_index</span>
            <span class="n">add_to_start</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_target_series</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">time_index_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">shared_times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">add_to_end</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_target_series</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">time_index_i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">shared_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">add_to_start</span> <span class="ow">or</span> <span class="n">add_to_end</span><span class="p">:</span>
                <span class="n">new_start</span> <span class="o">=</span> <span class="n">shared_times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">add_to_start</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">new_end</span> <span class="o">=</span> <span class="n">shared_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">add_to_end</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">num_prepended</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">time_index_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">shared_times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">//</span> <span class="n">series_i</span><span class="o">.</span><span class="n">freq</span>
                    <span class="k">if</span> <span class="n">add_to_start</span>
                    <span class="k">else</span> <span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">time_index_i</span> <span class="o">=</span> <span class="n">_extend_time_index</span><span class="p">(</span>
                    <span class="n">time_index_i</span><span class="p">,</span> <span class="n">series_i</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">new_start</span><span class="o">=</span><span class="n">new_start</span><span class="p">,</span> <span class="n">new_end</span><span class="o">=</span><span class="n">new_end</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">num_prepended</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">shared_time_idx</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">time_index_i</span><span class="p">,</span> <span class="n">shared_times</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="o">-</span> <span class="n">num_prepended</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">series_and_lags_specified</span><span class="p">:</span>
            <span class="n">idx_to_get</span> <span class="o">=</span> <span class="n">shared_time_idx</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lags_i</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="c1"># Before reshaping: lagged_vals.shape = (n_observations, num_lags, n_components, n_samples)</span>
            <span class="n">lagged_vals</span> <span class="o">=</span> <span class="n">series_i</span><span class="o">.</span><span class="n">all_values</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="n">idx_to_get</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="c1"># After reshaping: lagged_vals.shape = (n_observations, num_lags*n_components, n_samples)</span>
            <span class="n">lagged_vals</span> <span class="o">=</span> <span class="n">lagged_vals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">lagged_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">lagged_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lagged_vals</span><span class="p">)</span>
        <span class="c1"># `target_series` indices required for creating labels:</span>
        <span class="k">if</span> <span class="n">is_target_series</span><span class="p">:</span>
            <span class="n">label_shared_time_idx</span> <span class="o">=</span> <span class="n">shared_time_idx</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_training</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">multi_models</span><span class="p">:</span>
            <span class="c1"># All points between time `t` and `t + output_chunk_length - 1` are labels:</span>
            <span class="n">idx_to_get</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">label_shared_time_idx</span>
                <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">output_chunk_length</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">output_chunk_shift</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Only point at time `t + output_chunk_length - 1` is a label:</span>
            <span class="n">idx_to_get</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">label_shared_time_idx</span> <span class="o">+</span> <span class="n">output_chunk_length</span> <span class="o">+</span> <span class="n">output_chunk_shift</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="p">)</span>

        <span class="c1"># extract target labels and sample weights</span>
        <span class="n">y_and_weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vals</span> <span class="ow">in</span> <span class="p">[</span><span class="n">target_series</span><span class="o">.</span><span class="n">all_values</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">sample_weight_vals</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">y_and_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Before reshaping: lagged_vals.shape = (n_observations, num_lags, n_components, n_samples)</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">idx_to_get</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="c1"># After reshaping: lagged_vals.shape = (n_observations, num_lags*n_components, n_samples)</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">y_and_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">y_and_weights</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">shared_times</span><span class="p">,</span> <span class="n">weights</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_create_lagged_data_autoregression</span><span class="p">(</span>
    <span class="n">target_series</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span>
    <span class="n">t_pred</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">shift</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">last_step_shift</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">series_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">covariate_matrices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">lags</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">component_lags</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span>
    <span class="n">relative_cov_lags</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">uses_static_covariates</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">last_static_covariates_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract lagged data from target, past covariates and future covariates for auto-regression</span>
<span class="sd">    with SKLearnModels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">series_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_series</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">series_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">,</span> <span class="s2">&quot;past&quot;</span><span class="p">,</span> <span class="s2">&quot;future&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">series_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lags</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># extract series specific data</span>
        <span class="n">values_matrix</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">series_matrix</span>
            <span class="k">if</span> <span class="n">series_type</span> <span class="o">==</span> <span class="s2">&quot;target&quot;</span>
            <span class="k">else</span> <span class="n">covariate_matrices</span><span class="p">[</span><span class="n">series_type</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">series_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">component_lags</span><span class="p">:</span>
            <span class="c1"># for global lags over all components, directly extract lagged values from the data</span>
            <span class="k">if</span> <span class="n">series_type</span> <span class="o">==</span> <span class="s2">&quot;target&quot;</span><span class="p">:</span>
                <span class="n">relative_lags</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">lag</span> <span class="o">-</span> <span class="p">(</span><span class="n">shift</span> <span class="o">+</span> <span class="n">last_step_shift</span><span class="p">)</span> <span class="k">for</span> <span class="n">lag</span> <span class="ow">in</span> <span class="n">lags</span><span class="p">[</span><span class="n">series_type</span><span class="p">]</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">relative_lags</span> <span class="o">=</span> <span class="n">relative_cov_lags</span><span class="p">[</span><span class="n">series_type</span><span class="p">]</span> <span class="o">+</span> <span class="n">t_pred</span>

            <span class="n">lagged_data</span> <span class="o">=</span> <span class="n">values_matrix</span><span class="p">[:,</span> <span class="n">relative_lags</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">series_length</span> <span class="o">*</span> <span class="n">num_samples</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># for component-specific lags, sort by lags and components and then extract</span>
            <span class="n">tmp_X</span> <span class="o">=</span> <span class="n">_extract_component_lags_autoregression</span><span class="p">(</span>
                <span class="n">series_type</span><span class="o">=</span><span class="n">series_type</span><span class="p">,</span>
                <span class="n">values_matrix</span><span class="o">=</span><span class="n">values_matrix</span><span class="p">,</span>
                <span class="n">shift</span><span class="o">=</span><span class="n">shift</span><span class="p">,</span>
                <span class="n">last_step_shift</span><span class="o">=</span><span class="n">last_step_shift</span><span class="p">,</span>
                <span class="n">t_pred</span><span class="o">=</span><span class="n">t_pred</span><span class="p">,</span>
                <span class="n">lags</span><span class="o">=</span><span class="n">lags</span><span class="p">,</span>
                <span class="n">component_lags</span><span class="o">=</span><span class="n">component_lags</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">lagged_data</span> <span class="o">=</span> <span class="n">tmp_X</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">series_length</span> <span class="o">*</span> <span class="n">num_samples</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lagged_data</span><span class="p">)</span>
    <span class="c1"># concatenate retrieved lags</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">uses_static_covariates</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">X</span>

    <span class="c1"># Need to split up `X` into three equally-sized sub-blocks</span>
    <span class="c1"># corresponding to each timeseries in `series`, so that</span>
    <span class="c1"># static covariates can be added to each block; valid since</span>
    <span class="c1"># each block contains same number of observations:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">series_length</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">add_static_covariates_to_lagged_data</span><span class="p">(</span>
        <span class="n">features</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
        <span class="n">target_series</span><span class="o">=</span><span class="n">target_series</span><span class="p">,</span>
        <span class="n">uses_static_covariates</span><span class="o">=</span><span class="n">uses_static_covariates</span><span class="p">,</span>
        <span class="n">last_shape</span><span class="o">=</span><span class="n">last_static_covariates_shape</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># concatenate retrieved lags</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_extract_component_lags_autoregression</span><span class="p">(</span>
    <span class="n">series_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">values_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">shift</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">last_step_shift</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">t_pred</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">lags</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">component_lags</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract, concatenate and reorder component-wise lags to obtain a feature order</span>
<span class="sd">    identical to tabularization.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># prepare index to reorder features by lags across components</span>
    <span class="n">comp_lags_reordered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span>
        <span class="n">comp_lags</span> <span class="k">for</span> <span class="n">comp_lags</span> <span class="ow">in</span> <span class="n">component_lags</span><span class="p">[</span><span class="n">series_type</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
    <span class="p">])</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">**</span><span class="n">STABLE_SORT_KWARGS</span><span class="p">)</span>

    <span class="c1"># convert relative lags to absolute</span>
    <span class="k">if</span> <span class="n">series_type</span> <span class="o">==</span> <span class="s2">&quot;target&quot;</span><span class="p">:</span>
        <span class="n">lags_shift</span> <span class="o">=</span> <span class="o">-</span><span class="n">shift</span> <span class="o">-</span> <span class="n">last_step_shift</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lags_shift</span> <span class="o">=</span> <span class="o">-</span><span class="n">lags</span><span class="p">[</span><span class="n">series_type</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">t_pred</span>

    <span class="c1"># extract features</span>
    <span class="n">tmp_X</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">values_matrix</span><span class="p">[</span>
            <span class="p">:,</span>
            <span class="p">[</span><span class="n">lag</span> <span class="o">+</span> <span class="n">lags_shift</span> <span class="k">for</span> <span class="n">lag</span> <span class="ow">in</span> <span class="n">comp_lags</span><span class="p">],</span>
            <span class="n">comp_i</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">comp_i</span><span class="p">,</span> <span class="n">comp_lags</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">component_lags</span><span class="p">[</span><span class="n">series_type</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="p">]</span>

    <span class="c1"># concatenate on features dimension and reorder</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">tmp_X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">comp_lags_reordered</span><span class="p">]</span>


<span class="c1"># For convenience, define following types for `_get_feature_times`:</span>
<span class="n">FeatureTimes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span>
    <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">]],</span>
    <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">]],</span>
    <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">]],</span>
<span class="p">]</span>
<span class="n">MinLags</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span>
<span class="n">MaxLags</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_feature_times</span><span class="p">(</span>
    <span class="n">target_series</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">lags</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">lags_past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">lags_future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">output_chunk_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">output_chunk_shift</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">is_training</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_min_and_max_lags</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">check_inputs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">show_warnings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">FeatureTimes</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">FeatureTimes</span><span class="p">,</span> <span class="n">MinLags</span><span class="p">,</span> <span class="n">MaxLags</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a tuple containing the times in `target_series`, the times in `past_covariates`, and the times in</span>
<span class="sd">    `future_covariates` that *could* be used to create features. The returned tuple of times can then be passed</span>
<span class="sd">    to `get_shared_times` to compute the &#39;eligible time points&#39; shared by all specified series.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For the purposes of extracting feature times from each series, we define the `min_lag` and `max_lag` of</span>
<span class="sd">    each series to be:</span>
<span class="sd">            `min_lag = -max(lags_*)`,</span>
<span class="sd">            `max_lag = -min(lags_*)`</span>
<span class="sd">    where `lags_*` denotes either `lags`, `lags_past_covariates`, or `lags_future_covariates`.</span>

<span class="sd">    For both `lags` and `lags_past_covariates`, `min_lag` and `max_lag` are guaranteed to be positive values,</span>
<span class="sd">    since the values in `lags` and `lags_past_covariates` must all be negative. For these two series then,</span>
<span class="sd">    `min_lag` and `max_lag` represent the smallest and largest magnitude lags requested by the user. For example:</span>
<span class="sd">            `lags = [-3, -2, -1] -&gt; min_lag = 1, max_lag = 3`</span>

<span class="sd">    The values contained in `lags_future_covariates`, on the other hand, can be negative, zero, or positive; this</span>
<span class="sd">    means that there are three cases to consider:</span>
<span class="sd">        1. Both `min_lag` and `max_lag` are positive, which means that all the values in `lags_future_covariates`</span>
<span class="sd">        are negative. In this case, `min_lag` and `max_lag` correspond to the smallest and largest</span>
<span class="sd">        lag magnitudes respectively. For example:</span>
<span class="sd">                `lags_future_covariates = [-3, -2, -1] -&gt; min_lag = 1, max_lag = 3`</span>
<span class="sd">        2. `min_lag` is non-positive (i.e. zero or negative), but `max_lag` is positive, which means that</span>
<span class="sd">        `lags_future_covariates` contains both negative and non-negative (i.e. zero or positive) lag values.</span>
<span class="sd">        In this case, `abs(min_lag)` corresponds to the magnitude of the largest *non-negative* lag value in</span>
<span class="sd">        `lags_future_covariates`, whilst `max_lag` corresponds to the largest *negative* lag value in</span>
<span class="sd">        `lags_future_covariates`. For example:</span>
<span class="sd">                `lags_future_covariates = [-2, -1, 0, 1, 3] -&gt; min_lag = -3, max_lag = 2`</span>
<span class="sd">        3. Both `min_lag` and `max_lag` are non-positive, which means that `lags_future_covariates` contains</span>
<span class="sd">        only non-negative lag values. In this case, `abs(min_lag)` and `abs(max_lag)`, rather confusingly,</span>
<span class="sd">        correspond to the largest and smallest lag magnitudes respectively. For example:</span>
<span class="sd">                `lags_future_covariates = [1, 2, 3] -&gt; min_lag = -3, max_lag = -1`</span>
<span class="sd">    In all three cases, we have `min_lag &lt;= max_lag`. As a direct consequence:</span>
<span class="sd">        1. `min_lag &gt; 0` is a sufficient condition for `min_lag` and `max_lag` both being positive (i.e. Case 1).</span>
<span class="sd">        2. `max_lag &lt;= 0` is a sufficient condition for `min_lag` and `max_lag` both being non-positive (i.e. Case 2).</span>

<span class="sd">    To extract feature times from a `target_series` when `is_training = True`, the following steps are performed:</span>
<span class="sd">        1. The first `max_lag` times of the series are excluded; these times have too few preceding values to</span>
<span class="sd">        construct features from.</span>
<span class="sd">        2. The last `output_chunk_length - output_chunk_shift - 1` times are excluded; these times have too few</span>
<span class="sd">        succeeding times to construct labels from.</span>

<span class="sd">    To extract feature times from a `target_series` when `is_training = False`, the following steps are performed:</span>
<span class="sd">        1. An additional `min_lag` times are appended to the end of the series; although these times are not contained</span>
<span class="sd">        in the original series, we&#39;re able to construct features for them since we only need the values of the series</span>
<span class="sd">        from time `t - max_lag` to `t - min_lag` to construct a feature for time `t`.</span>
<span class="sd">        2. The first `max_lag` times of the series are then excluded; these times have too few preceding values to</span>
<span class="sd">        construct features from.</span>
<span class="sd">    The exact same procedure is performed to extract the feature times from a `past_covariates` series.</span>

<span class="sd">    To extract feature times from `future_covariates`, we perform the following steps:</span>
<span class="sd">        1. Depending on the signs of `min_lag` and `max_lag`, additional times are either prepended or appended</span>
<span class="sd">        to the original series. More specifically:</span>
<span class="sd">            a) If `min_lag` and `max_lag` are both positive (i.e. `min_lag &gt; 0`), then an additional `min_lag` times</span>
<span class="sd">            are appended to the end of the series; as previously mentioned, we only need values up to time `t - min_lag`</span>
<span class="sd">            to construct a feature for time `t`.</span>
<span class="sd">            b) If `min_lag` and `max_lag` are both non-positive (i.e. `max_lag &lt; 0`), then an additional `abs(max_lag)`</span>
<span class="sd">            times are prepended to the start of the series; this is because we only need to know the values of the</span>
<span class="sd">            series *after* time `t + abs(max_lag)` to construct a feature for time `t` when we&#39;re only extracting</span>
<span class="sd">            positive lags from `future_covariates`.</span>
<span class="sd">            c) If `min_lag` is non-positive and `max_lag` is positive, then *no additional times* are added to the</span>
<span class="sd">            series, since constructing a feature for time `t` requires knowing values from time `t - max_lag` to</span>
<span class="sd">            time `t + abs(min_lag)`; in other words, we need to have access to time `t` itself.</span>
<span class="sd">        2. If `min_lag &lt; 0`, the last `abs(min_lag)` times are excluded, since these values have fewer</span>
<span class="sd">        than `abs(min_lag)` values after them, which means we&#39;re unable to construct features for these times.</span>
<span class="sd">        3. If `max_lag &gt; 0`, the first `max_lag` times are excluded, since these values have fewer than `max_lag` values</span>
<span class="sd">        before them, which means we&#39;re unable to construct features for these times.</span>

<span class="sd">    Some additional behaviours to note about the `_get_feature_times` function are:</span>
<span class="sd">        1. If `return_min_and_max_lags = True`, the smallest and largest lag value for each</span>
<span class="sd">        series is also returned as a pair of tuples.</span>
<span class="sd">        2. For those series which are either unspecified, a `None` value takes the place of</span>
<span class="sd">        that series&#39; feature time, minimum lag values, and maximum lag value.</span>
<span class="sd">        3. If `is_training = True`, then `target_series` and `output_chunk_length` must</span>
<span class="sd">        be provided.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target_series</span>
<span class="sd">        Optionally, the series for the `SKLearnModel` to predict.</span>
<span class="sd">    past_covariates</span>
<span class="sd">        Optionally, the past covariates series that the `SKLearnModel` will use as inputs. Unlike the</span>
<span class="sd">        `target_series`, `past_covariates` are *not* to be predicted by the `SKLearnModel`.</span>
<span class="sd">    future_covariates</span>
<span class="sd">        Optionally, the future covariates (i.e. exogenous covariates) series that the `SKLearnModel` will</span>
<span class="sd">        use as inputs.</span>
<span class="sd">    lags</span>
<span class="sd">        Optionally, the lags of the target series to be used as (autoregressive) features. If not specified,</span>
<span class="sd">        autoregressive features will *not* be added to `X`.</span>
<span class="sd">    lags_past_covariates</span>
<span class="sd">        Optionally, the lags of `past_covariates` to be used as features.</span>
<span class="sd">    lags_future_covariates</span>
<span class="sd">        Optionally, the lags of `future_covariates` to be used as features.</span>
<span class="sd">    output_chunk_length</span>
<span class="sd">        Optionally, the number of time steps ahead into the future the `SKLearnModel` is to predict. This is ignored</span>
<span class="sd">        if `is_training = False`.</span>
<span class="sd">    output_chunk_shift</span>
<span class="sd">        Optionally, the number of time steps to shift the output chunk ahead into the future.</span>
<span class="sd">    is_training</span>
<span class="sd">        Optionally, specifies that training data is to be generated from the specified series. If `True`,</span>
<span class="sd">        `target_series`, `output_chunk_length`, and `multi_models` must all be specified.</span>
<span class="sd">    check_inputs</span>
<span class="sd">        Optionally, specifies that the `lags_*` and `series_*` inputs should be checked for validity. Should be set</span>
<span class="sd">        to `False` if inputs have already been checked for validity (e.g. inside the `__init__` of a class), otherwise</span>
<span class="sd">        should be set to `True`.</span>
<span class="sd">    return_min_and_max_lags</span>
<span class="sd">        Optionally, specifies whether the largest magnitude lag value for each series should also be returned along with</span>
<span class="sd">        the &#39;eligible&#39; feature times</span>
<span class="sd">    show_warnings</span>
<span class="sd">        Whether to show warnings.</span>

<span class="sd">    Note: if the lags are provided as a dictionary for the target series or any of the covariates series, the</span>
<span class="sd">    component-specific lags are grouped into a single list to compute the corresponding feature time.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    feature_times</span>
<span class="sd">        A tuple containing all the &#39;eligible feature times&#39; in `target_series`, in `past_covariates`, and in</span>
<span class="sd">        `future_covariates`, in that order. If a particular series-lag pair isn&#39;t fully specified, then a `None`</span>
<span class="sd">        will take the place of that series&#39; eligible times.</span>
<span class="sd">    min_lags</span>
<span class="sd">        Optionally, a tuple containing the smallest lag value in `lags`, `lags_past_covariates`, and</span>
<span class="sd">        `lags_future_covariates`, in that order. If a particular series-lag pair isn&#39;t fully specified, then a `None`</span>
<span class="sd">        will take the place of that series&#39; minimum lag values.</span>
<span class="sd">    max_lags</span>
<span class="sd">        Optionally, a tuple containing the largest lag value in `lags`, `lags_past_covariates`, and</span>
<span class="sd">        `lags_future_covariates`, in that order. If a particular series-lag pair isn&#39;t fully specified, then a `None`</span>
<span class="sd">        will take the place of that series&#39; maximum lag values.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `target_series` and `output_chunk_length` are not both specified if `is_training = True`.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If any of the `lags` inputs contain non-negative values or if none of the `lags` inputs have been specified.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If any of the series are too short for the requested `lags` and/or `output_chunk_length` values.</span>
<span class="sd">    UserWarning</span>
<span class="sd">        If a `lags_*` input is specified without the accompanying time series or vice versa. The only expection to this</span>
<span class="sd">        is when `lags` isn&#39;t specified alongside `target_series` when `is_training = True`, since one may wish to fit</span>
<span class="sd">        a `SKLearnModel` without using autoregressive features.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_training</span> <span class="ow">and</span> <span class="p">(</span><span class="n">target_series</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">raise_log</span><span class="p">(</span>
            <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must specify `target_series` when `is_training = True`.&quot;</span><span class="p">),</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">check_inputs</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_chunk_length</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">output_chunk_length</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`output_chunk_length` must be a positive `int`.&quot;</span><span class="p">),</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">_check_lags</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="n">lags_past_covariates</span><span class="p">,</span> <span class="n">lags_future_covariates</span><span class="p">)</span>
    <span class="n">feature_times</span><span class="p">,</span> <span class="n">min_lags</span><span class="p">,</span> <span class="n">max_lags</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name_i</span><span class="p">,</span> <span class="n">series_i</span><span class="p">,</span> <span class="n">lags_i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="p">[</span><span class="s2">&quot;target_series&quot;</span><span class="p">,</span> <span class="s2">&quot;past_covariates&quot;</span><span class="p">,</span> <span class="s2">&quot;future_covariates&quot;</span><span class="p">],</span>
        <span class="p">[</span><span class="n">target_series</span><span class="p">,</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span><span class="p">],</span>
        <span class="p">[</span><span class="n">lags</span><span class="p">,</span> <span class="n">lags_past_covariates</span><span class="p">,</span> <span class="n">lags_future_covariates</span><span class="p">],</span>
    <span class="p">):</span>
        <span class="c1"># union of the component-specific lags, unsorted</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lags_i</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">lags_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">lags_i</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>

        <span class="k">if</span> <span class="n">check_inputs</span> <span class="ow">and</span> <span class="p">(</span><span class="n">series_i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">_check_series_length</span><span class="p">(</span>
                <span class="n">series</span><span class="o">=</span><span class="n">series_i</span><span class="p">,</span>
                <span class="n">lags</span><span class="o">=</span><span class="n">lags_i</span><span class="p">,</span>
                <span class="n">output_chunk_length</span><span class="o">=</span><span class="n">output_chunk_length</span><span class="p">,</span>
                <span class="n">output_chunk_shift</span><span class="o">=</span><span class="n">output_chunk_shift</span><span class="p">,</span>
                <span class="n">is_training</span><span class="o">=</span><span class="n">is_training</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name_i</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">series_specified</span> <span class="o">=</span> <span class="n">series_i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">lags_specified</span> <span class="o">=</span> <span class="n">lags_i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">is_label_series</span> <span class="o">=</span> <span class="n">is_training</span> <span class="ow">and</span> <span class="n">name_i</span> <span class="o">==</span> <span class="s2">&quot;target_series&quot;</span>
        <span class="n">times_i</span> <span class="o">=</span> <span class="n">series_i</span><span class="o">.</span><span class="n">time_index</span> <span class="k">if</span> <span class="n">series_specified</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">max_lag_i</span> <span class="o">=</span> <span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">lags_i</span><span class="p">)</span> <span class="k">if</span> <span class="n">lags_specified</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">min_lag_i</span> <span class="o">=</span> <span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">lags_i</span><span class="p">)</span> <span class="k">if</span> <span class="n">lags_specified</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">is_label_series</span><span class="p">:</span>
            <span class="c1"># Exclude last `output_chunk_length - 1` times:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">output_chunk_shift</span><span class="p">:</span>
                <span class="n">end_idx</span> <span class="o">=</span> <span class="o">-</span><span class="n">output_chunk_length</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">output_chunk_length</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">end_idx</span> <span class="o">=</span> <span class="o">-</span><span class="n">output_chunk_length</span> <span class="o">-</span> <span class="n">output_chunk_shift</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">times_i</span> <span class="o">=</span> <span class="n">times_i</span><span class="p">[:</span><span class="n">end_idx</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">series_specified</span> <span class="ow">and</span> <span class="n">lags_specified</span><span class="p">:</span>
            <span class="c1"># Prepend times to start of series - see Step 1a for extracting</span>
            <span class="c1"># feature times from `future_covariates` in `Notes`:</span>
            <span class="n">new_start</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">times_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">series_i</span><span class="o">.</span><span class="n">freq</span> <span class="o">*</span> <span class="n">max_lag_i</span> <span class="k">if</span> <span class="n">max_lag_i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="p">)</span>
            <span class="c1"># Append times to end of series - see Step 1b for extracting features</span>
            <span class="c1"># times from `future_covariates`, or Step 1 for extracting features</span>
            <span class="c1"># from `target_series`/`past_covariates` in `Notes`:</span>
            <span class="n">new_end</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">times_i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">series_i</span><span class="o">.</span><span class="n">freq</span> <span class="o">*</span> <span class="p">(</span><span class="n">min_lag_i</span><span class="p">)</span> <span class="k">if</span> <span class="n">min_lag_i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="p">)</span>
            <span class="n">times_i</span> <span class="o">=</span> <span class="n">_extend_time_index</span><span class="p">(</span>
                <span class="n">times_i</span><span class="p">,</span> <span class="n">series_i</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">new_start</span><span class="o">=</span><span class="n">new_start</span><span class="p">,</span> <span class="n">new_end</span><span class="o">=</span><span class="n">new_end</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">series_specified</span> <span class="ow">and</span> <span class="n">lags_specified</span><span class="p">:</span>
            <span class="c1"># Exclude last `abs(min_lag)` times - see Step 2 for extracting feature</span>
            <span class="c1"># times from `future_covariates` in `Notes`:</span>
            <span class="k">if</span> <span class="n">min_lag_i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">times_i</span> <span class="o">=</span> <span class="n">times_i</span><span class="p">[:</span><span class="n">min_lag_i</span><span class="p">]</span>
            <span class="c1"># Exclude first `max_lag` times - see Step 3 for extracting feature times</span>
            <span class="c1"># from `future_covariates`, or Step 2 in extracting feature times from</span>
            <span class="c1"># `target_series`/`past_covariates` in `Notes`:</span>
            <span class="k">if</span> <span class="n">max_lag_i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">times_i</span> <span class="o">=</span> <span class="n">times_i</span><span class="p">[</span><span class="n">max_lag_i</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">show_warnings</span>
            <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_label_series</span><span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">series_specified</span> <span class="o">^</span> <span class="n">lags_specified</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># Warn user that series/lags input will be ignored:</span>
            <span class="n">times_i</span> <span class="o">=</span> <span class="n">max_lag_i</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">lags_name</span> <span class="o">=</span> <span class="s2">&quot;lags&quot;</span> <span class="k">if</span> <span class="n">name_i</span> <span class="o">==</span> <span class="s2">&quot;target_series&quot;</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;lags_</span><span class="si">{</span><span class="n">name_i</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">specified</span> <span class="o">=</span> <span class="n">lags_name</span> <span class="k">if</span> <span class="n">lags_specified</span> <span class="k">else</span> <span class="n">name_i</span>
            <span class="n">unspecified</span> <span class="o">=</span> <span class="n">name_i</span> <span class="k">if</span> <span class="n">lags_specified</span> <span class="k">else</span> <span class="n">lags_name</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">specified</span><span class="si">}</span><span class="s2">` was specified without accompanying `</span><span class="si">{</span><span class="n">unspecified</span><span class="si">}</span><span class="s2">` and, thus, will be ignored.&quot;</span>
            <span class="p">)</span>

        <span class="n">feature_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">times_i</span><span class="p">)</span>
        <span class="c1"># Note `max_lag_i` and `min_lag_i` if requested:</span>
        <span class="k">if</span> <span class="n">series_specified</span> <span class="ow">and</span> <span class="n">lags_specified</span><span class="p">:</span>
            <span class="n">min_lags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_lag_i</span><span class="p">)</span>
            <span class="n">max_lags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_lag_i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">min_lags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">max_lags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">feature_times</span><span class="p">,</span> <span class="n">min_lags</span><span class="p">,</span> <span class="n">max_lags</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_min_and_max_lags</span>
        <span class="k">else</span> <span class="n">feature_times</span>
    <span class="p">)</span>


<div class="viewcode-block" id="get_shared_times"><a class="viewcode-back" href="../../../../../generated_api/darts.utils.data.tabularization.tabularization.html#darts.utils.data.tabularization.tabularization.get_shared_times">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">get_shared_times</span><span class="p">(</span>
    <span class="o">*</span><span class="n">series_or_times</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the times shared by all specified `TimeSeries` or time indexes (i.e. the intersection of all</span>
<span class="sd">    these times). If `sort = True`, then these shared times are sorted from earliest to latest. Any `TimeSeries` or</span>
<span class="sd">    time indices in `series_or_times` that aren&#39;t specified (i.e. are `None`) are simply ignored.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    series_or_times</span>
<span class="sd">        The `TimeSeries` and/or time indices that should &#39;intersected&#39;.</span>
<span class="sd">    sort</span>
<span class="sd">        Optionally, specifies that the returned shared times should be sorted from earliest to latest.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    shared_times</span>
<span class="sd">        The time indices present in all specified `TimeSeries` and/or time indices.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the specified `TimeSeries` and/or time indices do not all share the same type of time index (i.e. must</span>
<span class="sd">        either be all `pd.DatetimeIndex` or all `pd.RangeIndex`).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># `sort = None` specifies to `pd.Index.intersection` that values should be sorted:</span>
    <span class="n">sort</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">sort</span> <span class="k">else</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">intersection_func</span><span class="p">(</span><span class="n">series_or_times_1</span><span class="p">,</span> <span class="n">series_or_times_2</span><span class="p">):</span>
        <span class="n">times_1</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">series_or_times_1</span><span class="o">.</span><span class="n">time_index</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">series_or_times_1</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">series_or_times_1</span>
        <span class="p">)</span>
        <span class="n">times_2</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">series_or_times_2</span><span class="o">.</span><span class="n">time_index</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">series_or_times_2</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">series_or_times_2</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">times_1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">times_2</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>

    <span class="n">specified_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">series</span> <span class="k">for</span> <span class="n">series</span> <span class="ow">in</span> <span class="n">series_or_times</span> <span class="k">if</span> <span class="n">series</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">specified_inputs</span><span class="p">:</span>
        <span class="n">shared_times</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">specified_inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">shared_times</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">specified_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">time_index</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">specified_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TimeSeries</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">specified_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">shared_times</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shared_times</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">shared_times</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shared_times</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">intersection_func</span><span class="p">,</span> <span class="n">specified_inputs</span><span class="p">)</span>
        <span class="c1"># Empty intersection may result from intersecting time indices being of different types - throw error if so:</span>
        <span class="k">if</span> <span class="n">shared_times</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">shared_times</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">times_types</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">time_index</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">)</span> <span class="k">else</span> <span class="n">ts</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">specified_inputs</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">times_types</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Specified series and/or times must all have the same type of &quot;</span>
                        <span class="s2">&quot;`time_index` (i.e. all `pd.RangeIndex` or all `pd.DatetimeIndex`).&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="n">shared_times</span></div>


<div class="viewcode-block" id="get_shared_times_bounds"><a class="viewcode-back" href="../../../../../generated_api/darts.utils.data.tabularization.tabularization.html#darts.utils.data.tabularization.tabularization.get_shared_times_bounds">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">get_shared_times_bounds</span><span class="p">(</span>
    <span class="o">*</span><span class="n">series_or_times</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="kc">None</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">],</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the latest `start_time` and the earliest `end_time` among all non-`None` `series_or_times`;</span>
<span class="sd">    these are (non-tight) lower and upper `bounds` on the intersection of all these `series_or_times` respectively.</span>
<span class="sd">    If no potential overlap exists between all specified series, `None` is returned instead.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If all specified `series_or_times` are of the same frequency, then `get_shared_times_bounds`</span>
<span class="sd">    returns tight `bounds` (i.e. the earliest and latest time within the intersection of all the timeseries</span>
<span class="sd">    is returned). To see this, suppose we have three equal-frequency series with observations made at different</span>
<span class="sd">    times:</span>
<span class="sd">        Series 1: ------</span>
<span class="sd">        Series 2:    ------</span>
<span class="sd">        Series 3:  ------</span>
<span class="sd">    Here, each `-` denotes an observation at a specific time. In this example, `find_time_overlap_bounds` will</span>
<span class="sd">    return the times at `LB` and `UB`:</span>
<span class="sd">                    LB</span>
<span class="sd">        Series 1: ---|---|</span>
<span class="sd">        Series 2:    |---|---</span>
<span class="sd">        Series 3:  --|---|-</span>
<span class="sd">                         UB</span>
<span class="sd">    If the specified timeseries are *not* of the same frequency, then the returned `bounds` is potentially non-tight</span>
<span class="sd">    (i.e. `LB &lt;= intersection.start_time() &lt; intersection.end_time() &lt;= UB`, where `intersection` are the times shared</span>
<span class="sd">    by all specified timeseries)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    series_or_times</span>
<span class="sd">        The `TimeSeries` and/or `pd.Index` values to compute intersection `bounds` for; any provided `None` values</span>
<span class="sd">        are ignored.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bounds</span>
<span class="sd">        Tuple containing the latest `start_time` and earliest `end time` among all specified `timeseries`, in that</span>
<span class="sd">        order. If no potential overlap exists between the specified series, then `None` is returned instead. Similarly,</span>
<span class="sd">        if no non-`None` `series_or_times` were specified, `None` is returned.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the series and/or times in `series_or_times` don&#39;t all share the same type of `time_index`</span>
<span class="sd">        (i.e. either all `pd.DatetimeIndex` or `pd.RangeIndex`).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_times</span><span class="p">,</span> <span class="n">end_times</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">series_or_times</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">start_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">val</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">)</span> <span class="k">else</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">end_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">)</span> <span class="k">else</span> <span class="n">val</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">start_times</span><span class="p">:</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">times_types</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">start_times</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">times_types</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Specified series and/or times must all have the same type of &quot;</span>
                    <span class="s2">&quot;`time_index` (i.e. all `pd.RangeIndex` or all `pd.DatetimeIndex`).&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># If `start_times` empty, no series were specified -&gt; `bounds = (1, -1)` will</span>
        <span class="c1"># be &#39;converted&#39; to `None` in next line:</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">start_times</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">end_times</span><span class="p">))</span> <span class="k">if</span> <span class="n">start_times</span> <span class="k">else</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Specified timeseries share no overlapping periods.</span>
        <span class="k">if</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">bounds</span></div>


<div class="viewcode-block" id="strided_moving_window"><a class="viewcode-back" href="../../../../../generated_api/darts.utils.data.tabularization.tabularization.html#darts.utils.data.tabularization.tabularization.strided_moving_window">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">strided_moving_window</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">window_len</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">check_inputs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts moving window views of an `x` array along a specified `axis`, where each window is of length `window_len`</span>
<span class="sd">    and consecutive windows are separated by `stride` indices. The total number of extracted windows equals</span>
<span class="sd">    `num_windows = (x.shape[axis] - window_len)//stride + 1`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is similar to `sliding_window_view` in `np.lib.stride_tricks`, except that:</span>
<span class="sd">        1. `strided_moving_window` allows for consecutive windows to be separated by a specified `stride`,</span>
<span class="sd">        whilst `sliding_window_view` does not.</span>
<span class="sd">        2. `strided_moving_window` can only operate along a single axis, whereas `sliding_window_view` can</span>
<span class="sd">        operate along multiple axes.</span>
<span class="sd">    Additionally, unlike `sliding_window_view`, using `strided_moving_window` doesn&#39;t require `numpy &gt;= 1.20.0`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x</span>
<span class="sd">        The array from which to extract moving windows.</span>
<span class="sd">    window_len</span>
<span class="sd">        The size of the extracted moving windows.</span>
<span class="sd">    stride</span>
<span class="sd">        Optionally, the separation between consecutive windows.</span>
<span class="sd">    axis</span>
<span class="sd">        Optionally, the axis along which the moving windows should be extracted.</span>
<span class="sd">    check_inputs</span>
<span class="sd">        Optionally, specifies whether inputs should be checked for validity. Should be set</span>
<span class="sd">        to `False` if inputs have already been checked for validity (e.g. inside the `__init__`</span>
<span class="sd">        of a class), otherwise should be set to `True`. See [1]_ for further details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    windows</span>
<span class="sd">        The moving windows extracted from `x`. The extracted windows are stacked along the last axis, and the</span>
<span class="sd">        `axis` along which the windows were extracted is &#39;trimmed&#39; such that its length equals the number of</span>
<span class="sd">        extracted windows. More specifically, `windows.shape = x_trimmed_shape + (window_len,)`, where</span>
<span class="sd">        `x_trimmed_shape` equals `x.shape`, except that `x_trimmed_shape[axis] = num_windows`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `check_inputs = True` and `window_len` is not positive.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `check_inputs = True` and `stride` is not positive.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `check_inputs = True` and `axis` is greater than `x.ndim`.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `check_inputs = True` and `window_len` is larger than `x.shape[axis]`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://numpy.org/doc/stable/reference/generated/numpy.lib.stride_tricks.as_strided.html</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">check_inputs</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">stride</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`stride` must be a positive `int`.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window_len</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">window_len</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`window_len` must be a positive `int`.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`axis` must be an `int` that is less than `x.ndim`.&quot;</span><span class="p">),</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">window_len</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`window_len` must be less than or equal to x.shape[axis].&quot;</span><span class="p">),</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="n">num_windows</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">window_len</span><span class="p">)</span> <span class="o">//</span> <span class="n">stride</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">new_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">new_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_windows</span>
    <span class="n">new_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">window_len</span><span class="p">,)</span>
    <span class="n">out_strides</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">axis</span><span class="p">]]</span>
    <span class="n">out_strides</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">stride</span> <span class="o">*</span> <span class="n">out_strides</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">out_strides</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out_strides</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">as_strided</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">new_shape</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">out_strides</span><span class="p">)</span></div>


<span class="c1">#</span>
<span class="c1">#   Private Functions</span>
<span class="c1">#</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_extend_time_index</span><span class="p">(</span>
    <span class="n">time_index</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span>
    <span class="n">freq</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
    <span class="n">new_start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">new_end</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extends a `time_index` of frequency `freq` such that it now ends at time `new_end`;</span>
<span class="sd">    the fastest way to do this is actually to create a new time index from scratch.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_range_idx</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">new_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">new_start</span> <span class="o">=</span> <span class="n">time_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">new_end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">new_end</span> <span class="o">=</span> <span class="n">time_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">is_range_idx</span><span class="p">:</span>
        <span class="n">time_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">new_start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">new_end</span> <span class="o">+</span> <span class="n">freq</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">time_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">new_start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">new_end</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">time_index</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_freqs</span><span class="p">(</span><span class="o">*</span><span class="n">series</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="kc">None</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns list with the frequency of all specified (i.e. non-`None`) `series`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">freqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">freqs</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_all_equal_freq</span><span class="p">(</span><span class="o">*</span><span class="n">series</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns `True` if all specified (i.e. non-`None`) `series` have the same frequency.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">_get_freqs</span><span class="p">(</span><span class="o">*</span><span class="n">series</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_check_lags</span><span class="p">(</span>
    <span class="n">lags</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]],</span>
    <span class="n">lags_past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]],</span>
    <span class="n">lags_future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Throws `ValueError` if any `lag` values aren&#39;t negative OR if no lags have been specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_lags</span> <span class="o">=</span> <span class="p">[</span><span class="n">lags</span><span class="p">,</span> <span class="n">lags_past_covariates</span><span class="p">,</span> <span class="n">lags_future_covariates</span><span class="p">]</span>
    <span class="n">suffixes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;_past_covariates&quot;</span><span class="p">,</span> <span class="s2">&quot;_future_covariates&quot;</span><span class="p">]</span>
    <span class="n">lags_is_none</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">suffix</span><span class="p">,</span> <span class="n">lags_i</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">suffixes</span><span class="p">,</span> <span class="n">all_lags</span><span class="p">)):</span>
        <span class="n">lags_is_none</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lags_i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lags_is_none</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">is_target_or_past</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span>
            <span class="n">max_lag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">is_target_or_past</span> <span class="k">else</span> <span class="n">inf</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lags_i</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">lags_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">lags_i</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">lag</span> <span class="o">&gt;</span> <span class="n">max_lag</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lag</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="k">for</span> <span class="n">lag</span> <span class="ow">in</span> <span class="n">lags_i</span><span class="p">):</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;`lags</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">` must be a `Sequence` or `Dict` containing only `int` &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;values less than </span><span class="si">{</span><span class="n">max_lag</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>

    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">lags_is_none</span><span class="p">):</span>
        <span class="n">raise_log</span><span class="p">(</span>
            <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Must specify at least one of: `lags`, `lags_past_covariates`, `lags_future_covariates`.&quot;</span>
            <span class="p">),</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_check_series_length</span><span class="p">(</span>
    <span class="n">series</span><span class="p">:</span> <span class="n">TimeSeries</span><span class="p">,</span>
    <span class="n">lags</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">output_chunk_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">output_chunk_shift</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">is_training</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;target_series&quot;</span><span class="p">,</span> <span class="s2">&quot;past_covariates&quot;</span><span class="p">,</span> <span class="s2">&quot;future_covariates&quot;</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Throws `ValueError` if `series` is too short for specified `lags` and, when `is_training`, `output_chunk_length`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_target</span> <span class="o">=</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;target_series&quot;</span>
    <span class="n">is_label_series</span> <span class="o">=</span> <span class="n">is_training</span> <span class="ow">and</span> <span class="n">is_target</span>
    <span class="n">lags_specified</span> <span class="o">=</span> <span class="n">lags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="n">minimum_len</span><span class="p">,</span> <span class="n">minimum_len_str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">is_label_series</span><span class="p">:</span>
        <span class="n">minimum_len_str</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;-min(lags) + output_chunk_length&quot;</span>
            <span class="k">if</span> <span class="n">lags_specified</span>
            <span class="k">else</span> <span class="s2">&quot;output_chunk_length&quot;</span>
        <span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; + output_chunk_shift&quot;</span>
        <span class="n">minimum_len</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">output_chunk_length</span>
            <span class="o">+</span> <span class="n">output_chunk_shift</span>
            <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">lags</span><span class="p">)</span> <span class="k">if</span> <span class="n">lags_specified</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">lags_specified</span><span class="p">:</span>
        <span class="n">lags_name</span> <span class="o">=</span> <span class="s2">&quot;lags&quot;</span> <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;target_series&quot;</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;lags_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">minimum_len_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;-min(</span><span class="si">{</span><span class="n">lags_name</span><span class="si">}</span><span class="s2">) + max(</span><span class="si">{</span><span class="n">lags_name</span><span class="si">}</span><span class="s2">) + 1&quot;</span>
        <span class="n">minimum_len</span> <span class="o">=</span> <span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">lags</span><span class="p">)</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">lags</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">lags_specified</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">series</span><span class="o">.</span><span class="n">n_timesteps</span> <span class="o">&lt;</span> <span class="n">minimum_len</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">` must have at least `</span><span class="si">{</span><span class="n">minimum_len_str</span><span class="si">}</span><span class="s2">` = </span><span class="si">{</span><span class="n">minimum_len</span><span class="si">}</span><span class="s2"> time &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;steps; instead, it only has </span><span class="si">{</span><span class="n">series</span><span class="o">.</span><span class="n">n_timesteps</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_extract_sample_weight</span><span class="p">(</span><span class="n">sample_weight</span><span class="p">,</span> <span class="n">target_series</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extracts sample weights values from the time intersection with the target labels.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sample_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">sample_weight_vals</span> <span class="o">=</span> <span class="n">sample_weight</span><span class="o">.</span><span class="n">slice_intersect_values</span><span class="p">(</span><span class="n">target_series</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_weight_vals</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_series</span><span class="p">):</span>
        <span class="n">raise_log</span><span class="p">(</span>
            <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The `sample_weight` series must have at least the same times as the target `series`.&quot;</span>
            <span class="p">),</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">weight_n_comp</span> <span class="o">=</span> <span class="n">sample_weight_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">series_n_comp</span> <span class="o">=</span> <span class="n">target_series</span><span class="o">.</span><span class="n">n_components</span>
    <span class="k">if</span> <span class="n">weight_n_comp</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">weight_n_comp</span> <span class="o">!=</span> <span class="n">series_n_comp</span><span class="p">:</span>
        <span class="n">raise_log</span><span class="p">(</span>
            <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The number of components in `sample_weight` must either be `1` or match &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;the number of target series components `</span><span class="si">{</span><span class="n">series_n_comp</span><span class="si">}</span><span class="s2">`.&quot;</span>
            <span class="p">),</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">weight_n_comp</span> <span class="o">!=</span> <span class="n">series_n_comp</span><span class="p">:</span>
        <span class="n">sample_weight_vals</span> <span class="o">=</span> <span class="n">sample_weight_vals</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">series_n_comp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sample_weight_vals</span>
</pre></div>

              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../../../../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2020 - 2025, Unit8 SA (Apache 2.0 License).<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.0.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>