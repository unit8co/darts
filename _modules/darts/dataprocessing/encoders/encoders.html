
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>darts.dataprocessing.encoders.encoders &#8212; darts  documentation</title>
    
  <link href="../../../../_static/css/theme.css" rel="stylesheet">
  <link href="../../../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/css/blank.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    
  <link rel="preload" as="script" href="../../../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="shortcut icon" href="../../../../_static/docs-favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../../index.html">
  <img src="../../../../_static/darts-logo-trim.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../README.html">
  Home
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../quickstart/00-quickstart.html">
  Quickstart
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../userguide.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../generated_api/darts.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../examples.html">
  Examples
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/unit8co/darts" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/unit8co" rel="noopener" target="_blank" title="Twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for darts.dataprocessing.encoders.encoders</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Time Axes Encoders</span>
<span class="sd">------------------</span>

<span class="sd">Encoders can generate past and/or future covariates series by encoding the index of a TimeSeries `series`.</span>
<span class="sd">Each encoder class has methods `encode_train()`, `encode_inference()`, and `encode_train_inference()` to generate the</span>
<span class="sd">encodings for training and inference.</span>

<span class="sd">The encoders extract the index either from the target series or optional additional past/future covariates.</span>
<span class="sd">If additional covariates are supplied to `encode_train()`, `encode_inference()`, or `encode_train_inference()`,</span>
<span class="sd">the time index of those covariates are used for the encodings. This means that the input covariates must meet the same</span>
<span class="sd">model-specific requirements as without encoders.</span>

<span class="sd">There are two main types of encoder classes: `SingleEncoder` and `SequentialEncoder`.</span>

<span class="sd">*   SingleEncoder</span>
<span class="sd">        The SingleEncoder classes carry the encoder logic for past and future covariates, and training and</span>
<span class="sd">        inference datasets. They can be used as stand-alone encoders.</span>

<span class="sd">        Each SingleEncoder has a dedicated subclass for generating past or future covariates. The naming convention</span>
<span class="sd">        is `{X}{SingleEncoder}` where {X} is one of (Past, Future) and {SingleEncoder} is one of the SingleEncoder</span>
<span class="sd">        classes described in the next section. An example:</span>

<span class="sd">        .. highlight:: python</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            encoder = PastDatetimeAttributeEncoder(</span>
<span class="sd">                input_chunk_length=24,</span>
<span class="sd">                output_chunk_length=12,</span>
<span class="sd">                attribute=&#39;month&#39;</span>
<span class="sd">                tz=&#39;CET&#39;</span>
<span class="sd">            )</span>

<span class="sd">            past_covariates_train = encoder.encode_train(</span>
<span class="sd">                target=target,</span>
<span class="sd">                covariates=optional_past_covariates</span>
<span class="sd">            )</span>
<span class="sd">            past_covariates_inf = encoder.encode_inference(</span>
<span class="sd">                n=12,</span>
<span class="sd">                target=target,</span>
<span class="sd">                covariates=optional_past_covariates</span>
<span class="sd">            )</span>
<span class="sd">            # or generate encodings for train and inference together</span>
<span class="sd">            past_covariates_train_inf = encoder.encode_train_inference(</span>
<span class="sd">                n=12,</span>
<span class="sd">                target=target,</span>
<span class="sd">                covariates=optional_past_covariates</span>
<span class="sd">            )</span>

<span class="sd">*   SequentialEncoder</span>
<span class="sd">        Stores and controls multiple SingleEncoders for both past and/or future covariates all under one hood.</span>
<span class="sd">        It provides the same functionality as SingleEncoders (`encode_train()`, `encode_inference()`, and</span>
<span class="sd">        `encode_train_inference()`).</span>
<span class="sd">        It can be used both as stand-alone or as an all-in-one solution with Darts&#39; forecasting models that support</span>
<span class="sd">        covariates through optional parameter `add_encoders`:</span>

<span class="sd">        .. highlight:: python</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            model = SomeForecastingModel(..., add_encoders={...})</span>
<span class="sd">        ..</span>

<span class="sd">        If used at model creation, the SequentialEncoder will handle all past and future encoders autonomously.</span>
<span class="sd">        The requirements for model parameter `add_encoders` are described in the next section or in</span>
<span class="sd">        :meth:`SequentialEncoder &lt;darts.dataprocessing.encoders.SequentialEncoder&gt;`.</span>

<span class="sd">SingleEncoder</span>
<span class="sd">-------------</span>

<span class="sd">The SingleEncoders from {X}{SingleEncoder} are:</span>

<span class="sd">*   `DatetimeAttributeEncoder`</span>
<span class="sd">        Adds scalar pd.DatatimeIndex attribute information derived from `series.time_index`.</span>
<span class="sd">        Requires `series` to have a pd.DatetimeIndex.</span>

<span class="sd">        attribute</span>
<span class="sd">            An attribute of `pd.DatetimeIndex`: see all available attributes in</span>
<span class="sd">            https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex.</span>
<span class="sd">        tz</span>
<span class="sd">            Optionally, convert the time zone naive index to a time zone `tz` before applying the encoder.</span>
<span class="sd">*   `CyclicTemporalEncoder`</span>
<span class="sd">        Adds cyclic pd.DatetimeIndex attribute information deriveed from `series.time_index`.</span>
<span class="sd">        Adds 2 columns, corresponding to sin and cos encodings, to uniquely describe the underlying attribute.</span>
<span class="sd">        Requires `series` to have a pd.DatetimeIndex.</span>

<span class="sd">        attribute</span>
<span class="sd">            An attribute of `pd.DatetimeIndex` that follows a cyclic pattern. One of (&#39;month&#39;, &#39;day&#39;, &#39;weekday&#39;,</span>
<span class="sd">            &#39;dayofweek&#39;, &#39;day_of_week&#39;, &#39;hour&#39;, &#39;minute&#39;, &#39;second&#39;, &#39;microsecond&#39;, &#39;nanosecond&#39;, &#39;quarter&#39;,</span>
<span class="sd">            &#39;dayofyear&#39;, &#39;day_of_year&#39;, &#39;week&#39;, &#39;weekofyear&#39;, &#39;week_of_year&#39;).</span>
<span class="sd">        tz</span>
<span class="sd">            Optionally, convert the time zone naive index to a time zone `tz` before applying the encoder.</span>
<span class="sd">*   `IntegerIndexEncoder`</span>
<span class="sd">        Adds the relative index positions as integer values (positions) derived from `series` time index.</span>
<span class="sd">        `series` can either have a pd.DatetimeIndex or an integer index.</span>

<span class="sd">        attribute</span>
<span class="sd">            Currently, only &#39;relative&#39; is supported.</span>
<span class="sd">            &#39;relative&#39; will generate position values relative to the forecasting/prediction point. Values range</span>
<span class="sd">            from -inf to inf where 0 is set at the forecasting point.</span>
<span class="sd">*   `CallableIndexEncoder`</span>
<span class="sd">        Applies a user-defined callable to encode `series`&#39; index.</span>
<span class="sd">        `series` can either have a pd.DatetimeIndex or an integer index.</span>

<span class="sd">        attribute</span>
<span class="sd">            a callable/function to encode the index.</span>
<span class="sd">            For `series` with a pd.DatetimeIndex: ``lambda index: (index.year - 1950) / 50``.</span>
<span class="sd">            For `series` with an integer index: ``lambda index: index / 50``</span>

<span class="sd">SequentialEncoder</span>
<span class="sd">-----------------</span>

<span class="sd">The SequentialEncoder combines the logic of all SingleEncoders from above and has additional benefits:</span>

<span class="sd">*   use multiple encoders at once</span>
<span class="sd">*   generate multiple attribute encodings at once</span>
<span class="sd">*   generate both past and future at once</span>
<span class="sd">*   supports transformers (Scaler)</span>
<span class="sd">*   easy to use with any forecasting model that supports covariates.</span>

<span class="sd">The model parameter `add_encoders` must be a Dict following of this convention:</span>

<span class="sd">*   outer keys: `SingleEncoder` and Transformer tags:</span>

<span class="sd">    *   &#39;datetime_attribute&#39; for `DatetimeAttributeEncoder`</span>
<span class="sd">    *   &#39;cyclic&#39; for `CyclicEncoder`</span>
<span class="sd">    *   &#39;position&#39; for `IntegerIndexEncoder`</span>
<span class="sd">    *   &#39;custom&#39; for `CallableIndexEncoder`</span>
<span class="sd">    *   &#39;transformer&#39; for a transformer</span>
<span class="sd">    *   &#39;tz&#39; for applying a time zone conversion</span>
<span class="sd">*   inner keys: covariates type</span>

<span class="sd">    *   &#39;past&#39; for past covariates</span>
<span class="sd">    *   &#39;future&#39; for future covariates</span>
<span class="sd">    *   (do not specify for &#39;transformer&#39;)</span>
<span class="sd">*   inner key values:</span>

<span class="sd">    *   list of attributes for `SingleEncoder`</span>
<span class="sd">    *   transformer object for &#39;transformer&#39;</span>

<span class="sd">Below is an example that illustrates a valid `add_encoders` dict for hourly data and how it can be used with a</span>
<span class="sd">TorchForecastingModel (this is only meant to illustrate many features at once).</span>

<span class="sd">.. highlight:: python</span>
<span class="sd">.. code-block:: python</span>

<span class="sd">    add_encoders = {</span>
<span class="sd">        &#39;cyclic&#39;: {&#39;future&#39;: [&#39;month&#39;]},</span>
<span class="sd">        &#39;datetime_attribute&#39;: {&#39;future&#39;: [&#39;hour&#39;, &#39;dayofweek&#39;]},</span>
<span class="sd">        &#39;position&#39;: {&#39;past&#39;: [&#39;relative&#39;], &#39;future&#39;: [&#39;relative&#39;]},</span>
<span class="sd">        &#39;custom&#39;: {&#39;past&#39;: [lambda idx: (idx.year - 1950) / 50]},</span>
<span class="sd">        &#39;transformer&#39;: Scaler(),</span>
<span class="sd">        &#39;tz&#39;: &#39;CET&#39;,</span>
<span class="sd">    }</span>

<span class="sd">    model = SomeTorchForecastingModel(..., add_encoders=add_encoders)</span>
<span class="sd">..</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">darts</span> <span class="kn">import</span> <span class="n">TimeSeries</span><span class="p">,</span> <span class="n">concatenate</span>
<span class="kn">from</span> <span class="nn">darts.dataprocessing.encoders.encoder_base</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">CovariatesIndexGenerator</span><span class="p">,</span>
    <span class="n">Encoder</span><span class="p">,</span>
    <span class="n">FutureCovariatesIndexGenerator</span><span class="p">,</span>
    <span class="n">PastCovariatesIndexGenerator</span><span class="p">,</span>
    <span class="n">SequentialEncoderTransformer</span><span class="p">,</span>
    <span class="n">SingleEncoder</span><span class="p">,</span>
    <span class="n">SupportedIndex</span><span class="p">,</span>
    <span class="n">_EncoderMethod</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">darts.dataprocessing.transformers</span> <span class="kn">import</span> <span class="n">FittableDataTransformer</span>
<span class="kn">from</span> <span class="nn">darts.logging</span> <span class="kn">import</span> <span class="n">get_logger</span><span class="p">,</span> <span class="n">raise_if</span><span class="p">,</span> <span class="n">raise_if_not</span>
<span class="kn">from</span> <span class="nn">darts.timeseries</span> <span class="kn">import</span> <span class="n">DIMS</span>
<span class="kn">from</span> <span class="nn">darts.utils.timeseries_generation</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">datetime_attribute_timeseries</span><span class="p">,</span>
    <span class="n">generate_index</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">darts.utils.utils</span> <span class="kn">import</span> <span class="n">seq2series</span><span class="p">,</span> <span class="n">series2seq</span>

<span class="n">SupportedTimeSeries</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">ENCODER_KEYS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cyclic&quot;</span><span class="p">,</span> <span class="s2">&quot;datetime_attribute&quot;</span><span class="p">,</span> <span class="s2">&quot;position&quot;</span><span class="p">,</span> <span class="s2">&quot;custom&quot;</span><span class="p">]</span>
<span class="n">FUTURE</span> <span class="o">=</span> <span class="s2">&quot;future&quot;</span>
<span class="n">PAST</span> <span class="o">=</span> <span class="s2">&quot;past&quot;</span>
<span class="n">VALID_TIME_PARAMS</span> <span class="o">=</span> <span class="p">[</span><span class="n">FUTURE</span><span class="p">,</span> <span class="n">PAST</span><span class="p">]</span>
<span class="n">VALID_ENCODER_DTYPES</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span>

<span class="n">TZ_KEYS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;tz&quot;</span><span class="p">]</span>
<span class="n">TRANSFORMER_KEYS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;transformer&quot;</span><span class="p">]</span>
<span class="n">VALID_TRANSFORMER_DTYPES</span> <span class="o">=</span> <span class="n">FittableDataTransformer</span>
<span class="n">INTEGER_INDEX_ATTRIBUTES</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;relative&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="CyclicTemporalEncoder"><a class="viewcode-back" href="../../../../generated_api/darts.dataprocessing.encoders.encoders.html#darts.dataprocessing.encoders.encoders.CyclicTemporalEncoder">[docs]</a><span class="k">class</span> <span class="nc">CyclicTemporalEncoder</span><span class="p">(</span><span class="n">SingleEncoder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;`CyclicTemporalEncoder`: Cyclic encoding of time series datetime attributes.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">index_generator</span><span class="p">:</span> <span class="n">CovariatesIndexGenerator</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">tz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cyclic index encoding for `TimeSeries` that have a time index of type `pd.DatetimeIndex`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index_generator</span>
<span class="sd">            An instance of `CovariatesIndexGenerator` with methods `generate_train_idx()` and</span>
<span class="sd">            `generate_inference_idx()`. Used to generate the index for encoders.</span>
<span class="sd">        attribute</span>
<span class="sd">            The attribute of the underlying pd.DatetimeIndex from  for which to apply cyclic encoding.</span>
<span class="sd">            Must be an attribute of `pd.DatetimeIndex`, or `week` / `weekofyear` / `week_of_year` - e.g. &quot;month&quot;,</span>
<span class="sd">            &quot;weekday&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;. See all available attributes in</span>
<span class="sd">            https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex.</span>
<span class="sd">            For more information, check out :meth:`datetime_attribute_timeseries()</span>
<span class="sd">            &lt;darts.utils.timeseries_generation.datetime_attribute_timeseries&gt;`</span>
<span class="sd">        tz</span>
<span class="sd">            Optionally, a time zone to convert the time index to before computing the attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">index_generator</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attribute</span> <span class="o">=</span> <span class="n">attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="o">=</span> <span class="n">tz</span>

    <span class="k">def</span> <span class="nf">_encode</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">SupportedIndex</span><span class="p">,</span> <span class="n">target_end</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TimeSeries</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;applies cyclic encoding from `datetime_attribute_timeseries()` to `self.attribute` of `index`.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_encode</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">target_end</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">datetime_attribute_timeseries</span><span class="p">(</span>
            <span class="n">index</span><span class="p">,</span>
            <span class="n">attribute</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">attribute</span><span class="p">,</span>
            <span class="n">cyclic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">with_columns</span><span class="o">=</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base_component_name</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attribute</span> <span class="o">+</span> <span class="s2">&quot;_sin&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base_component_name</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attribute</span> <span class="o">+</span> <span class="s2">&quot;_cos&quot;</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">accept_transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;`CyclicTemporalEncoder` should not be transformed. Returns two elements for sine and cosine waves.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_component_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">base_component_name</span> <span class="o">+</span> <span class="s2">&quot;_cyc_&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">encoding_n_components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span></div>


<div class="viewcode-block" id="PastCyclicEncoder"><a class="viewcode-back" href="../../../../generated_api/darts.dataprocessing.encoders.encoders.html#darts.dataprocessing.encoders.encoders.PastCyclicEncoder">[docs]</a><span class="k">class</span> <span class="nc">PastCyclicEncoder</span><span class="p">(</span><span class="n">CyclicTemporalEncoder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;`CyclicEncoder`: Cyclic encoding of past covariates datetime attributes.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">input_chunk_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_chunk_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lags_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attribute</span>
<span class="sd">            The attribute of the underlying pd.DatetimeIndex from  for which to apply cyclic encoding.</span>
<span class="sd">            Must be an attribute of `pd.DatetimeIndex`, or `week` / `weekofyear` / `week_of_year` - e.g. &quot;month&quot;,</span>
<span class="sd">            &quot;weekday&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;. See all available attributes in</span>
<span class="sd">            https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex.</span>
<span class="sd">            For more information, check out :meth:`datetime_attribute_timeseries()</span>
<span class="sd">            &lt;darts.utils.timeseries_generation.datetime_attribute_timeseries&gt;`</span>
<span class="sd">        input_chunk_length</span>
<span class="sd">            Optionally, the number of input target time steps per chunk. Only required for</span>
<span class="sd">            :class:`TorchForecastingModel`, and :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to parameter `input_chunk_length` from :class:`TorchForecastingModel`, or to the absolute</span>
<span class="sd">            minimum target lag value `abs(min(lags))` for :class:`RegressionModel`.</span>
<span class="sd">        output_chunk_length</span>
<span class="sd">            Optionally, the number of output target time steps per chunk. Only required for</span>
<span class="sd">            :class:`TorchForecastingModel`, and :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to parameter `output_chunk_length` from both :class:`TorchForecastingModel`, and</span>
<span class="sd">            :class:`RegressionModel`.</span>
<span class="sd">        lags_covariates</span>
<span class="sd">            Optionally, a list of integers representing the past covariate lags. Accepts integer lag values &lt;= -1.</span>
<span class="sd">            Only required for :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to the lag values from parameter `lags_past_covariates` of :class:`RegressionModel`.</span>
<span class="sd">        tz</span>
<span class="sd">            Optionally, a time zone to convert the time index to before computing the attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">index_generator</span><span class="o">=</span><span class="n">PastCovariatesIndexGenerator</span><span class="p">(</span>
                <span class="n">input_chunk_length</span><span class="p">,</span>
                <span class="n">output_chunk_length</span><span class="p">,</span>
                <span class="n">lags_covariates</span><span class="o">=</span><span class="n">lags_covariates</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">attribute</span><span class="o">=</span><span class="n">attribute</span><span class="p">,</span>
            <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="FutureCyclicEncoder"><a class="viewcode-back" href="../../../../generated_api/darts.dataprocessing.encoders.encoders.html#darts.dataprocessing.encoders.encoders.FutureCyclicEncoder">[docs]</a><span class="k">class</span> <span class="nc">FutureCyclicEncoder</span><span class="p">(</span><span class="n">CyclicTemporalEncoder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;`CyclicEncoder`: Cyclic encoding of future covariates datetime attributes.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">input_chunk_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_chunk_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lags_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attribute</span>
<span class="sd">            The attribute of the underlying pd.DatetimeIndex from  for which to apply cyclic encoding.</span>
<span class="sd">            Must be an attribute of `pd.DatetimeIndex`, or `week` / `weekofyear` / `week_of_year` - e.g. &quot;month&quot;,</span>
<span class="sd">            &quot;weekday&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;. See all available attributes in</span>
<span class="sd">            https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex.</span>
<span class="sd">            For more information, check out :meth:`datetime_attribute_timeseries()</span>
<span class="sd">            &lt;darts.utils.timeseries_generation.datetime_attribute_timeseries&gt;`</span>
<span class="sd">        input_chunk_length</span>
<span class="sd">            Optionally, the number of input target time steps per chunk. Only required for</span>
<span class="sd">            :class:`TorchForecastingModel`, and :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to parameter `input_chunk_length` from :class:`TorchForecastingModel`, or to the absolute</span>
<span class="sd">            minimum target lag value `abs(min(lags))` for :class:`RegressionModel`.</span>
<span class="sd">        output_chunk_length</span>
<span class="sd">            Optionally, the number of output target time steps per chunk. Only required for</span>
<span class="sd">            :class:`TorchForecastingModel`, and :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to parameter `output_chunk_length` from both :class:`TorchForecastingModel`, and</span>
<span class="sd">            :class:`RegressionModel`.</span>
<span class="sd">        lags_covariates</span>
<span class="sd">            Optionally, a list of integers representing the future covariate lags. Accepts all integer values.</span>
<span class="sd">            Only required for :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to the lag values from parameter `lags_future_covariates` from :class:`RegressionModel`.</span>
<span class="sd">        tz</span>
<span class="sd">            Optionally, a time zone to convert the time index to before computing the attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">index_generator</span><span class="o">=</span><span class="n">FutureCovariatesIndexGenerator</span><span class="p">(</span>
                <span class="n">input_chunk_length</span><span class="p">,</span>
                <span class="n">output_chunk_length</span><span class="p">,</span>
                <span class="n">lags_covariates</span><span class="o">=</span><span class="n">lags_covariates</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">attribute</span><span class="o">=</span><span class="n">attribute</span><span class="p">,</span>
            <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="DatetimeAttributeEncoder"><a class="viewcode-back" href="../../../../generated_api/darts.dataprocessing.encoders.encoders.html#darts.dataprocessing.encoders.encoders.DatetimeAttributeEncoder">[docs]</a><span class="k">class</span> <span class="nc">DatetimeAttributeEncoder</span><span class="p">(</span><span class="n">SingleEncoder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;`DatetimeAttributeEncoder`: Adds pd.DatatimeIndex attribute information derived from the index as scalars.</span>
<span class="sd">    Requires the underlying TimeSeries to have a pd.DatetimeIndex</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">index_generator</span><span class="p">:</span> <span class="n">CovariatesIndexGenerator</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">tz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index_generator</span>
<span class="sd">            An instance of `CovariatesIndexGenerator` with methods `generate_train_idx()` and</span>
<span class="sd">            `generate_inference_idx()`. Used to generate the index for encoders.</span>
<span class="sd">        attribute</span>
<span class="sd">            The attribute of the underlying pd.DatetimeIndex for which to add scalar information.</span>
<span class="sd">            Must be an attribute of `pd.DatetimeIndex`, or `week` / `weekofyear` / `week_of_year` - e.g. &quot;month&quot;,</span>
<span class="sd">            &quot;weekday&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;. See all available attributes in</span>
<span class="sd">            https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex.</span>
<span class="sd">            For more information, check out :meth:`datetime_attribute_timeseries()</span>
<span class="sd">            &lt;darts.utils.timeseries_generation.datetime_attribute_timeseries&gt;`</span>
<span class="sd">        tz</span>
<span class="sd">            Optionally, a time zone to convert the time index to before computing the attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">index_generator</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attribute</span> <span class="o">=</span> <span class="n">attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="o">=</span> <span class="n">tz</span>

    <span class="k">def</span> <span class="nf">_encode</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">SupportedIndex</span><span class="p">,</span> <span class="n">target_end</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TimeSeries</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Encode `index` as a scalar.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_encode</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">target_end</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">datetime_attribute_timeseries</span><span class="p">(</span>
            <span class="n">index</span><span class="p">,</span>
            <span class="n">attribute</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">attribute</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">with_columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_component_name</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attribute</span><span class="p">,</span>
            <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">accept_transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;`DatetimeAttributeEncoder` accepts transformations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_component_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">base_component_name</span> <span class="o">+</span> <span class="s2">&quot;_dta_&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">encoding_n_components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="PastDatetimeAttributeEncoder"><a class="viewcode-back" href="../../../../generated_api/darts.dataprocessing.encoders.encoders.html#darts.dataprocessing.encoders.encoders.PastDatetimeAttributeEncoder">[docs]</a><span class="k">class</span> <span class="nc">PastDatetimeAttributeEncoder</span><span class="p">(</span><span class="n">DatetimeAttributeEncoder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Datetime attribute encoder for past covariates.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">input_chunk_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_chunk_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lags_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attribute</span>
<span class="sd">            The attribute of the underlying pd.DatetimeIndex for which to add scalar information.</span>
<span class="sd">            Must be an attribute of `pd.DatetimeIndex`, or `week` / `weekofyear` / `week_of_year` - e.g. &quot;month&quot;,</span>
<span class="sd">            &quot;weekday&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;. See all available attributes in</span>
<span class="sd">            https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex.</span>
<span class="sd">            For more information, check out :meth:`datetime_attribute_timeseries()</span>
<span class="sd">            &lt;darts.utils.timeseries_generation.datetime_attribute_timeseries&gt;`</span>
<span class="sd">        input_chunk_length</span>
<span class="sd">            Optionally, the number of input target time steps per chunk. Only required for</span>
<span class="sd">            :class:`TorchForecastingModel`, and :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to parameter `input_chunk_length` from :class:`TorchForecastingModel`, or to the absolute</span>
<span class="sd">            minimum target lag value `abs(min(lags))` for :class:`RegressionModel`.</span>
<span class="sd">        output_chunk_length</span>
<span class="sd">            Optionally, the number of output target time steps per chunk. Only required for</span>
<span class="sd">            :class:`TorchForecastingModel`, and :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to parameter `output_chunk_length` from both :class:`TorchForecastingModel`, and</span>
<span class="sd">            :class:`RegressionModel`.</span>
<span class="sd">        lags_covariates</span>
<span class="sd">            Optionally, a list of integers representing the past covariate lags. Accepts integer lag values &lt;= -1.</span>
<span class="sd">            Only required for :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to the lag values from parameter `lags_past_covariates` of :class:`RegressionModel`.</span>
<span class="sd">        tz</span>
<span class="sd">            Optionally, a time zone to convert the time index to before computing the attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">index_generator</span><span class="o">=</span><span class="n">PastCovariatesIndexGenerator</span><span class="p">(</span>
                <span class="n">input_chunk_length</span><span class="p">,</span>
                <span class="n">output_chunk_length</span><span class="p">,</span>
                <span class="n">lags_covariates</span><span class="o">=</span><span class="n">lags_covariates</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">attribute</span><span class="o">=</span><span class="n">attribute</span><span class="p">,</span>
            <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="FutureDatetimeAttributeEncoder"><a class="viewcode-back" href="../../../../generated_api/darts.dataprocessing.encoders.encoders.html#darts.dataprocessing.encoders.encoders.FutureDatetimeAttributeEncoder">[docs]</a><span class="k">class</span> <span class="nc">FutureDatetimeAttributeEncoder</span><span class="p">(</span><span class="n">DatetimeAttributeEncoder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Datetime attribute encoder for future covariates.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">input_chunk_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_chunk_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lags_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attribute</span>
<span class="sd">            The attribute of the underlying pd.DatetimeIndex for which to add scalar information.</span>
<span class="sd">            Must be an attribute of `pd.DatetimeIndex`, or `week` / `weekofyear` / `week_of_year` - e.g. &quot;month&quot;,</span>
<span class="sd">            &quot;weekday&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;. See all available attributes in</span>
<span class="sd">            https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex.</span>
<span class="sd">            For more information, check out :meth:`datetime_attribute_timeseries()</span>
<span class="sd">            &lt;darts.utils.timeseries_generation.datetime_attribute_timeseries&gt;`</span>
<span class="sd">        input_chunk_length</span>
<span class="sd">            Optionally, the number of input target time steps per chunk. Only required for</span>
<span class="sd">            :class:`TorchForecastingModel`, and :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to parameter `input_chunk_length` from :class:`TorchForecastingModel`, or to the absolute</span>
<span class="sd">            minimum target lag value `abs(min(lags))` for :class:`RegressionModel`.</span>
<span class="sd">        output_chunk_length</span>
<span class="sd">            Optionally, the number of output target time steps per chunk. Only required for</span>
<span class="sd">            :class:`TorchForecastingModel`, and :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to parameter `output_chunk_length` from both :class:`TorchForecastingModel`, and</span>
<span class="sd">            :class:`RegressionModel`.</span>
<span class="sd">        lags_covariates</span>
<span class="sd">            Optionally, a list of integers representing the future covariate lags. Accepts all integer values.</span>
<span class="sd">            Only required for :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to the lag values from parameter `lags_future_covariates` from :class:`RegressionModel`.</span>
<span class="sd">        tz</span>
<span class="sd">            Optionally, a time zone to convert the time index to before computing the attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">index_generator</span><span class="o">=</span><span class="n">FutureCovariatesIndexGenerator</span><span class="p">(</span>
                <span class="n">input_chunk_length</span><span class="p">,</span>
                <span class="n">output_chunk_length</span><span class="p">,</span>
                <span class="n">lags_covariates</span><span class="o">=</span><span class="n">lags_covariates</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">attribute</span><span class="o">=</span><span class="n">attribute</span><span class="p">,</span>
            <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="IntegerIndexEncoder"><a class="viewcode-back" href="../../../../generated_api/darts.dataprocessing.encoders.encoders.html#darts.dataprocessing.encoders.encoders.IntegerIndexEncoder">[docs]</a><span class="k">class</span> <span class="nc">IntegerIndexEncoder</span><span class="p">(</span><span class="n">SingleEncoder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;IntegerIndexEncoder: Adds integer index value (position) derived from the underlying TimeSeries&#39; time index</span>
<span class="sd">    for past and future covariates.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_generator</span><span class="p">:</span> <span class="n">CovariatesIndexGenerator</span><span class="p">,</span> <span class="n">attribute</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index_generator</span>
<span class="sd">            An instance of `CovariatesIndexGenerator` with methods `generate_train_idx()` and</span>
<span class="sd">            `generate_inference_idx()`. Used to generate the index for encoders.</span>
<span class="sd">        attribute</span>
<span class="sd">            Currently only &#39;relative&#39; is supported. The generated encoded values will range from (-inf, inf) and the</span>
<span class="sd">            target series end time will be used as a reference to evaluate the relative index positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="n">INTEGER_INDEX_ATTRIBUTES</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;Encountered invalid encoder argument `</span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2">` for encoder `position`. &quot;</span>
            <span class="sa">f</span><span class="s1">&#39;Attribute must be `&quot;relative&quot;`.&#39;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">index_generator</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">attribute</span> <span class="o">=</span> <span class="n">attribute</span>

    <span class="k">def</span> <span class="nf">_encode</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">SupportedIndex</span><span class="p">,</span> <span class="n">target_end</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TimeSeries</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds integer index value (position) to the provided `index`.</span>
<span class="sd">        For attribute==&#39;relative&#39;, the reference point/index is the prediction/forecast index of the target series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_encode</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">target_end</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

        <span class="n">idx_larger_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">target_end</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">freq</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)</span> <span class="k">else</span> <span class="n">index</span><span class="o">.</span><span class="n">step</span>
        <span class="k">if</span> <span class="n">idx_larger_end</span><span class="p">:</span>
            <span class="n">idx_larger_end</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target_end</span><span class="p">:</span>
            <span class="n">idx_diff</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">generate_index</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">target_end</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target_end</span><span class="p">:</span>
            <span class="n">idx_diff</span> <span class="o">=</span> <span class="p">(</span>
                <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">generate_index</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="n">target_end</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx_diff</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="o">.</span><span class="n">from_times_and_values</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                <span class="n">start</span><span class="o">=</span><span class="n">idx_diff</span> <span class="o">-</span> <span class="n">idx_larger_end</span><span class="p">,</span>
                <span class="n">stop</span><span class="o">=</span><span class="n">idx_diff</span> <span class="o">-</span> <span class="n">idx_larger_end</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">),</span>
            <span class="p">),</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">base_component_name</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attribute</span><span class="p">],</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">accept_transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;`IntegerIndexEncoder` accepts transformations. Note that transforming &#39;relative&#39; `IntegerIndexEncoder`</span>
<span class="sd">        will return the absolute position (in the transformed space).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># requires fitting to get the reference index from `IntegerIndexEncoder.index_generator` for inference</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_component_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">base_component_name</span> <span class="o">+</span> <span class="s2">&quot;_pos_&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">encoding_n_components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="PastIntegerIndexEncoder"><a class="viewcode-back" href="../../../../generated_api/darts.dataprocessing.encoders.encoders.html#darts.dataprocessing.encoders.encoders.PastIntegerIndexEncoder">[docs]</a><span class="k">class</span> <span class="nc">PastIntegerIndexEncoder</span><span class="p">(</span><span class="n">IntegerIndexEncoder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;`IntegerIndexEncoder`: Adds integer index value (position) for past covariates derived from the underlying</span>
<span class="sd">    TimeSeries&#39; time index.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">input_chunk_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_chunk_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lags_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attribute</span>
<span class="sd">            Currently only &#39;relative&#39; is supported. The generated encoded values will range from (-inf, inf) and the</span>
<span class="sd">            target series end time will be used as a reference to evaluate the relative index positions.</span>
<span class="sd">        input_chunk_length</span>
<span class="sd">            Optionally, the number of input target time steps per chunk. Only required for</span>
<span class="sd">            :class:`TorchForecastingModel`, and :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to parameter `input_chunk_length` from :class:`TorchForecastingModel`, or to the absolute</span>
<span class="sd">            minimum target lag value `abs(min(lags))` for :class:`RegressionModel`.</span>
<span class="sd">        output_chunk_length</span>
<span class="sd">            Optionally, the number of output target time steps per chunk. Only required for</span>
<span class="sd">            :class:`TorchForecastingModel`, and :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to parameter `output_chunk_length` from both :class:`TorchForecastingModel`, and</span>
<span class="sd">            :class:`RegressionModel`.</span>
<span class="sd">        lags_covariates</span>
<span class="sd">            Optionally, a list of integers representing the past covariate lags. Accepts integer lag values &lt;= -1.</span>
<span class="sd">            Only required for :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to the lag values from parameter `lags_past_covariates` of :class:`RegressionModel`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">index_generator</span><span class="o">=</span><span class="n">PastCovariatesIndexGenerator</span><span class="p">(</span>
                <span class="n">input_chunk_length</span><span class="p">,</span>
                <span class="n">output_chunk_length</span><span class="p">,</span>
                <span class="n">lags_covariates</span><span class="o">=</span><span class="n">lags_covariates</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">attribute</span><span class="o">=</span><span class="n">attribute</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="FutureIntegerIndexEncoder"><a class="viewcode-back" href="../../../../generated_api/darts.dataprocessing.encoders.encoders.html#darts.dataprocessing.encoders.encoders.FutureIntegerIndexEncoder">[docs]</a><span class="k">class</span> <span class="nc">FutureIntegerIndexEncoder</span><span class="p">(</span><span class="n">IntegerIndexEncoder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;`IntegerIndexEncoder`: Adds integer index value (position) for future covariates derived from the underlying</span>
<span class="sd">    TimeSeries&#39; time index.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">input_chunk_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_chunk_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lags_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attribute</span>
<span class="sd">            Currently only &#39;relative&#39; is supported. The generated encoded values will range from (-inf, inf) and the</span>
<span class="sd">            target series end time will be used as a reference to evaluate the relative index positions.</span>
<span class="sd">        input_chunk_length</span>
<span class="sd">            Optionally, the number of input target time steps per chunk. Only required for</span>
<span class="sd">            :class:`TorchForecastingModel`, and :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to parameter `input_chunk_length` from :class:`TorchForecastingModel`, or to the absolute</span>
<span class="sd">            minimum target lag value `abs(min(lags))` for :class:`RegressionModel`.</span>
<span class="sd">        output_chunk_length</span>
<span class="sd">            Optionally, the number of output target time steps per chunk. Only required for</span>
<span class="sd">            :class:`TorchForecastingModel`, and :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to parameter `output_chunk_length` from both :class:`TorchForecastingModel`, and</span>
<span class="sd">            :class:`RegressionModel`.</span>
<span class="sd">        lags_covariates</span>
<span class="sd">            Optionally, a list of integers representing the future covariate lags. Accepts all integer values.</span>
<span class="sd">            Only required for :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to the lag values from parameter `lags_future_covariates` from :class:`RegressionModel`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">index_generator</span><span class="o">=</span><span class="n">FutureCovariatesIndexGenerator</span><span class="p">(</span>
                <span class="n">input_chunk_length</span><span class="p">,</span>
                <span class="n">output_chunk_length</span><span class="p">,</span>
                <span class="n">lags_covariates</span><span class="o">=</span><span class="n">lags_covariates</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">attribute</span><span class="o">=</span><span class="n">attribute</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="CallableIndexEncoder"><a class="viewcode-back" href="../../../../generated_api/darts.dataprocessing.encoders.encoders.html#darts.dataprocessing.encoders.encoders.CallableIndexEncoder">[docs]</a><span class="k">class</span> <span class="nc">CallableIndexEncoder</span><span class="p">(</span><span class="n">SingleEncoder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;`CallableIndexEncoder`: Applies a user-defined callable to encode the underlying index for past and future</span>
<span class="sd">    covariates.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_generator</span><span class="p">:</span> <span class="n">CovariatesIndexGenerator</span><span class="p">,</span> <span class="n">attribute</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index_generator</span>
<span class="sd">            An instance of `CovariatesIndexGenerator` with methods `generate_train_idx()` and</span>
<span class="sd">            `generate_inference_idx()`. Used to generate the index for encoders.</span>
<span class="sd">        attribute</span>
<span class="sd">            A callable that takes an index `index` of type `(pd.DatetimeIndex, pd.RangeIndex)` as input</span>
<span class="sd">            and returns a np.ndarray of shape `(len(index),)`.</span>
<span class="sd">            An example for a correct `attribute` for `index` of type pd.DatetimeIndex:</span>
<span class="sd">            ``attribute = lambda index: (index.year - 1950) / 50``. And for pd.RangeIndex:</span>
<span class="sd">            ``attribute = lambda index: (index - 1950) / 50``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="nb">callable</span><span class="p">(</span><span class="n">attribute</span><span class="p">),</span>
            <span class="sa">f</span><span class="s2">&quot;Encountered invalid encoder argument `</span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2">` for encoder `callable`. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Attribute must be a callable that returns a `np.ndarray`.&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">index_generator</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">attribute</span> <span class="o">=</span> <span class="n">attribute</span>

    <span class="k">def</span> <span class="nf">_encode</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">SupportedIndex</span><span class="p">,</span> <span class="n">target_end</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TimeSeries</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the user-defined callable to encode the index&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_encode</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">target_end</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">TimeSeries</span><span class="o">.</span><span class="n">from_times_and_values</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span><span class="n">index</span><span class="p">),</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">base_component_name</span> <span class="o">+</span> <span class="s2">&quot;custom&quot;</span><span class="p">],</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">accept_transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;`CallableIndexEncoder` accepts transformations.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_component_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">base_component_name</span> <span class="o">+</span> <span class="s2">&quot;_cus_&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">encoding_n_components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="PastCallableIndexEncoder"><a class="viewcode-back" href="../../../../generated_api/darts.dataprocessing.encoders.encoders.html#darts.dataprocessing.encoders.encoders.PastCallableIndexEncoder">[docs]</a><span class="k">class</span> <span class="nc">PastCallableIndexEncoder</span><span class="p">(</span><span class="n">CallableIndexEncoder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;`IntegerIndexEncoder`: Adds integer index value (position) for past covariates derived from the underlying</span>
<span class="sd">    TimeSeries&#39; time index.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">input_chunk_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_chunk_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lags_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attribute</span>
<span class="sd">            A callable that takes an index `index` of type `(pd.DatetimeIndex, pd.RangeIndex)` as input</span>
<span class="sd">            and returns a np.ndarray of shape `(len(index),)`.</span>
<span class="sd">            An example for a correct `attribute` for `index` of type pd.DatetimeIndex:</span>
<span class="sd">            ``attribute = lambda index: (index.year - 1950) / 50``. And for pd.RangeIndex:</span>
<span class="sd">            ``attribute = lambda index: (index - 1950) / 50``</span>
<span class="sd">        input_chunk_length</span>
<span class="sd">            Optionally, the number of input target time steps per chunk. Only required for</span>
<span class="sd">            :class:`TorchForecastingModel`, and :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to parameter `input_chunk_length` from :class:`TorchForecastingModel`, or to the absolute</span>
<span class="sd">            minimum target lag value `abs(min(lags))` for :class:`RegressionModel`.</span>
<span class="sd">        output_chunk_length</span>
<span class="sd">            Optionally, the number of output target time steps per chunk. Only required for</span>
<span class="sd">            :class:`TorchForecastingModel`, and :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to parameter `output_chunk_length` from both :class:`TorchForecastingModel`, and</span>
<span class="sd">            :class:`RegressionModel`.</span>
<span class="sd">        lags_covariates</span>
<span class="sd">            Optionally, a list of integers representing the past covariate lags. Accepts integer lag values &lt;= -1.</span>
<span class="sd">            Only required for :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to the lag values from parameter `lags_past_covariates` of :class:`RegressionModel`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">index_generator</span><span class="o">=</span><span class="n">PastCovariatesIndexGenerator</span><span class="p">(</span>
                <span class="n">input_chunk_length</span><span class="p">,</span>
                <span class="n">output_chunk_length</span><span class="p">,</span>
                <span class="n">lags_covariates</span><span class="o">=</span><span class="n">lags_covariates</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">attribute</span><span class="o">=</span><span class="n">attribute</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="FutureCallableIndexEncoder"><a class="viewcode-back" href="../../../../generated_api/darts.dataprocessing.encoders.encoders.html#darts.dataprocessing.encoders.encoders.FutureCallableIndexEncoder">[docs]</a><span class="k">class</span> <span class="nc">FutureCallableIndexEncoder</span><span class="p">(</span><span class="n">CallableIndexEncoder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;`IntegerIndexEncoder`: Adds integer index value (position) for future covariates derived from the underlying</span>
<span class="sd">    TimeSeries&#39; time index.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">input_chunk_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_chunk_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lags_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attribute</span>
<span class="sd">            A callable that takes an index `index` of type `(pd.DatetimeIndex, pd.RangeIndex)` as input</span>
<span class="sd">            and returns a np.ndarray of shape `(len(index),)`.</span>
<span class="sd">            An example for a correct `attribute` for `index` of type pd.DatetimeIndex:</span>
<span class="sd">            ``attribute = lambda index: (index.year - 1950) / 50``. And for pd.RangeIndex:</span>
<span class="sd">            ``attribute = lambda index: (index - 1950) / 50``</span>
<span class="sd">        input_chunk_length</span>
<span class="sd">            Optionally, the number of input target time steps per chunk. Only required for</span>
<span class="sd">            :class:`TorchForecastingModel`, and :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to parameter `input_chunk_length` from :class:`TorchForecastingModel`, or to the absolute</span>
<span class="sd">            minimum target lag value `abs(min(lags))` for :class:`RegressionModel`.</span>
<span class="sd">        output_chunk_length</span>
<span class="sd">            Optionally, the number of output target time steps per chunk. Only required for</span>
<span class="sd">            :class:`TorchForecastingModel`, and :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to parameter `output_chunk_length` from both :class:`TorchForecastingModel`, and</span>
<span class="sd">            :class:`RegressionModel`.</span>
<span class="sd">        lags_covariates</span>
<span class="sd">            Optionally, a list of integers representing the future covariate lags. Accepts all integer values.</span>
<span class="sd">            Only required for :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to the lag values from parameter `lags_future_covariates` from :class:`RegressionModel`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">index_generator</span><span class="o">=</span><span class="n">FutureCovariatesIndexGenerator</span><span class="p">(</span>
                <span class="n">input_chunk_length</span><span class="p">,</span>
                <span class="n">output_chunk_length</span><span class="p">,</span>
                <span class="n">lags_covariates</span><span class="o">=</span><span class="n">lags_covariates</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">attribute</span><span class="o">=</span><span class="n">attribute</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SequentialEncoder"><a class="viewcode-back" href="../../../../generated_api/darts.dataprocessing.encoders.encoders.html#darts.dataprocessing.encoders.encoders.SequentialEncoder">[docs]</a><span class="k">class</span> <span class="nc">SequentialEncoder</span><span class="p">(</span><span class="n">Encoder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A `SequentialEncoder` object can store and control multiple past and future covariates encoders at once.</span>
<span class="sd">    It provides the same functionality as single encoders (`encode_train()`, `encode_inference()`,</span>
<span class="sd">    `encode_train_inference()`).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">add_encoders</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">input_chunk_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_chunk_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lags_past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lags_future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">takes_past_covariates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">takes_future_covariates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SequentialEncoder automatically creates encoder objects from parameter `add_encoders`. `add_encoders` can also</span>
<span class="sd">        be set directly in all of Darts&#39; `ForecastingModels`. This will automatically set up a</span>
<span class="sd">        :class:`SequentialEncoder` tailored to the settings of the underlying forecasting model.</span>

<span class="sd">        The `add_encoders` dict must follow this convention:</span>
<span class="sd">            `{encoder keyword: {temporal keyword: List[attributes]}, ..., transformer keyword: transformer object}`</span>
<span class="sd">        Supported encoder keywords:</span>
<span class="sd">            `&#39;cyclic&#39;` for cyclic temporal encoder. See the docs</span>
<span class="sd">            :meth:`CyclicTemporalEncoder &lt;darts.dataprocessing.encoders.CyclicTemporalEncoder&gt;`;</span>
<span class="sd">            `&#39;datetime_attribute&#39;` for adding scalar information of pd.DatetimeIndex attribute. See the docs</span>
<span class="sd">            :meth:`DatetimeAttributeEncoder &lt;darts.dataprocessing.encoders.DatetimeAttributeEncoder&gt;`</span>
<span class="sd">            `&#39;position&#39;` for integer index position encoder. See the docs</span>
<span class="sd">            :meth:`IntegerIndexEncoder &lt;darts.dataprocessing.encoders.IntegerIndexEncoder&gt;`;</span>
<span class="sd">            `&#39;custom&#39;` for encoding index with custom callables (functions). See the docs</span>
<span class="sd">            :meth:`CallableIndexEncoder &lt;darts.dataprocessing.encoders.CallableIndexEncoder&gt;`;</span>
<span class="sd">        Supported temporal keywords:</span>
<span class="sd">            &#39;past&#39; for adding encoding as past covariates</span>
<span class="sd">            &#39;future&#39; for adding encoding as future covariates</span>
<span class="sd">        Supported attributes:</span>
<span class="sd">            for attributes read the referred docs for the corresponding encoder from above</span>
<span class="sd">        Supported transformers:</span>
<span class="sd">            a transformer can be added with transformer keyword &#39;transformer&#39;. The transformer object must be an</span>
<span class="sd">            instance of Darts&#39; :meth:`FittableDataTransformer</span>
<span class="sd">            &lt;darts.dataprocessing.transformers.fittable_data_transformer.FittableDataTransformer&gt;` such as Scaler() or</span>
<span class="sd">            BoxCox(). The transformers will be fitted on the training dataset when calling calling `model.fit()`.</span>
<span class="sd">            The training, validation and inference datasets are then transformed equally.</span>
<span class="sd">        Supported time zone:</span>
<span class="sd">            Optionally, apply a time zone conversion with keyword &#39;tz&#39;. This converts the time zone-naive index to a</span>
<span class="sd">            timezone `&#39;tz&#39;` before applying the `&#39;cyclic&#39;` or `&#39;datetime_attribute&#39;` temporal encoders.</span>

<span class="sd">        An example of a valid `add_encoders` dict for hourly data:</span>

<span class="sd">            .. highlight:: python</span>
<span class="sd">            .. code-block:: python</span>

<span class="sd">                from darts.dataprocessing.transformers import Scaler</span>
<span class="sd">                add_encoders={</span>
<span class="sd">                    &#39;cyclic&#39;: {&#39;future&#39;: [&#39;month&#39;]},</span>
<span class="sd">                    &#39;datetime_attribute&#39;: {&#39;past&#39;: [&#39;hour&#39;], &#39;future&#39;: [&#39;year&#39;, &#39;dayofweek&#39;]},</span>
<span class="sd">                    &#39;position&#39;: {&#39;past&#39;: [&#39;relative&#39;], &#39;future&#39;: [&#39;relative&#39;]},</span>
<span class="sd">                    &#39;custom&#39;: {&#39;past&#39;: [lambda idx: (idx.year - 1950) / 50]},</span>
<span class="sd">                    &#39;transformer&#39;: Scaler(),</span>
<span class="sd">                    &#39;tz&#39;: &#39;CET&#39;,</span>
<span class="sd">                }</span>

<span class="sd">        Tuples of `(encoder_id, attribute)` are extracted from `add_encoders` to instantiate the `SingleEncoder`</span>
<span class="sd">        objects:</span>

<span class="sd">        * The `encoder_id` is extracted as follows:</span>
<span class="sd">            str(encoder_kw) + str(temporal_kw) -&gt; &#39;cyclic&#39; + &#39;past&#39; -&gt; `encoder_id` = &#39;cyclic_past&#39;</span>
<span class="sd">            The `encoder_id` is used to map the parameters with the corresponding `SingleEncoder` objects.</span>
<span class="sd">        * The `attribute` is extracted from the values given by values under `temporal_kw`</span>
<span class="sd">            `attribute` = &#39;month&#39;</span>
<span class="sd">            ...</span>
<span class="sd">            The `attribute` tells the `SingleEncoder` which attribute of the index to encode</span>

<span class="sd">        New encoders can be added by appending them to the mapping property `SequentialEncoder.encoder_map()`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        add_encoders</span>
<span class="sd">            A dictionary with the encoder settings.</span>
<span class="sd">        input_chunk_length</span>
<span class="sd">            Optionally, the number of input target time steps per chunk. Only required for</span>
<span class="sd">            :class:`TorchForecastingModel`, and :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to parameter `input_chunk_length` from :class:`TorchForecastingModel`, or to the absolute</span>
<span class="sd">            minimum target lag value `abs(min(lags))` for :class:`RegressionModel`.</span>
<span class="sd">        output_chunk_length</span>
<span class="sd">            Optionally, the number of output target time steps per chunk. Only required for</span>
<span class="sd">            :class:`TorchForecastingModel`, and :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to parameter `output_chunk_length` from both :class:`TorchForecastingModel`, and</span>
<span class="sd">            :class:`RegressionModel`.</span>
<span class="sd">        lags_past_covariates</span>
<span class="sd">            Optionally, a list of integers representing the past covariate lags. Accepts integer lag values &lt;= -1.</span>
<span class="sd">            Only required for :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to the lag values from parameter `lags_past_covariates` of :class:`RegressionModel`.</span>
<span class="sd">        lags_future_covariates</span>
<span class="sd">            Optionally, a list of integers representing the future covariate lags. Accepts all integer values.</span>
<span class="sd">            Only required for :class:`RegressionModel`.</span>
<span class="sd">            Corresponds to the lag values from parameter `lags_future_covariates` from :class:`RegressionModel`.</span>
<span class="sd">        takes_past_covariates</span>
<span class="sd">            Whether to encode/generate past covariates.</span>
<span class="sd">        takes_future_covariates</span>
<span class="sd">            Whether to encode/generate future covariates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">add_encoders</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_chunk_length</span> <span class="o">=</span> <span class="n">input_chunk_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span> <span class="o">=</span> <span class="n">output_chunk_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">encoding_available</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">takes_past_covariates</span> <span class="o">=</span> <span class="n">takes_past_covariates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">takes_future_covariates</span> <span class="o">=</span> <span class="n">takes_future_covariates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lags_past_covariates</span> <span class="o">=</span> <span class="n">lags_past_covariates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lags_future_covariates</span> <span class="o">=</span> <span class="n">lags_future_covariates</span>

        <span class="c1"># encoders</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_past_encoders</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SingleEncoder</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_past_components</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_future_encoders</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SingleEncoder</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_future_components</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([])</span>

        <span class="c1"># transformer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_past_transformer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SequentialEncoderTransformer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_future_transformer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SequentialEncoderTransformer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># setup encoders and transformer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_encoders</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_transformer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

<div class="viewcode-block" id="SequentialEncoder.encode_train"><a class="viewcode-back" href="../../../../generated_api/darts.dataprocessing.encoders.encoders.html#darts.dataprocessing.encoders.encoders.SequentialEncoder.encode_train">[docs]</a>    <span class="k">def</span> <span class="nf">encode_train</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">SupportedTimeSeries</span><span class="p">,</span>
        <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SupportedTimeSeries</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SupportedTimeSeries</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encode_past</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">encode_future</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns encoded index for all past and/or future covariates for training.</span>
<span class="sd">        Which covariates are generated depends on the parameters used at model creation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target</span>
<span class="sd">            The target TimeSeries used during training or passed to prediction as `series`.</span>
<span class="sd">        past_covariates</span>
<span class="sd">            Optionally, the past covariates used for training.</span>
<span class="sd">        future_covariates</span>
<span class="sd">            Optionally, the future covariates used for training.</span>
<span class="sd">        encode_past</span>
<span class="sd">            Whether to apply encoders for past covariates.</span>
<span class="sd">        encode_future</span>
<span class="sd">            Whether to apply encoders for future covariates.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[past_covariates, future_covariates]</span>
<span class="sd">            The past_covariates and/or future_covariates for training including the encodings.</span>
<span class="sd">            If input {x}_covariates is None and no {x}_encoders are given, will return `None`</span>
<span class="sd">            for the {x}_covariates.</span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        Warning</span>
<span class="sd">            If model was created with `add_encoders` and there is suspicion of lazy loading.</span>
<span class="sd">            The encodings/covariates are generated eagerly before starting training for all individual targets and</span>
<span class="sd">            loaded into memory. Depending on the size of target data, this can create memory</span>
<span class="sd">            issues. In case this applies, consider setting `add_encoders=None` at model</span>
<span class="sd">            creation and build your encodings covariates manually for lazy loading.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_called</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Fitting was called with `add_encoders` and suspicion of lazy loading. &quot;</span>
                    <span class="s2">&quot;The encodings/covariates are generated pre-train for all individual targets and &quot;</span>
                    <span class="s2">&quot;loaded into memory. Depending on the size of your data, this can create memory issues. &quot;</span>
                    <span class="s2">&quot;In case this applies, consider setting `add_encoders=None` at model creation.&quot;</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_fit_called</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_launch_encoder</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
            <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
            <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
            <span class="n">encoder_method</span><span class="o">=</span><span class="n">_EncoderMethod</span><span class="p">(</span><span class="s2">&quot;train&quot;</span><span class="p">),</span>
            <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">encode_past</span><span class="o">=</span><span class="n">encode_past</span><span class="p">,</span>
            <span class="n">encode_future</span><span class="o">=</span><span class="n">encode_future</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_called</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span></div>

<div class="viewcode-block" id="SequentialEncoder.encode_inference"><a class="viewcode-back" href="../../../../generated_api/darts.dataprocessing.encoders.encoders.html#darts.dataprocessing.encoders.encoders.SequentialEncoder.encode_inference">[docs]</a>    <span class="k">def</span> <span class="nf">encode_inference</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">SupportedTimeSeries</span><span class="p">,</span>
        <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SupportedTimeSeries</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SupportedTimeSeries</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encode_past</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">encode_future</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns encoded index for all past and/or future covariates for inference/prediction.</span>
<span class="sd">        Which covariates are generated depends on the parameters used at model creation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n</span>
<span class="sd">            The forecast horizon</span>
<span class="sd">        target</span>
<span class="sd">            The target TimeSeries used during training or passed to prediction as `series`.</span>
<span class="sd">        past_covariates</span>
<span class="sd">            Optionally, the past covariates used for training.</span>
<span class="sd">        future_covariates</span>
<span class="sd">            Optionally, the future covariates used for training.</span>
<span class="sd">        encode_past</span>
<span class="sd">            Whether to apply encoders for past covariates.</span>
<span class="sd">        encode_future</span>
<span class="sd">            Whether to apply encoders for future covariates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[past_covariates, future_covariates]</span>
<span class="sd">            The past_covariates and/or future_covariates for prediction/inference including the encodings.</span>
<span class="sd">            If input {x}_covariates is None and no {x}_encoders are given, will return `None`</span>
<span class="sd">            for the {x}_covariates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_if</span><span class="p">(</span>
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_called</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">requires_fit</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">` contains encoders or transformers which must be trained before inference. &quot;</span>
            <span class="s2">&quot;Call method `encode_train()` before `encode_inference()`.&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_launch_encoder</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
            <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
            <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
            <span class="n">encoder_method</span><span class="o">=</span><span class="n">_EncoderMethod</span><span class="p">(</span><span class="s2">&quot;inference&quot;</span><span class="p">),</span>
            <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
            <span class="n">encode_past</span><span class="o">=</span><span class="n">encode_past</span><span class="p">,</span>
            <span class="n">encode_future</span><span class="o">=</span><span class="n">encode_future</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="SequentialEncoder.encode_train_inference"><a class="viewcode-back" href="../../../../generated_api/darts.dataprocessing.encoders.encoders.html#darts.dataprocessing.encoders.encoders.SequentialEncoder.encode_train_inference">[docs]</a>    <span class="k">def</span> <span class="nf">encode_train_inference</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">SupportedTimeSeries</span><span class="p">,</span>
        <span class="n">past_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SupportedTimeSeries</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">future_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SupportedTimeSeries</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encode_past</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">encode_future</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]],</span> <span class="n">Union</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns encoded index for all past and/or future covariates for training and inference/prediction.</span>
<span class="sd">        Which covariates are generated depends on the parameters used at model creation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n</span>
<span class="sd">            The forecast horizon</span>
<span class="sd">        target</span>
<span class="sd">            The target TimeSeries used for training and prediction.</span>
<span class="sd">        past_covariates</span>
<span class="sd">            Optionally, the past covariates used for training and prediction.</span>
<span class="sd">        future_covariates</span>
<span class="sd">            Optionally, the future covariates used for training and prediction.</span>
<span class="sd">        encode_past</span>
<span class="sd">            Whether to apply encoders for past covariates.</span>
<span class="sd">        encode_future</span>
<span class="sd">            Whether to apply encoders for future covariates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[past_covariates, future_covariates]</span>
<span class="sd">            The past_covariates and/or future_covariates for prediction/inference including the encodings.</span>
<span class="sd">            If input {x}_covariates is None and no {x}_encoders are given, will return `None`</span>
<span class="sd">            for the {x}_covariates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_called</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Fitting was called with `add_encoders` and suspicion of lazy loading. &quot;</span>
                    <span class="s2">&quot;The encodings/covariates are generated pre-train for all individual targets and &quot;</span>
                    <span class="s2">&quot;loaded into memory. Depending on the size of your data, this can create memory issues. &quot;</span>
                    <span class="s2">&quot;In case this applies, consider setting `add_encoders=None` at model creation.&quot;</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_fit_called</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_launch_encoder</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
            <span class="n">past_covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
            <span class="n">future_covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
            <span class="n">encoder_method</span><span class="o">=</span><span class="n">_EncoderMethod</span><span class="p">(</span><span class="s2">&quot;train_inference&quot;</span><span class="p">),</span>
            <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
            <span class="n">encode_past</span><span class="o">=</span><span class="n">encode_past</span><span class="p">,</span>
            <span class="n">encode_future</span><span class="o">=</span><span class="n">encode_future</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_called</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span></div>

    <span class="k">def</span> <span class="nf">_launch_encoder</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
        <span class="n">past_covariates</span><span class="p">:</span> <span class="n">SupportedTimeSeries</span><span class="p">,</span>
        <span class="n">future_covariates</span><span class="p">:</span> <span class="n">SupportedTimeSeries</span><span class="p">,</span>
        <span class="n">encoder_method</span><span class="p">:</span> <span class="n">_EncoderMethod</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encode_past</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">encode_future</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Launches the encode sequence for past covariates and future covariates for either training,</span>
<span class="sd">        inference/prediction or training and inference/prediction depending on `encoder_method`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding_available</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span>

        <span class="c1"># guarantee that all inputs are either a sequence of TimeSeries or None</span>
        <span class="n">single_series</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">)</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">series2seq</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">past_covariates</span> <span class="o">=</span> <span class="n">series2seq</span><span class="p">(</span><span class="n">past_covariates</span><span class="p">)</span>
        <span class="n">future_covariates</span> <span class="o">=</span> <span class="n">series2seq</span><span class="p">(</span><span class="n">future_covariates</span><span class="p">)</span>

        <span class="c1"># generate past covariates encodings</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">past_encoders</span> <span class="ow">and</span> <span class="n">encode_past</span><span class="p">:</span>
            <span class="n">past_covariates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_sequence</span><span class="p">(</span>
                <span class="n">encoders</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">past_encoders</span><span class="p">,</span>
                <span class="n">transformer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">past_transformer</span><span class="p">,</span>
                <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                <span class="n">covariates</span><span class="o">=</span><span class="n">past_covariates</span><span class="p">,</span>
                <span class="n">covariates_type</span><span class="o">=</span><span class="n">PAST</span><span class="p">,</span>
                <span class="n">encoder_method</span><span class="o">=</span><span class="n">encoder_method</span><span class="p">,</span>
                <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># generate future covariates encodings</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">future_encoders</span> <span class="ow">and</span> <span class="n">encode_future</span><span class="p">:</span>
            <span class="n">future_covariates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_sequence</span><span class="p">(</span>
                <span class="n">encoders</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">future_encoders</span><span class="p">,</span>
                <span class="n">transformer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">future_transformer</span><span class="p">,</span>
                <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                <span class="n">covariates</span><span class="o">=</span><span class="n">future_covariates</span><span class="p">,</span>
                <span class="n">covariates_type</span><span class="o">=</span><span class="n">FUTURE</span><span class="p">,</span>
                <span class="n">encoder_method</span><span class="o">=</span><span class="n">encoder_method</span><span class="p">,</span>
                <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># convert covariates back to single series if single target was used as input</span>
        <span class="k">if</span> <span class="n">single_series</span><span class="p">:</span>
            <span class="n">past_covariates</span> <span class="o">=</span> <span class="n">seq2series</span><span class="p">(</span><span class="n">past_covariates</span><span class="p">)</span>
            <span class="n">future_covariates</span> <span class="o">=</span> <span class="n">seq2series</span><span class="p">(</span><span class="n">future_covariates</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">past_covariates</span><span class="p">,</span> <span class="n">future_covariates</span>

    <span class="k">def</span> <span class="nf">_encode_sequence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">encoders</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">SingleEncoder</span><span class="p">],</span>
        <span class="n">transformer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SequentialEncoderTransformer</span><span class="p">],</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
        <span class="n">covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SupportedTimeSeries</span><span class="p">],</span>
        <span class="n">covariates_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">encoder_method</span><span class="p">:</span> <span class="n">_EncoderMethod</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sequentially encodes the index of all input target/covariates TimeSeries with the corresponding</span>
<span class="sd">        `encoder_method`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">encode_method</span> <span class="o">=</span> <span class="n">encoder_method</span><span class="o">.</span><span class="n">method</span>

        <span class="n">encoded_sequence</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">covariates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">covariates</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">covariates</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[</span><span class="n">covariates</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">covariates</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">)</span> <span class="k">else</span> <span class="n">covariates</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">ts</span><span class="p">,</span> <span class="n">covs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">covariates</span><span class="p">):</span>
            <span class="c1"># drop encoder components if they are in input covariates</span>
            <span class="n">covs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drop_encoded_components</span><span class="p">(</span>
                <span class="n">covariates</span><span class="o">=</span><span class="n">covs</span><span class="p">,</span>
                <span class="n">components</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">covariates_type</span><span class="si">}</span><span class="s2">_components&quot;</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">encoded</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">enc</span><span class="p">,</span> <span class="n">encode_method</span><span class="p">)(</span>
                        <span class="n">target</span><span class="o">=</span><span class="n">ts</span><span class="p">,</span> <span class="n">covariates</span><span class="o">=</span><span class="n">covs</span><span class="p">,</span> <span class="n">merge_covariates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">enc</span> <span class="ow">in</span> <span class="n">encoders</span>
                <span class="p">],</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">encoded_sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_merge_covariates</span><span class="p">(</span><span class="n">encoded</span><span class="o">=</span><span class="n">encoded</span><span class="p">,</span> <span class="n">covariates</span><span class="o">=</span><span class="n">covs</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">transformer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">encoded_sequence</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">encoded_sequence</span><span class="p">)</span>

        <span class="c1"># store encoded past/future component names if they were not saved before</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">covariates_type</span><span class="si">}</span><span class="s2">_components&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">components</span> <span class="o">=</span> <span class="n">encoded_sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">components</span>
            <span class="k">if</span> <span class="n">covariates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">covariates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">components</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="o">~</span><span class="n">components</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">covariates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">components</span><span class="p">)]</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">covariates_type</span><span class="si">}</span><span class="s2">_components&quot;</span><span class="p">,</span> <span class="n">components</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">encoded_sequence</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">past_encoders</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">SingleEncoder</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the past covariates encoders&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_past_encoders</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">future_encoders</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">SingleEncoder</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the future covariates encoders&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_future_encoders</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">encoders</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">SingleEncoder</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">SingleEncoder</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a tuple of (past covariates encoders, future covariates encoders)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">past_encoders</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">future_encoders</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">past_components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the past covariates component names generated by `SequentialEncoder.past_encoders`.</span>
<span class="sd">        Only available after calling `SequentialEncoder.encode_train()`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_past_components</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">future_components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the future covariates component names generated by `SequentialEncoder.future_encoders`.</span>
<span class="sd">        Only available after calling `SequentialEncoder.encode_train()`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_future_components</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the covariates component names generated by `SequentialEncoder.past_encoders` and</span>
<span class="sd">        `SequentialEncoder.future_encoders`. A tuple of (past encoded components, future encoded components).</span>
<span class="sd">        Only available after calling `SequentialEncoder.encode_train()`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">past_components</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">future_components</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">encoding_n_components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of components generated by `SequentialEncoder.past_encoders` and</span>
<span class="sd">        `SequentialEncoder.future_encoders`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># by default, _[past/future]_encoders are empty lists</span>
        <span class="n">past_enc_n_compoments</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="n">past_enc</span><span class="o">.</span><span class="n">encoding_n_components</span> <span class="k">for</span> <span class="n">past_enc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">past_encoders</span>
        <span class="p">)</span>
        <span class="n">future_enc_n_compoments</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="n">future_enc</span><span class="o">.</span><span class="n">encoding_n_components</span> <span class="k">for</span> <span class="n">future_enc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">future_encoders</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">past_enc_n_compoments</span><span class="p">,</span> <span class="n">future_enc_n_compoments</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">past_transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SequentialEncoderTransformer</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the past transformer object&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_past_transformer</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">future_transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SequentialEncoderTransformer</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the future transformer object&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_future_transformer</span>

<div class="viewcode-block" id="SequentialEncoder.transformers"><a class="viewcode-back" href="../../../../generated_api/darts.dataprocessing.encoders.encoders.html#darts.dataprocessing.encoders.encoders.SequentialEncoder.transformers">[docs]</a>    <span class="k">def</span> <span class="nf">transformers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">SequentialEncoderTransformer</span><span class="p">,</span> <span class="n">SequentialEncoderTransformer</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a tuple of (past transformer, future transformer).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">past_transformer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">future_transformer</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">encoder_map</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mapping between encoder identifier string (from parameters at model creations) and the corresponding</span>
<span class="sd">        future or past covariates encoder&quot;&quot;&quot;</span>
        <span class="n">mapper</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;cyclic_past&quot;</span><span class="p">:</span> <span class="n">PastCyclicEncoder</span><span class="p">,</span>
            <span class="s2">&quot;cyclic_future&quot;</span><span class="p">:</span> <span class="n">FutureCyclicEncoder</span><span class="p">,</span>
            <span class="s2">&quot;datetime_attribute_past&quot;</span><span class="p">:</span> <span class="n">PastDatetimeAttributeEncoder</span><span class="p">,</span>
            <span class="s2">&quot;datetime_attribute_future&quot;</span><span class="p">:</span> <span class="n">FutureDatetimeAttributeEncoder</span><span class="p">,</span>
            <span class="s2">&quot;position_past&quot;</span><span class="p">:</span> <span class="n">PastIntegerIndexEncoder</span><span class="p">,</span>
            <span class="s2">&quot;position_future&quot;</span><span class="p">:</span> <span class="n">FutureIntegerIndexEncoder</span><span class="p">,</span>
            <span class="s2">&quot;custom_past&quot;</span><span class="p">:</span> <span class="n">PastCallableIndexEncoder</span><span class="p">,</span>
            <span class="s2">&quot;custom_future&quot;</span><span class="p">:</span> <span class="n">FutureCallableIndexEncoder</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">mapper</span>

    <span class="k">def</span> <span class="nf">_setup_encoders</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets up/Initializes all past and future encoders and an optional transformer from `add_encoder` parameter</span>
<span class="sd">        used at model creation.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params</span>
<span class="sd">            Dict from parameter `add_encoders` (kwargs) used at model creation. Relevant parameters are:</span>
<span class="sd">            * params={&#39;cyclic&#39;: {&#39;past&#39;: [&#39;month&#39;, &#39;dayofweek&#39;, ...], &#39;future&#39;: [same as for &#39;past&#39;]}}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">past_encoders</span><span class="p">,</span> <span class="n">future_encoders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_input_encoders</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_timezone</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">past_encoders</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">future_encoders</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_past_encoders</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encoder_map</span><span class="p">[</span><span class="n">enc_id</span><span class="p">](</span>
                <span class="n">attribute</span><span class="o">=</span><span class="n">attr</span><span class="p">,</span>
                <span class="n">input_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_chunk_length</span><span class="p">,</span>
                <span class="n">output_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span><span class="p">,</span>
                <span class="n">lags_covariates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lags_past_covariates</span><span class="p">,</span>
                <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">enc_id</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">past_encoders</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_future_encoders</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encoder_map</span><span class="p">[</span><span class="n">enc_id</span><span class="p">](</span>
                <span class="n">attribute</span><span class="o">=</span><span class="n">attr</span><span class="p">,</span>
                <span class="n">input_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_chunk_length</span><span class="p">,</span>
                <span class="n">output_chunk_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_chunk_length</span><span class="p">,</span>
                <span class="n">lags_covariates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lags_future_covariates</span><span class="p">,</span>
                <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">enc_id</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">future_encoders</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">encoding_available</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_setup_transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets up/Initializes an optional transformer from `add_encoder` parameter used at model creation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params</span>
<span class="sd">            Dict from parameter `add_encoders` (kwargs) used at model creation. Relevant parameters are:</span>
<span class="sd">            * params={..., &#39;transformer&#39;: Scaler()}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span>
            <span class="n">transformer</span><span class="p">,</span>
            <span class="n">transform_past_mask</span><span class="p">,</span>
            <span class="n">transform_future_mask</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_input_transformer</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transform_past_mask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_past_transformer</span> <span class="o">=</span> <span class="n">SequentialEncoderTransformer</span><span class="p">(</span>
                <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">transformer</span><span class="p">),</span> <span class="n">transform_past_mask</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">transform_future_mask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_future_transformer</span> <span class="o">=</span> <span class="n">SequentialEncoderTransformer</span><span class="p">(</span>
                <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">transformer</span><span class="p">),</span> <span class="n">transform_future_mask</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_input_encoders</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">List</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Processes input and returns two lists of tuples `(encoder_id, attribute)` from relevant encoder</span>
<span class="sd">        parameters at model creation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params</span>
<span class="sd">            The `add_encoders` dict used at model creation. Must follow this convention:</span>
<span class="sd">                `{encoder keyword: {temporal keyword: List[attributes]}}`</span>

<span class="sd">            Tuples of `(encoder_id, attribute)` are extracted from `add_encoders` to instantiate the `SingleEncoder`</span>
<span class="sd">            objects:</span>

<span class="sd">            * The `encoder_id` is extracted as follows:</span>
<span class="sd">                str(encoder_kw) + str(temporal_kw) -&gt; &#39;cyclic&#39; + &#39;past&#39; -&gt; `encoder_id` = &#39;cyclic_past&#39;</span>
<span class="sd">                The `encoder_id` is used to map the parameters with the corresponding `SingleEncoder` objects.</span>
<span class="sd">            * The `attribute` is extracted from the values given by values under `temporal_kw`</span>
<span class="sd">                `attribute` = &#39;month&#39;</span>
<span class="sd">                ...</span>
<span class="sd">                The `attribute` tells the `SingleEncoder` which attribute of the index to encode</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            1) if the outermost key is other than (`past`, `future`)</span>
<span class="sd">            2) if the innermost values are other than type `str` or `Sequence`</span>
<span class="sd">            3) if any of entry in the innermost values is a lambda function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="c1"># check input for invalid encoder types</span>
        <span class="n">invalid_encoders</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">enc</span>
            <span class="k">for</span> <span class="n">enc</span> <span class="ow">in</span> <span class="n">params</span>
            <span class="k">if</span> <span class="n">enc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ENCODER_KEYS</span> <span class="o">+</span> <span class="n">TZ_KEYS</span> <span class="o">+</span> <span class="n">TRANSFORMER_KEYS</span>
        <span class="p">]</span>
        <span class="n">raise_if</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">invalid_encoders</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;Encountered invalid encoder types `</span><span class="si">{</span><span class="n">invalid_encoders</span><span class="si">}</span><span class="s2">` in `add_encoders` parameter at model &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;creation. Supported encoder types are: `</span><span class="si">{</span><span class="n">ENCODER_KEYS</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">TRANSFORMER_KEYS</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">encoders</span> <span class="o">=</span> <span class="p">{</span><span class="n">enc</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="n">enc</span><span class="p">]</span> <span class="k">for</span> <span class="n">enc</span> <span class="ow">in</span> <span class="n">ENCODER_KEYS</span> <span class="k">if</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">enc</span><span class="p">,</span> <span class="kc">None</span><span class="p">)}</span>

        <span class="c1"># check input for invalid temporal types</span>
        <span class="n">invalid_time_params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">encoder</span><span class="p">,</span> <span class="n">t_types</span> <span class="ow">in</span> <span class="n">encoders</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">invalid_time_params</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">t_type</span> <span class="k">for</span> <span class="n">t_type</span> <span class="ow">in</span> <span class="n">t_types</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">t_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">VALID_TIME_PARAMS</span>
            <span class="p">]</span>

        <span class="n">raise_if</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">invalid_time_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;Encountered invalid temporal types `</span><span class="si">{</span><span class="n">invalid_time_params</span><span class="si">}</span><span class="s2">` in `add_encoders` parameter at model &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;creation. Supported temporal types are: `</span><span class="si">{</span><span class="n">VALID_TIME_PARAMS</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># check that encoders are not lambda functions (not pickable)</span>
        <span class="n">lambda_func_encoders</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># convert into tuples of (encoder string identifier, encoder attribute)</span>
        <span class="n">past_encoders</span><span class="p">,</span> <span class="n">future_encoders</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">enc</span><span class="p">,</span> <span class="n">enc_params</span> <span class="ow">in</span> <span class="n">encoders</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">enc_time</span><span class="p">,</span> <span class="n">enc_attr</span> <span class="ow">in</span> <span class="n">enc_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">raise_if_not</span><span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">enc_attr</span><span class="p">,</span> <span class="n">VALID_ENCODER_DTYPES</span><span class="p">),</span>
                    <span class="sa">f</span><span class="s2">&quot;Encountered value `</span><span class="si">{</span><span class="n">enc_attr</span><span class="si">}</span><span class="s2">` of invalid type `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">enc_attr</span><span class="p">)</span><span class="si">}</span><span class="s2">` for encoder &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">enc</span><span class="si">}</span><span class="s2">` in `add_encoders` at model creation. Supported data types are: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">VALID_ENCODER_DTYPES</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">,</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">enc_attr</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">enc_attr</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">enc_attr</span>
                <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
                    <span class="n">encoder_id</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">enc</span><span class="p">,</span> <span class="n">enc_time</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">enc_time</span> <span class="o">==</span> <span class="n">PAST</span><span class="p">:</span>
                        <span class="n">past_encoders</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">encoder_id</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">future_encoders</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">encoder_id</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">Callable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attr</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;&lt;lambda&gt;&quot;</span><span class="p">:</span>
                        <span class="n">lambda_func_encoders</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">enc</span><span class="p">)</span>

        <span class="n">raise_if</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">lambda_func_encoders</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;Encountered lambda function in the following `add_encoders` entries : </span><span class="si">{</span><span class="n">lambda_func_encoders</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;at model creation. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;In order to prevent issues when saving the model, these encoders must be converted to &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;named functions.&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">temp_enc</span><span class="p">,</span> <span class="n">takes_temp</span><span class="p">,</span> <span class="n">temp</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">past_encoders</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">takes_past_covariates</span><span class="p">,</span> <span class="s2">&quot;past&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="n">future_encoders</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">takes_future_covariates</span><span class="p">,</span> <span class="s2">&quot;future&quot;</span><span class="p">),</span>
        <span class="p">]:</span>
            <span class="k">if</span> <span class="n">temp_enc</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">takes_temp</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Specified </span><span class="si">{</span><span class="n">temp</span><span class="si">}</span><span class="s2"> encoders in `add_encoders` at model creation but model does not &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;accept </span><span class="si">{</span><span class="n">temp</span><span class="si">}</span><span class="s2"> covariates. </span><span class="si">{</span><span class="n">temp</span><span class="si">}</span><span class="s2"> encoders will be ignored.&quot;</span>
                <span class="p">)</span>

        <span class="n">past_encoders</span> <span class="o">=</span> <span class="n">past_encoders</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">takes_past_covariates</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="n">future_encoders</span> <span class="o">=</span> <span class="n">future_encoders</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">takes_future_covariates</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">past_encoders</span><span class="p">,</span> <span class="n">future_encoders</span>

    <span class="k">def</span> <span class="nf">_process_input_transformer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">FittableDataTransformer</span><span class="p">],</span> <span class="n">List</span><span class="p">,</span> <span class="n">List</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Processes input params used at model creation and returns tuple of one transformer object and two masks</span>
<span class="sd">        that specify which past / future encoders accept being transformed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params</span>
<span class="sd">            Dict from parameter `add_encoders` (kwargs) used at model creation. Relevant parameters are:</span>
<span class="sd">            * params={&#39;transformer&#39;: Scaler()}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="n">transformer</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">TRANSFORMER_KEYS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transformer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">transformer</span><span class="p">,</span> <span class="n">VALID_TRANSFORMER_DTYPES</span><span class="p">),</span>
            <span class="sa">f</span><span class="s2">&quot;Encountered `</span><span class="si">{</span><span class="n">TRANSFORMER_KEYS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">` of invalid type `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">transformer</span><span class="p">)</span><span class="si">}</span><span class="s2">` &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;in `add_encoders` at model creation. Transformer must be an instance of &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">VALID_TRANSFORMER_DTYPES</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">transform_past_mask</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">transform</span>
            <span class="k">for</span> <span class="n">enc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">past_encoders</span>
            <span class="k">for</span> <span class="n">transform</span> <span class="ow">in</span> <span class="n">enc</span><span class="o">.</span><span class="n">accept_transformer</span>
        <span class="p">]</span>
        <span class="n">transform_future_mask</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">transform</span>
            <span class="k">for</span> <span class="n">enc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">future_encoders</span>
            <span class="k">for</span> <span class="n">transform</span> <span class="ow">in</span> <span class="n">enc</span><span class="o">.</span><span class="n">accept_transformer</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">transformer</span><span class="p">,</span> <span class="n">transform_past_mask</span><span class="p">,</span> <span class="n">transform_future_mask</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_process_timezone</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Processes input params used at model creation for time zone specification, and returns the time zone.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params</span>
<span class="sd">            Dict from parameter `add_encoders` (kwargs) used at model creation. Relevant parameters are:</span>
<span class="sd">            * params={&#39;tz&#39;: &#39;CET&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">TZ_KEYS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">[</span><span class="n">enc</span><span class="o">.</span><span class="n">requires_fit</span> <span class="k">for</span> <span class="n">cov_enc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoders</span> <span class="k">for</span> <span class="n">enc</span> <span class="ow">in</span> <span class="n">cov_enc</span><span class="p">]</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">([</span><span class="n">tf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformers</span><span class="p">()])</span></div>
</pre></div>

              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../../../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2020 - 2023, Unit8 SA (Apache 2.0 License).<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.3.2.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>