
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>darts.timeseries &#8212; darts  documentation</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet">
  <link href="../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/blank.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <link rel="shortcut icon" href="../../_static/docs-favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../index.html">
  <img src="../../_static/darts-logo-trim.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../README.html">
  Home
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../quickstart/00-quickstart.html">
  Quickstart
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../userguide.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../generated_api/darts.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../examples.html">
  Examples
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../release_notes/RELEASE_NOTES.html">
  Release Notes
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/unit8co/darts" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/unit8co" rel="noopener" target="_blank" title="Twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for darts.timeseries</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Timeseries</span>
<span class="sd">----------</span>

<span class="sd">``TimeSeries`` is `Darts` container for storing and handling time series data. It supports univariate or</span>
<span class="sd">multivariate time series that can be deterministic or stochastic.</span>

<span class="sd">The values are stored in an array of shape `(times, components, samples)`, where `times` are the number of</span>
<span class="sd">time steps, `components` are the number of columns, and `samples` are the number of samples in the series.</span>

<span class="sd">**Definitions:**</span>

<span class="sd">- A series with `components = 1` is **univariate**, and a series with `components &gt; 1` is **multivariate**.</span>
<span class="sd">- A series with `samples = 1` is **deterministic** and a series with `samples &gt; 1` is **stochastic** (or</span>
<span class="sd">  **probabilistic**).</span>

<span class="sd">Each series also stores a `time_index`, which contains either datetimes (:class:`pandas.DateTimeIndex`) or integer</span>
<span class="sd">indices (:class:`pandas.RangeIndex`).</span>

<span class="sd">Optionally, ``TimeSeries`` can store static covariates, a hierarchy, and / or metadata.</span>

<span class="sd">- **Static covariates** are time-invariant external data / information about the series and can be used by some models</span>
<span class="sd">  to help improve predictions. Find more info on covariates `here</span>
<span class="sd">  &lt;https://unit8co.github.io/darts/userguide/covariates.html&gt;`_.</span>
<span class="sd">- A **hierarchy** describes the hierarchical structure of the components which can be used to reconcile forecasts. For</span>
<span class="sd">  more info on hierarchical reconciliation `here</span>
<span class="sd">  &lt;https://unit8co.github.io/darts/examples/16-hierarchical-reconciliation.html&gt;`_.</span>
<span class="sd">- **Metadata** can be used to store any additional information about the series which will not be used by any model.</span>

<span class="sd">``TimeSeries`` **are guaranteed to:**</span>

<span class="sd">- Have a strictly monotonically increasing time index with a well-defined frequency (without holes / missing dates).</span>
<span class="sd">  For more info on available ``DateTimeIndex`` frequencies, see `date offset aliases</span>
<span class="sd">  &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_. For integer-indexed</span>
<span class="sd">  series the frequency corresponds to the constant step size between consecutive indices.</span>
<span class="sd">- Contain numeric data types only</span>
<span class="sd">- Have unique component / column names</span>
<span class="sd">- Have static covariates consistent with their components (global or component-specific), or no static covariates</span>
<span class="sd">- Have a hierarchy consistent with their components, or no hierarchy</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inspect</span><span class="w"> </span><span class="kn">import</span> <span class="n">signature</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">io</span><span class="w"> </span><span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">types</span><span class="w"> </span><span class="kn">import</span> <span class="n">ModuleType</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.axes</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">narwhals</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nw</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">narwhals.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">IntoDataFrame</span><span class="p">,</span> <span class="n">IntoSeries</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">narwhals.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">Implementation</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pandas.tseries.frequencies</span><span class="w"> </span><span class="kn">import</span> <span class="n">to_offset</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">kurtosis</span><span class="p">,</span> <span class="n">skew</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">darts.logging</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_logger</span><span class="p">,</span> <span class="n">raise_log</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">darts.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">_build_tqdm_iterator</span><span class="p">,</span> <span class="n">_parallel_apply</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">darts.utils.utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">SUPPORTED_RESAMPLE_METHODS</span><span class="p">,</span>
    <span class="n">dataframe_col_to_time_index</span><span class="p">,</span>
    <span class="n">expand_arr</span><span class="p">,</span>
    <span class="n">generate_index</span><span class="p">,</span>
    <span class="n">n_steps_between</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Self</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">typing_extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Self</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># dimension names in the array</span>
<span class="c1"># the &quot;time&quot; one can be different, if it has a name in the underlying Series/DataFrame.</span>
<span class="n">DIMS</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;component&quot;</span><span class="p">,</span> <span class="s2">&quot;sample&quot;</span><span class="p">)</span>
<span class="n">TIME_AX</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">COMP_AX</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">SMPL_AX</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">AXES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">TIME_AX</span><span class="p">,</span> <span class="s2">&quot;component&quot;</span><span class="p">:</span> <span class="n">COMP_AX</span><span class="p">,</span> <span class="s2">&quot;sample&quot;</span><span class="p">:</span> <span class="n">SMPL_AX</span><span class="p">}</span>

<span class="n">VALID_INDEX_TYPES</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">)</span>
<span class="n">STATIC_COV_TAG</span> <span class="o">=</span> <span class="s2">&quot;static_covariates&quot;</span>
<span class="n">DEFAULT_GLOBAL_STATIC_COV_NAME</span> <span class="o">=</span> <span class="s2">&quot;global_components&quot;</span>
<span class="n">HIERARCHY_TAG</span> <span class="o">=</span> <span class="s2">&quot;hierarchy&quot;</span>
<span class="n">METADATA_TAG</span> <span class="o">=</span> <span class="s2">&quot;metadata&quot;</span>


<div class="viewcode-block" id="TimeSeries"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">TimeSeries</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">times</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">],</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">components</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">_typing</span><span class="o">.</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fillna_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">static_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hierarchy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a ``TimeSeries`` from a time index `times` and values `values`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.from_dataframe : Create from a `DataFrame` (:class:`pandas.DataFrame`, :class:`polars.DataFrame`,</span>
<span class="sd">            and other backends).</span>
<span class="sd">        TimeSeries.from_group_dataframe : Create multiple TimeSeries by groups from a :class:`pandas.DataFrame`.</span>
<span class="sd">        TimeSeries.from_series : Create from a `Series` (:class:`pandas.Series`, :class:`polars.Series`, and other</span>
<span class="sd">            backends).</span>
<span class="sd">        TimeSeries.from_values : Create from a :class:`numpy.ndarray`.</span>
<span class="sd">        TimeSeries.from_times_and_values : Create from a time index and a :class:`numpy.ndarray`.</span>
<span class="sd">        TimeSeries.from_csv : Create from a CSV file.</span>
<span class="sd">        TimeSeries.from_json : Create from a JSON file.</span>
<span class="sd">        TimeSeries.from_xarray : Create from an :class:`xarray.DataArray`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times</span>
<span class="sd">            A pandas DateTimeIndex, RangeIndex, or Index that can be converted to a RangeIndex representing the time</span>
<span class="sd">            axis for the time series. It is better if the index has no holes; alternatively setting</span>
<span class="sd">            `fill_missing_dates` can in some cases solve these issues (filling holes with NaN, or with the provided</span>
<span class="sd">            `fillna_value` numeric value, if any).</span>
<span class="sd">        values</span>
<span class="sd">            A Numpy array of values for the TimeSeries. Both 2-dimensional arrays, for deterministic series,</span>
<span class="sd">            and 3-dimensional arrays, for probabilistic series, are accepted. In the former case the dimensions</span>
<span class="sd">            should be (time, component), and in the latter case (time, component, sample).</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates (or indices in case of integer index)</span>
<span class="sd">            with NaN values. This requires either a provided `freq` or the possibility to infer the frequency from the</span>
<span class="sd">            provided timestamps. See :meth:`_fill_missing_dates() &lt;TimeSeries._fill_missing_dates&gt;` for more info.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string or integer representing the frequency of the underlying index. This is useful in order</span>
<span class="sd">            to fill in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>
<span class="sd">            If a string, represents the frequency of the pandas DatetimeIndex (see `offset aliases</span>
<span class="sd">            &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_ for more info on</span>
<span class="sd">            supported frequencies).</span>
<span class="sd">            If an integer, represents the step size of the pandas Index or pandas RangeIndex.</span>
<span class="sd">        components</span>
<span class="sd">            Optionally, some column names to use for the second `values` dimension.</span>
<span class="sd">        fillna_value</span>
<span class="sd">            Optionally, a numeric value to fill missing values (NaNs) with.</span>
<span class="sd">        static_covariates</span>
<span class="sd">            Optionally, a set of static covariates to be added to the TimeSeries. Either a pandas Series or a pandas</span>
<span class="sd">            DataFrame. If a Series, the index represents the static variables. The covariates are globally &#39;applied&#39;</span>
<span class="sd">            to all components of the TimeSeries. If a DataFrame, the columns represent the static variables and the</span>
<span class="sd">            rows represent the components of the uni/multivariate TimeSeries. If a single-row DataFrame, the covariates</span>
<span class="sd">            are globally &#39;applied&#39; to all components of the TimeSeries. If a multi-row DataFrame, the number of</span>
<span class="sd">            rows must match the number of components of the TimeSeries (in this case, the number of columns in</span>
<span class="sd">            ``values``). This adds control for component-specific static covariates.</span>
<span class="sd">        hierarchy</span>
<span class="sd">            Optionally, a dictionary describing the grouping(s) of the time series. The keys are component names, and</span>
<span class="sd">            for a given component name `c`, the value is a list of component names that `c` &quot;belongs&quot; to. For instance,</span>
<span class="sd">            if there is a `total` component, split both in two divisions `d1` and `d2` and in two regions `r1` and `r2`,</span>
<span class="sd">            and four products `d1r1` (in division `d1` and region `r1`), `d2r1`, `d1r2` and `d2r2`, the hierarchy would</span>
<span class="sd">            be encoded as follows.</span>

<span class="sd">            .. highlight:: python</span>
<span class="sd">            .. code-block:: python</span>

<span class="sd">                hierarchy={</span>
<span class="sd">                    &quot;d1r1&quot;: [&quot;d1&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d1r2&quot;: [&quot;d1&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d2r1&quot;: [&quot;d2&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d2r2&quot;: [&quot;d2&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;d2&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r2&quot;: [&quot;total&quot;]</span>
<span class="sd">                }</span>
<span class="sd">            ..</span>
<span class="sd">            The hierarchy can be used to reconcile forecasts (so that the sums of the forecasts at</span>
<span class="sd">            different levels are consistent), see `hierarchical reconciliation</span>
<span class="sd">            &lt;https://unit8co.github.io/darts/generated_api/darts.dataprocessing.transformers.reconciliation.html&gt;`_.</span>
<span class="sd">        metadata</span>
<span class="sd">            Optionally, a dictionary with metadata to be added to the TimeSeries.</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to copy the `times` and `values` objects. If `copy=False`, mutating the series data will affect the</span>
<span class="sd">            original data. Additionally, if `times` lack a frequency or step size, it will be assigned to the original</span>
<span class="sd">            object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The resulting series.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from darts import TimeSeries</span>
<span class="sd">        &gt;&gt;&gt; from darts.utils.utils import generate_index</span>
<span class="sd">        &gt;&gt;&gt; # create values and times with daily frequency</span>
<span class="sd">        &gt;&gt;&gt; vals, times = np.arange(3), generate_index(&quot;2020-01-01&quot;, length=3, freq=&quot;D&quot;)</span>
<span class="sd">        &gt;&gt;&gt; series = TimeSeries(times=times, values=vals)</span>
<span class="sd">        &gt;&gt;&gt; series.shape</span>
<span class="sd">        (3, 1, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">VALID_INDEX_TYPES</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">times</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;the `times` argument must be a `pandas.RangeIndex`, or `pandas.DateTimeIndex`. Use &quot;</span>
                    <span class="s2">&quot;TimeSeries.from_values() if you want to use an automatic `RangeIndex`.&quot;</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># avoid copying if data is already np.ndarray:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">values</span>

        <span class="c1"># optionally, cast values to float</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;TimeSeries is using a numeric type different from numpy.float32 or numpy.float64. &quot;</span>
                <span class="s2">&quot;Not all functionalities may work properly. It is recommended casting your data to floating &quot;</span>
                <span class="s2">&quot;point numbers before using TimeSeries.&quot;</span>
            <span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">expand_arr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">DIMS</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;TimeSeries require a `values` array that has or can be expanded to &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;3 dimensions (</span><span class="si">{</span><span class="n">DIMS</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The time index and values must have the same length.&quot;</span><span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">components</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">components</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">COMP_AX</span><span class="p">])])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">components</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="n">components</span><span class="p">])</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">):</span>
            <span class="n">components</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span> <span class="o">!=</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">COMP_AX</span><span class="p">]:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The number of provided components must match the number of &quot;</span>
                    <span class="s2">&quot;components from `values` (`values.shape[1]`). Expected &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;number of components: `</span><span class="si">{</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">`, received: `</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span><span class="si">}</span><span class="s2">`.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="c1"># deepcopy the index as updating `times.freq` with a shallow `copy()` mutates the original index</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># clean component (column) names if needed (when names are not unique, or not strings)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">components</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">([</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">components</span>
        <span class="p">]):</span>
            <span class="n">components</span> <span class="o">=</span> <span class="n">_clean_components</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>

        <span class="n">has_datetime_index</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)</span>
        <span class="n">has_range_index</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">)</span>
        <span class="n">has_integer_index</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">has_datetime_index</span> <span class="ow">or</span> <span class="n">has_range_index</span><span class="p">)</span>

        <span class="c1"># remove timezone information if present; drops the frequency</span>
        <span class="c1"># TODO: potential to use timezone-aware index since `TimeSeries` was refactored</span>
        <span class="c1">#  to use numpy as backend</span>
        <span class="k">if</span> <span class="n">has_datetime_index</span> <span class="ow">and</span> <span class="n">times</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The provided DatetimeIndex was associated with a timezone (tz), which is currently &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;not supported. To avoid unexpected behaviour, the tz information was removed. Consider &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;calling `ts.time_index.tz_localize(</span><span class="si">{</span><span class="n">times</span><span class="o">.</span><span class="n">tz</span><span class="si">}</span><span class="s2">)` when exporting the results.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;To plot the series with the right time steps, consider setting the matplotlib.pyplot &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`rcParams[&#39;timezone&#39;]` parameter to automatically convert the time axis back to the &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;original timezone.&quot;</span>
            <span class="p">)</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">has_frequency</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">has_datetime_index</span> <span class="ow">and</span> <span class="n">times</span><span class="o">.</span><span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="n">has_range_index</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_frequency</span><span class="p">:</span>
            <span class="c1"># can only be `pd.DatetimeIndex` or int `pd.Index` (not `pd.RangeIndex`)</span>
            <span class="k">if</span> <span class="n">fill_missing_dates</span><span class="p">:</span>
                <span class="c1"># optionally fill missing dates</span>
                <span class="n">times</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_missing_dates</span><span class="p">(</span>
                    <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># using the provided `freq`</span>
                <span class="n">times</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restore_from_frequency</span><span class="p">(</span>
                    <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">has_integer_index</span><span class="p">:</span>
                <span class="c1"># integer `pd.Index` and no `freq` is provided; try convert it to pd.RangeIndex</span>
                <span class="n">times</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restore_range_indexed</span><span class="p">(</span><span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># `pd.DatetimeIndex`, and no `freq` provided; sort and see later if frequency can be inferred</span>
                <span class="n">times</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_index</span><span class="p">(</span><span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">has_datetime_index</span> <span class="ow">and</span> <span class="n">times</span><span class="o">.</span><span class="n">freq</span><span class="o">.</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">has_range_index</span>
            <span class="ow">and</span> <span class="n">times</span><span class="o">.</span><span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">fillna_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">)]</span> <span class="o">=</span> <span class="n">fillna_value</span>

        <span class="k">if</span> <span class="n">has_datetime_index</span><span class="p">:</span>
            <span class="c1"># frequency must be known or it can be inferred</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">freq</span>
            <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">freq</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">times</span><span class="o">.</span><span class="n">inferred_freq</span><span class="p">)</span>
                <span class="n">times</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span>

            <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;The time index is missing the `freq` attribute, and the frequency &quot;</span>
                        <span class="s2">&quot;could not be directly inferred. This probably comes from inconsistent date frequencies with &quot;</span>
                        <span class="s2">&quot;missing dates. If you know the actual frequency, try setting `fill_missing_dates=True, &quot;</span>
                        <span class="s2">&quot;freq=actual_frequency`. If not, try setting `fill_missing_dates=True, freq=None` to see if a &quot;</span>
                        <span class="s2">&quot;frequency can be inferred.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">freq_str</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">freqstr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">freq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">step</span>
            <span class="n">freq_str</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># how the dimensions are named; we convert hashable to string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">times</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">times</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">DIMS</span><span class="p">[</span><span class="n">TIME_AX</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span> <span class="o">=</span> <span class="n">times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freq_str</span> <span class="o">=</span> <span class="n">freq_str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span> <span class="o">=</span> <span class="n">has_datetime_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_components</span> <span class="o">=</span> <span class="n">components</span>

        <span class="c1"># check static covariates</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">static_covariates</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">))</span>
            <span class="ow">or</span> <span class="n">static_covariates</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;`static_covariates` must be either a pandas Series, DataFrame or None&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># check if valid static covariates for multivariate TimeSeries</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">static_covariates</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">n_components</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">static_covariates</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n_components</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n_components</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;When passing a multi-row pandas DataFrame, the number of rows must match the number of &quot;</span>
                        <span class="s2">&quot;components of the TimeSeries object (multi-component/multi-row static covariates &quot;</span>
                        <span class="s2">&quot;must map to each TimeSeries component).&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="n">static_covariates</span> <span class="o">=</span> <span class="n">static_covariates</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">static_covariates</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="n">static_covariates</span> <span class="o">=</span> <span class="n">static_covariates</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># None</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">static_covariates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">static_covariates</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">static_covariates</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span>
                <span class="k">else</span> <span class="p">[</span><span class="n">DEFAULT_GLOBAL_STATIC_COV_NAME</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">static_covariates</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">STATIC_COV_TAG</span>
            <span class="c1"># convert numerical columns to same dtype as series</span>
            <span class="c1"># we get all numerical columns, except those that have right dtype already</span>
            <span class="n">cols_to_cast</span> <span class="o">=</span> <span class="n">static_covariates</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span>
                <span class="n">include</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
            <span class="p">)</span><span class="o">.</span><span class="n">columns</span>

            <span class="c1"># Calling astype is costly even when there&#39;s no change...</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cols_to_cast</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">static_covariates</span> <span class="o">=</span> <span class="n">static_covariates</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols_to_cast</span><span class="p">},</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

        <span class="c1"># prepare metadata</span>
        <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;`metadata` must be of type `dict` mapping metadata attributes to their values.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># handle hierarchy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_top_level_component</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bottom_level_components</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">hierarchy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hierarchy</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;The hierarchy must be a dict mapping (non-top) component names to their parent(s) &quot;</span>
                        <span class="s2">&quot;in the hierarchy.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="c1"># pre-compute grouping information</span>
            <span class="n">components_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
            <span class="n">children</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">hierarchy</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="c1"># convert string ancestors to list of strings</span>
            <span class="n">hierarchy</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="p">([</span><span class="n">v</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">hierarchy</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">c</span> <span class="ow">in</span> <span class="n">components_set</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">):</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;The keys of the hierarchy must be time series components&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">ancestors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">hierarchy</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">a</span> <span class="ow">in</span> <span class="n">components_set</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ancestors</span><span class="p">):</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;The values of the hierarchy must only contain component names matching those &quot;</span>
                        <span class="s2">&quot;of the series.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">hierarchy_top</span> <span class="o">=</span> <span class="n">components_set</span> <span class="o">-</span> <span class="n">children</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">hierarchy_top</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;The hierarchy must be such that only one component does not appear as a key &quot;</span>
                        <span class="s2">&quot;(the top level component).&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_top_level_component</span> <span class="o">=</span> <span class="n">hierarchy_top</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_level_component</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ancestors</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Invalid hierarchy. Component </span><span class="si">{}</span><span class="s2"> appears as it should be top-level, but &quot;</span>
                        <span class="s2">&quot;does not appear as an ancestor in the hierarchy dict.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">bottom_level</span> <span class="o">=</span> <span class="n">components_set</span> <span class="o">-</span> <span class="n">ancestors</span>

            <span class="c1"># maintain the same order as the original components</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bottom_level_components</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">bottom_level</span>
            <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">STATIC_COV_TAG</span><span class="p">:</span> <span class="n">static_covariates</span><span class="p">,</span>
            <span class="n">HIERARCHY_TAG</span><span class="p">:</span> <span class="n">hierarchy</span><span class="p">,</span>
            <span class="n">METADATA_TAG</span><span class="p">:</span> <span class="n">metadata</span><span class="p">,</span>
        <span class="p">}</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Factory Methods</span>
<span class="sd">    ===============</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TimeSeries.from_xarray"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_xarray">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_xarray</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">xa</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fillna_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a ``TimeSeries`` from an `xarray.DataArray`.</span>

<span class="sd">        The dimensions of the DataArray have to be (time, component, sample), in this order. The time</span>
<span class="sd">        dimension can have an arbitrary name, but component and sample must be named &quot;component&quot; and &quot;sample&quot;,</span>
<span class="sd">        respectively.</span>

<span class="sd">        The first dimension (time), and second dimension (component) must be indexed (i.e., have coordinates).</span>
<span class="sd">        The time must be indexed either with a pandas DatetimeIndex, a pandas RangeIndex, or a pandas Index that can</span>
<span class="sd">        be converted to a RangeIndex. It is better if the index has no holes; alternatively setting</span>
<span class="sd">        `fill_missing_dates` can in some cases solve these issues (filling holes with NaN, or with the provided</span>
<span class="sd">        `fillna_value` numeric value, if any).</span>

<span class="sd">        If two components have the same name or are not strings, this method will disambiguate the components</span>
<span class="sd">        names by appending a suffix of the form &quot;&lt;name&gt;_N&quot; to the N-th column with name &quot;name&quot;.</span>
<span class="sd">        The component names in the static covariates and hierarchy (if any) are *not* disambiguated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xa</span>
<span class="sd">            The `xarray.DataArray`</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates (or indices in case of integer index)</span>
<span class="sd">            with NaN values. This requires either a provided `freq` or the possibility to infer the frequency from the</span>
<span class="sd">            provided timestamps. See :meth:`_fill_missing_dates() &lt;TimeSeries._fill_missing_dates&gt;` for more info.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string or integer representing the frequency of the underlying index. This is useful in order</span>
<span class="sd">            to fill in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>
<span class="sd">            If a string, represents the frequency of the pandas DatetimeIndex (see `offset aliases</span>
<span class="sd">            &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_ for more info on</span>
<span class="sd">            supported frequencies).</span>
<span class="sd">            If an integer, represents the step size of the pandas Index or pandas RangeIndex.</span>
<span class="sd">        fillna_value</span>
<span class="sd">            Optionally, a numeric value to fill missing values (NaNs) with.</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to copy the `times` (time index dimension) and `values` (data) objects. If `copy=False`, mutating</span>
<span class="sd">            the series data will affect the original data. Additionally, if `times` lack a frequency or step size, it</span>
<span class="sd">            will be assigned to the original object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The resulting series.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import xarray as xr</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from darts.timeseries import DIMS</span>
<span class="sd">        &gt;&gt;&gt; from darts import TimeSeries</span>
<span class="sd">        &gt;&gt;&gt; from darts.utils.utils import generate_index</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # create values with the required dimensions (time, component, sample)</span>
<span class="sd">        &gt;&gt;&gt; vals = np.random.random((3, 1, 1))</span>
<span class="sd">        &gt;&gt;&gt; # create time index with daily frequency</span>
<span class="sd">        &gt;&gt;&gt; times = generate_index(&quot;2020-01-01&quot;, length=3, freq=&quot;D&quot;)</span>
<span class="sd">        &gt;&gt;&gt; columns = [&quot;vals&quot;]</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # create xarray with the required dimensions and coordinates</span>
<span class="sd">        &gt;&gt;&gt; xa = xr.DataArray(</span>
<span class="sd">        &gt;&gt;&gt;     vals,</span>
<span class="sd">        &gt;&gt;&gt;     dims=DIMS,</span>
<span class="sd">        &gt;&gt;&gt;     coords={DIMS[0]: times, DIMS[1]: columns}</span>
<span class="sd">        &gt;&gt;&gt; )</span>
<span class="sd">        &gt;&gt;&gt; series = TimeSeries.from_xarray(xa)</span>
<span class="sd">        &gt;&gt;&gt; series.shape</span>
<span class="sd">        (3, 1, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="n">TIME_AX</span><span class="p">]),</span>
            <span class="n">values</span><span class="o">=</span><span class="n">xa</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">fill_missing_dates</span><span class="o">=</span><span class="n">fill_missing_dates</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="n">COMP_AX</span><span class="p">]),</span>
            <span class="n">fillna_value</span><span class="o">=</span><span class="n">fillna_value</span><span class="p">,</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="n">xa</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">STATIC_COV_TAG</span><span class="p">),</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="n">xa</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">HIERARCHY_TAG</span><span class="p">),</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">xa</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">METADATA_TAG</span><span class="p">),</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.from_csv"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_csv">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_csv</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">filepath_or_buffer</span><span class="p">,</span>
        <span class="n">time_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">value_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fillna_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">static_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hierarchy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a ``TimeSeries`` from a CSV file.</span>

<span class="sd">        One column can be used to represent the time (if not present, the time index will be a RangeIndex)</span>
<span class="sd">        and a list of columns `value_cols` can be used to indicate the values for this time series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filepath_or_buffer</span>
<span class="sd">            The path to the CSV file, or the file object; consistent with the argument of `pandas.read_csv` function</span>
<span class="sd">        time_col</span>
<span class="sd">            The time column name. If set, the column will be cast to a pandas DatetimeIndex (if it contains</span>
<span class="sd">            timestamps) or a RangeIndex (if it contains integers).</span>
<span class="sd">            If not set, the pandas RangeIndex will be used.</span>
<span class="sd">        value_cols</span>
<span class="sd">            A string or list of strings representing the value column(s) to be extracted from the CSV file. If set to</span>
<span class="sd">            `None`, all columns from the CSV file will be used (except for the time_col, if specified)</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates (or indices in case of integer index)</span>
<span class="sd">            with NaN values. This requires either a provided `freq` or the possibility to infer the frequency from the</span>
<span class="sd">            provided timestamps. See :meth:`_fill_missing_dates() &lt;TimeSeries._fill_missing_dates&gt;` for more info.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string or integer representing the frequency of the underlying index. This is useful in order</span>
<span class="sd">            to fill in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>
<span class="sd">            If a string, represents the frequency of the pandas DatetimeIndex (see `offset aliases</span>
<span class="sd">            &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_ for more info on</span>
<span class="sd">            supported frequencies).</span>
<span class="sd">            If an integer, represents the step size of the pandas Index or pandas RangeIndex.</span>
<span class="sd">        fillna_value</span>
<span class="sd">            Optionally, a numeric value to fill missing values (NaNs) with.</span>
<span class="sd">        static_covariates</span>
<span class="sd">            Optionally, a set of static covariates to be added to the TimeSeries. Either a pandas Series or a pandas</span>
<span class="sd">            DataFrame. If a Series, the index represents the static variables. The covariates are globally &#39;applied&#39;</span>
<span class="sd">            to all components of the TimeSeries. If a DataFrame, the columns represent the static variables and the</span>
<span class="sd">            rows represent the components of the uni/multivariate TimeSeries. If a single-row DataFrame, the covariates</span>
<span class="sd">            are globally &#39;applied&#39; to all components of the TimeSeries. If a multi-row DataFrame, the number of</span>
<span class="sd">            rows must match the number of components of the TimeSeries (in this case, the number of columns in the CSV</span>
<span class="sd">            file). This adds control for component-specific static covariates.</span>
<span class="sd">        hierarchy</span>
<span class="sd">            Optionally, a dictionary describing the grouping(s) of the time series. The keys are component names, and</span>
<span class="sd">            for a given component name `c`, the value is a list of component names that `c` &quot;belongs&quot; to. For instance,</span>
<span class="sd">            if there is a `total` component, split both in two divisions `d1` and `d2` and in two regions `r1` and `r2`,</span>
<span class="sd">            and four products `d1r1` (in division `d1` and region `r1`), `d2r1`, `d1r2` and `d2r2`, the hierarchy would</span>
<span class="sd">            be encoded as follows.</span>

<span class="sd">            .. highlight:: python</span>
<span class="sd">            .. code-block:: python</span>

<span class="sd">                hierarchy={</span>
<span class="sd">                    &quot;d1r1&quot;: [&quot;d1&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d1r2&quot;: [&quot;d1&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d2r1&quot;: [&quot;d2&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d2r2&quot;: [&quot;d2&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;d2&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r2&quot;: [&quot;total&quot;]</span>
<span class="sd">                }</span>
<span class="sd">            ..</span>
<span class="sd">            The hierarchy can be used to reconcile forecasts (so that the sums of the forecasts at</span>
<span class="sd">            different levels are consistent), see `hierarchical reconciliation</span>
<span class="sd">            &lt;https://unit8co.github.io/darts/generated_api/darts.dataprocessing.transformers.reconciliation.html&gt;`_.</span>
<span class="sd">        metadata</span>
<span class="sd">            Optionally, a dictionary with metadata to be added to the TimeSeries.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Optional arguments to be passed to `pandas.read_csv` function</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The resulting series.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from darts import TimeSeries</span>
<span class="sd">        &gt;&gt;&gt; TimeSeries.from_csv(&quot;data.csv&quot;, time_col=&quot;time&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">filepath_or_buffer</span><span class="o">=</span><span class="n">filepath_or_buffer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
            <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
            <span class="n">value_cols</span><span class="o">=</span><span class="n">value_cols</span><span class="p">,</span>
            <span class="n">fill_missing_dates</span><span class="o">=</span><span class="n">fill_missing_dates</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">fillna_value</span><span class="o">=</span><span class="n">fillna_value</span><span class="p">,</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="n">static_covariates</span><span class="p">,</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="n">hierarchy</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.from_dataframe"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_dataframe">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_dataframe</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">IntoDataFrame</span><span class="p">,</span>
        <span class="n">time_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">value_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fillna_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">static_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hierarchy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a ``TimeSeries`` from a selection of columns of a `DataFrame`.</span>

<span class="sd">        One column (or the DataFrame index) has to represent the time, and a list of columns `value_cols` has to</span>
<span class="sd">        represent the values for this time series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df</span>
<span class="sd">            The DataFrame, or anything which can be converted to a narwhals DataFrame (e.g. pandas.DataFrame,</span>
<span class="sd">            polars.DataFrame, ...). See the `narwhals documentation</span>
<span class="sd">            &lt;https://narwhals-dev.github.io/narwhals/api-reference/narwhals/#narwhals.from_native&gt;`_ for more</span>
<span class="sd">            information.</span>
<span class="sd">        time_col</span>
<span class="sd">            The time column name. If set, the column will be cast to a pandas DatetimeIndex (if it contains</span>
<span class="sd">            timestamps) or a RangeIndex (if it contains integers).</span>
<span class="sd">            If not set, the DataFrame index will be used. In this case the DataFrame must contain an index that is</span>
<span class="sd">            either a pandas DatetimeIndex, a pandas RangeIndex, or a pandas Index that can be converted to a</span>
<span class="sd">            RangeIndex. It is better if the index has no holes; alternatively setting `fill_missing_dates` can in some</span>
<span class="sd">            cases solve these issues (filling holes with NaN, or with the provided `fillna_value` numeric value, if</span>
<span class="sd">            any).</span>
<span class="sd">        value_cols</span>
<span class="sd">            A string or list of strings representing the value column(s) to be extracted from the DataFrame. If set to</span>
<span class="sd">            `None`, the whole DataFrame will be used.</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates (or indices in case of integer index)</span>
<span class="sd">            with NaN values. This requires either a provided `freq` or the possibility to infer the frequency from the</span>
<span class="sd">            provided timestamps. See :meth:`_fill_missing_dates() &lt;TimeSeries._fill_missing_dates&gt;` for more info.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string or integer representing the frequency of the underlying index. This is useful in order</span>
<span class="sd">            to fill in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>
<span class="sd">            If a string, represents the frequency of the pandas DatetimeIndex (see `offset aliases</span>
<span class="sd">            &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_ for more info on</span>
<span class="sd">            supported frequencies).</span>
<span class="sd">            If an integer, represents the step size of the pandas Index or pandas RangeIndex.</span>
<span class="sd">        fillna_value</span>
<span class="sd">            Optionally, a numeric value to fill missing values (NaNs) with.</span>
<span class="sd">        static_covariates</span>
<span class="sd">            Optionally, a set of static covariates to be added to the TimeSeries. Either a pandas Series or a pandas</span>
<span class="sd">            DataFrame. If a Series, the index represents the static variables. The covariates are globally &#39;applied&#39;</span>
<span class="sd">            to all components of the TimeSeries. If a DataFrame, the columns represent the static variables and the</span>
<span class="sd">            rows represent the components of the uni/multivariate TimeSeries. If a single-row DataFrame, the covariates</span>
<span class="sd">            are globally &#39;applied&#39; to all components of the TimeSeries. If a multi-row DataFrame, the number of</span>
<span class="sd">            rows must match the number of components of the TimeSeries (in this case, the number of columns in</span>
<span class="sd">            ``value_cols``). This adds control for component-specific static covariates.</span>
<span class="sd">        hierarchy</span>
<span class="sd">            Optionally, a dictionary describing the grouping(s) of the time series. The keys are component names, and</span>
<span class="sd">            for a given component name `c`, the value is a list of component names that `c` &quot;belongs&quot; to. For instance,</span>
<span class="sd">            if there is a `total` component, split both in two divisions `d1` and `d2` and in two regions `r1` and `r2`,</span>
<span class="sd">            and four products `d1r1` (in division `d1` and region `r1`), `d2r1`, `d1r2` and `d2r2`, the hierarchy would</span>
<span class="sd">            be encoded as follows.</span>

<span class="sd">            .. highlight:: python</span>
<span class="sd">            .. code-block:: python</span>

<span class="sd">                hierarchy={</span>
<span class="sd">                    &quot;d1r1&quot;: [&quot;d1&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d1r2&quot;: [&quot;d1&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d2r1&quot;: [&quot;d2&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d2r2&quot;: [&quot;d2&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;d2&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r2&quot;: [&quot;total&quot;]</span>
<span class="sd">                }</span>
<span class="sd">            ..</span>
<span class="sd">            The hierarchy can be used to reconcile forecasts (so that the sums of the forecasts at</span>
<span class="sd">            different levels are consistent), see `hierarchical reconciliation</span>
<span class="sd">            &lt;https://unit8co.github.io/darts/generated_api/darts.dataprocessing.transformers.reconciliation.html&gt;`_.</span>
<span class="sd">        metadata</span>
<span class="sd">            Optionally, a dictionary with metadata to be added to the TimeSeries.</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to copy the `times` (DataFrame index or the `time_col` column) and DataFrame `values`.</span>
<span class="sd">            If `copy=False`, mutating the series data will affect the original data. Additionally, if `times` lack a</span>
<span class="sd">            frequency or step size, it will be assigned to the original object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The resulting series.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; from darts import TimeSeries</span>
<span class="sd">        &gt;&gt;&gt; from darts.utils.utils import generate_index</span>
<span class="sd">        &gt;&gt;&gt; # create values and times with daily frequency</span>
<span class="sd">        &gt;&gt;&gt; data = {&quot;vals&quot;: range(3), &quot;time&quot;: generate_index(&quot;2020-01-01&quot;, length=3, freq=&quot;D&quot;)}</span>
<span class="sd">        &gt;&gt;&gt; # create from `pandas.DataFrame`</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(data)</span>
<span class="sd">        &gt;&gt;&gt; series = TimeSeries.from_dataframe(df, time_col=&quot;time&quot;)</span>
<span class="sd">        &gt;&gt;&gt; # shape (n time steps, n components, n samples)</span>
<span class="sd">        &gt;&gt;&gt; series.shape</span>
<span class="sd">        (3, 1, 1)</span>

<span class="sd">        &gt;&gt;&gt; # or from `polars.DataFrame` (make sure Polars is installed)</span>
<span class="sd">        &gt;&gt;&gt; import polars as pl</span>
<span class="sd">        &gt;&gt;&gt; df = pl.DataFrame(data)</span>
<span class="sd">        &gt;&gt;&gt; series = TimeSeries.from_dataframe(df, time_col=&quot;time&quot;)</span>
<span class="sd">        &gt;&gt;&gt; series.shape</span>
<span class="sd">        (3, 1, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">nw</span><span class="o">.</span><span class="n">from_native</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">eager_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pass_through</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># get time index</span>
        <span class="k">if</span> <span class="n">time_col</span><span class="p">:</span>
            <span class="n">time_index</span> <span class="o">=</span> <span class="n">dataframe_col_to_time_index</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">time_col</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time_index</span> <span class="o">=</span> <span class="n">nw</span><span class="o">.</span><span class="n">maybe_get_index</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">time_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">time_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="n">TIME_AX</span><span class="p">])</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;No time column specified (`time_col=None`) and no index found in the `DataFrame`. Defaulting to &quot;</span>
                    <span class="s2">&quot;`pandas.RangeIndex(len(df))`. If this is not desired consider adding a time column &quot;</span>
                    <span class="s2">&quot;to your `DataFrame` and defining `time_col`.&quot;</span>
                <span class="p">)</span>
            <span class="c1"># if we are here, the dataframe was pandas</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_index</span><span class="p">,</span> <span class="n">VALID_INDEX_TYPES</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">time_index</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;If time_col is not specified, the DataFrame must be indexed either with &quot;</span>
                        <span class="s2">&quot;a DatetimeIndex, a RangeIndex, or an integer Index that can be converted into a RangeIndex&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># get values</span>
        <span class="k">if</span> <span class="n">value_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">series_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">time_col</span><span class="p">)</span> <span class="k">if</span> <span class="n">time_col</span> <span class="k">else</span> <span class="n">df</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value_cols</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                <span class="n">value_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">value_cols</span><span class="p">]</span>
            <span class="n">series_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">value_cols</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">time_index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">series_df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
            <span class="n">fill_missing_dates</span><span class="o">=</span><span class="n">fill_missing_dates</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">series_df</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">fillna_value</span><span class="o">=</span><span class="n">fillna_value</span><span class="p">,</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="n">static_covariates</span><span class="p">,</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="n">hierarchy</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.from_group_dataframe"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_group_dataframe">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_group_dataframe</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">IntoDataFrame</span><span class="p">,</span>
        <span class="n">group_cols</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">time_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">value_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">static_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fillna_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">drop_group_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_jobs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Self</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a list of ``TimeSeries`` grouped by a selection of columns from a `DataFrame`.</span>

<span class="sd">        One column (or the DataFrame index) has to represent the time, a list of columns `group_cols` must be used for</span>
<span class="sd">        extracting the individual TimeSeries by groups, and a list of columns `value_cols` has to represent the values</span>
<span class="sd">        for the individual time series. Values from columns ``group_cols`` and ``static_cols`` are added as static</span>
<span class="sd">        covariates to the resulting TimeSeries objects. These can be viewed with `my_series.static_covariates`.</span>
<span class="sd">        Different to `group_cols`, `static_cols` only adds the static values but are not used to extract the TimeSeries</span>
<span class="sd">        groups.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df</span>
<span class="sd">            The DataFrame, or anything which can be converted to a narwhals DataFrame (e.g. pandas.DataFrame,</span>
<span class="sd">            polars.DataFrame, ...). See the `narwhals documentation</span>
<span class="sd">            &lt;https://narwhals-dev.github.io/narwhals/api-reference/narwhals/#narwhals.from_native&gt;`_ for more</span>
<span class="sd">            information.</span>
<span class="sd">        group_cols</span>
<span class="sd">            A string or list of strings representing the columns from the DataFrame by which to extract the</span>
<span class="sd">            individual TimeSeries groups.</span>
<span class="sd">        time_col</span>
<span class="sd">            The time column name. If set, the column will be cast to a pandas DatetimeIndex (if it contains</span>
<span class="sd">            timestamps) or a RangeIndex (if it contains integers).</span>
<span class="sd">            If not set, the DataFrame index will be used. In this case the DataFrame must contain an index that is</span>
<span class="sd">            either a pandas DatetimeIndex, a pandas RangeIndex, or a pandas Index that can be converted to a</span>
<span class="sd">            RangeIndex. Be aware that the index must represents the actual index of each individual time series group</span>
<span class="sd">            (can contain non-unique values). It is better if the index has no holes; alternatively setting</span>
<span class="sd">            `fill_missing_dates` can in some cases solve these issues (filling holes with NaN, or with the provided</span>
<span class="sd">            `fillna_value` numeric value, if any).</span>
<span class="sd">        value_cols</span>
<span class="sd">            A string or list of strings representing the value column(s) to be extracted from the DataFrame. If set to</span>
<span class="sd">            `None`, the whole DataFrame will be used.</span>
<span class="sd">        static_cols</span>
<span class="sd">            A string or list of strings representing static variable columns from the DataFrame that should be</span>
<span class="sd">            appended as static covariates to the resulting TimeSeries groups. Different to `group_cols`, the</span>
<span class="sd">            DataFrame is not grouped by these columns. Uses the first encountered value per group and column</span>
<span class="sd">            (assumes that there is only one unique value). Static covariates can be used as input features to all</span>
<span class="sd">            Darts models that support it.</span>
<span class="sd">        metadata_cols</span>
<span class="sd">            Same as `static_cols` but appended as metadata to the resulting TimeSeries groups. Metadata will never be</span>
<span class="sd">            used by the underlying Darts models.</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates (or indices in case of integer index)</span>
<span class="sd">            with NaN values. This requires either a provided `freq` or the possibility to infer the frequency from the</span>
<span class="sd">            provided timestamps. See :meth:`_fill_missing_dates() &lt;TimeSeries._fill_missing_dates&gt;` for more info.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string or integer representing the frequency of the underlying index. This is useful in order</span>
<span class="sd">            to fill in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>
<span class="sd">            If a string, represents the frequency of the pandas DatetimeIndex (see `offset aliases</span>
<span class="sd">            &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_ for more info on</span>
<span class="sd">            supported frequencies).</span>
<span class="sd">            If an integer, represents the step size of the pandas Index or pandas RangeIndex.</span>
<span class="sd">        fillna_value</span>
<span class="sd">            Optionally, a numeric value to fill missing values (NaNs) with.</span>
<span class="sd">        drop_group_cols</span>
<span class="sd">            Optionally, a string or list of strings with `group_cols` column(s) to exclude from the static covariates.</span>
<span class="sd">        n_jobs</span>
<span class="sd">            Optionally, an integer representing the number of parallel jobs to run. Behavior is the same as in the</span>
<span class="sd">            `joblib.Parallel` class.</span>
<span class="sd">        verbose</span>
<span class="sd">            Optionally, a boolean value indicating whether to display a progress bar.</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to copy the `times` (DataFrame index or the `time_col` column) and DataFrame `values`.</span>
<span class="sd">            If `copy=False`, mutating the series data will affect the original data. Additionally, if `times` lack a</span>
<span class="sd">            frequency or step size, it will be assigned to the original object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[TimeSeries]</span>
<span class="sd">            A list of series, where each series represents one group from the DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; from darts import TimeSeries</span>
<span class="sd">        &gt;&gt;&gt; from darts.utils.utils import generate_index</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # create a DataFrame with two series that have different ids,</span>
<span class="sd">        &gt;&gt;&gt; # values, and frequencies</span>
<span class="sd">        &gt;&gt;&gt; df_1 = pd.DataFrame({</span>
<span class="sd">        &gt;&gt;&gt;     &quot;ID&quot;: [0] * 3,</span>
<span class="sd">        &gt;&gt;&gt;     &quot;vals&quot;: range(3),</span>
<span class="sd">        &gt;&gt;&gt;     &quot;time&quot;: generate_index(&quot;2020-01-01&quot;, length=3, freq=&quot;D&quot;)}</span>
<span class="sd">        &gt;&gt;&gt; )</span>
<span class="sd">        &gt;&gt;&gt; df_2 = pd.DataFrame({</span>
<span class="sd">        &gt;&gt;&gt;     &quot;ID&quot;: [1] * 6,</span>
<span class="sd">        &gt;&gt;&gt;     &quot;vals&quot;: range(6),</span>
<span class="sd">        &gt;&gt;&gt;     &quot;time&quot;: generate_index(&quot;2020-01-01&quot;, length=6, freq=&quot;h&quot;)}</span>
<span class="sd">        &gt;&gt;&gt; )</span>
<span class="sd">        &gt;&gt;&gt; df = pd.concat([df_1, df_2], axis=0)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # extract the series by &quot;ID&quot; groups from the DataFrame</span>
<span class="sd">        &gt;&gt;&gt; series_multi = TimeSeries.from_group_dataframe(</span>
<span class="sd">        &gt;&gt;&gt;     df,</span>
<span class="sd">        &gt;&gt;&gt;     group_cols=&quot;ID&quot;,</span>
<span class="sd">        &gt;&gt;&gt;     time_col=&quot;time&quot;</span>
<span class="sd">        &gt;&gt;&gt; )</span>
<span class="sd">        &gt;&gt;&gt; len(series_multi), series_multi[0].shape, series_multi[1].shape</span>
<span class="sd">        (2, (3, 1, 1), (6, 1, 1))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">nw</span><span class="o">.</span><span class="n">from_native</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">eager_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pass_through</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time_col</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">df</span><span class="o">.</span><span class="n">implementation</span><span class="o">.</span><span class="n">is_pandas</span><span class="p">():</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;`time_col` is required when `df` is not a `pandas.DataFrame`.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">is_sorted</span> <span class="o">=</span> <span class="n">nw</span><span class="o">.</span><span class="n">maybe_get_index</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_sorted</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span><span class="n">time_col</span><span class="p">)</span><span class="o">.</span><span class="n">is_sorted</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">implementation</span><span class="o">.</span><span class="n">is_pandas</span><span class="p">():</span>
                <span class="c1"># with pandas we can get a performance boost by converting the time_col to index</span>
                <span class="n">time_index</span> <span class="o">=</span> <span class="n">dataframe_col_to_time_index</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">time_col</span><span class="p">)</span>
                <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">time_col</span><span class="p">)</span><span class="o">.</span><span class="n">to_native</span><span class="p">()</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">time_index</span><span class="p">)</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">nw</span><span class="o">.</span><span class="n">from_native</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
                <span class="n">time_col</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">is_sorted</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;UserWarning: The (time) index from `df` is monotonically increasing. This may &quot;</span>
                <span class="s2">&quot;result in time series groups with non-overlapping (time) index. You can ignore this &quot;</span>
                <span class="s2">&quot;warning if the index represents the actual index of each individual time series group.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># group cols: used to extract time series groups from `df`, will also be added as static covariates</span>
        <span class="c1"># (except `drop_group_cols`)</span>
        <span class="n">group_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">group_cols</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group_cols</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">group_cols</span>
        <span class="k">if</span> <span class="n">drop_group_cols</span><span class="p">:</span>
            <span class="n">drop_group_cols</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[</span><span class="n">drop_group_cols</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">drop_group_cols</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">drop_group_cols</span>
            <span class="p">)</span>
            <span class="n">invalid_cols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">drop_group_cols</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">group_cols</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">invalid_cols</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Found invalid `drop_group_cols` columns. All columns must be in the passed `group_cols`. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Expected any of: </span><span class="si">{</span><span class="n">group_cols</span><span class="si">}</span><span class="s2">, received: </span><span class="si">{</span><span class="n">invalid_cols</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">drop_group_col_idx</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">group_cols</span><span class="p">)</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">drop_group_cols</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">drop_group_cols</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">drop_group_col_idx</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># static covariates: all `group_cols` (except `drop_group_cols`) and `static_cols`</span>
        <span class="k">if</span> <span class="n">static_cols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">static_cols</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[</span><span class="n">static_cols</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">static_cols</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">static_cols</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">static_cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">static_cov_cols</span> <span class="o">=</span> <span class="n">group_cols</span> <span class="o">+</span> <span class="n">static_cols</span>
        <span class="c1"># columns that are used as static covariates but not for grouping</span>
        <span class="n">extract_static_cov_cols</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">static_cov_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">drop_group_cols</span>
        <span class="p">]</span>

        <span class="c1"># metadata: all `metadata_cols`</span>
        <span class="k">if</span> <span class="n">metadata_cols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metadata_cols</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[</span><span class="n">metadata_cols</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metadata_cols</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">metadata_cols</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">metadata_cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># columns that are used as metadata but not for grouping or static covariates</span>
        <span class="n">extract_metadata_cols</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">metadata_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">static_cov_cols</span>
        <span class="p">]</span>

        <span class="n">extract_time_col</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">time_col</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="n">time_col</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">value_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value_cols</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">col</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
                <span class="k">if</span> <span class="n">col</span>
                <span class="ow">not</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">static_cov_cols</span> <span class="o">+</span> <span class="n">extract_metadata_cols</span> <span class="o">+</span> <span class="n">extract_time_col</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="n">extract_value_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">value_cols</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value_cols</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">value_cols</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span>
            <span class="n">static_cov_cols</span>
            <span class="o">+</span> <span class="n">extract_value_cols</span>
            <span class="o">+</span> <span class="n">extract_time_col</span>
            <span class="o">+</span> <span class="n">extract_metadata_cols</span>
        <span class="p">]</span>

        <span class="n">groups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">group_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group_cols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">group_cols</span><span class="p">)</span>

        <span class="c1"># not all backends maintain the order when grouping; need to sort the groups in the end for reproducibility</span>
        <span class="n">unique_groups</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">group_cols</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="n">group_cols</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">sorted_group_idx</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">group_</span><span class="p">):</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">group_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_groups</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1"># build progress bar for iterator</span>
        <span class="n">iterator</span> <span class="o">=</span> <span class="n">_build_tqdm_iterator</span><span class="p">(</span>
            <span class="n">groups</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_groups</span><span class="p">),</span>
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Creating TimeSeries&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">from_group</span><span class="p">(</span><span class="n">static_cov_vals</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
            <span class="n">static_cov_vals</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">static_cov_vals</span><span class="p">,)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">static_cov_vals</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">static_cov_vals</span>
            <span class="p">)</span>
            <span class="n">group_idx</span> <span class="o">=</span> <span class="n">static_cov_vals</span>
            <span class="c1"># optionally, exclude group columns from static covariates</span>
            <span class="k">if</span> <span class="n">drop_group_col_idx</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">drop_group_col_idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">group_cols</span><span class="p">):</span>
                    <span class="n">static_cov_vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">static_cov_vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                        <span class="n">val</span>
                        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">static_cov_vals</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">drop_group_col_idx</span>
                    <span class="p">)</span>

            <span class="k">if</span> <span class="n">static_cols</span><span class="p">:</span>
                <span class="c1"># use first value as static covariate (assume only one unique per group)</span>
                <span class="n">static_cov_vals</span> <span class="o">+=</span> <span class="n">group</span><span class="p">[</span><span class="n">static_cols</span><span class="p">]</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">metadata</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">metadata_cols</span><span class="p">:</span>
                <span class="c1"># use first value as metadata (assume only one unique per group)</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">col</span><span class="p">:</span> <span class="n">val</span>
                    <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">metadata_cols</span><span class="p">,</span> <span class="n">group</span><span class="p">[</span><span class="n">metadata_cols</span><span class="p">]</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
                <span class="p">}</span>

            <span class="k">return</span> <span class="p">(</span>
                <span class="n">group_idx</span><span class="p">,</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span>
                    <span class="n">df</span><span class="o">=</span><span class="n">group</span><span class="p">,</span>
                    <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
                    <span class="n">value_cols</span><span class="o">=</span><span class="n">extract_value_cols</span><span class="p">,</span>
                    <span class="n">fill_missing_dates</span><span class="o">=</span><span class="n">fill_missing_dates</span><span class="p">,</span>
                    <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
                    <span class="n">fillna_value</span><span class="o">=</span><span class="n">fillna_value</span><span class="p">,</span>
                    <span class="n">static_covariates</span><span class="o">=</span><span class="p">(</span>
                        <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">static_cov_vals</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">extract_static_cov_cols</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">extract_static_cov_cols</span>
                        <span class="k">else</span> <span class="kc">None</span>
                    <span class="p">),</span>
                    <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                    <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="n">series_groups</span> <span class="o">=</span> <span class="n">_parallel_apply</span><span class="p">(</span>
            <span class="n">iterator</span><span class="p">,</span>
            <span class="n">from_group</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="p">,</span>
            <span class="n">fn_args</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>
            <span class="n">fn_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>
        <span class="p">)</span>

        <span class="c1"># re-order series to get reproducible results</span>
        <span class="n">series</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_group_idx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">group_i</span><span class="p">,</span> <span class="n">series_group</span> <span class="ow">in</span> <span class="n">series_groups</span><span class="p">:</span>
            <span class="n">series</span><span class="p">[</span><span class="n">sorted_group_idx</span><span class="p">[</span><span class="n">group_i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">series_group</span>
        <span class="k">return</span> <span class="n">series</span></div>

<div class="viewcode-block" id="TimeSeries.from_series"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_series">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_series</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">pd_series</span><span class="p">:</span> <span class="n">IntoSeries</span><span class="p">,</span>
        <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fillna_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">static_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a ``TimeSeries`` from a `Series`.</span>

<span class="sd">        The series must contain an index that is either a pandas DatetimeIndex, a pandas RangeIndex, or a pandas Index</span>
<span class="sd">        that can be converted into a RangeIndex. It is better if the index has no holes; alternatively setting</span>
<span class="sd">        `fill_missing_dates` can in some cases solve these issues (filling holes with NaN, or with the provided</span>
<span class="sd">        `fillna_value` numeric value, if any).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pd_series</span>
<span class="sd">            The Series, or anything which can be converted to a narwhals Series (e.g. pandas.Series, ...). See the</span>
<span class="sd">            `narwhals documentation</span>
<span class="sd">            &lt;https://narwhals-dev.github.io/narwhals/api-reference/narwhals/#narwhals.from_native&gt;`_ for more</span>
<span class="sd">            information.</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates (or indices in case of integer index)</span>
<span class="sd">            with NaN values. This requires either a provided `freq` or the possibility to infer the frequency from the</span>
<span class="sd">            provided timestamps. See :meth:`_fill_missing_dates() &lt;TimeSeries._fill_missing_dates&gt;` for more info.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string or integer representing the frequency of the underlying index. This is useful in order</span>
<span class="sd">            to fill in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>
<span class="sd">            If a string, represents the frequency of the pandas DatetimeIndex (see `offset aliases</span>
<span class="sd">            &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_ for more info on</span>
<span class="sd">            supported frequencies).</span>
<span class="sd">            If an integer, represents the step size of the pandas Index or pandas RangeIndex.</span>
<span class="sd">        fillna_value</span>
<span class="sd">            Optionally, a numeric value to fill missing values (NaNs) with.</span>
<span class="sd">        static_covariates</span>
<span class="sd">            Optionally, a set of static covariates to be added to the TimeSeries. Either a pandas Series or a</span>
<span class="sd">            single-row pandas DataFrame. If a Series, the index represents the static variables. If a DataFrame, the</span>
<span class="sd">            columns represent the static variables and the single row represents the univariate TimeSeries component.</span>
<span class="sd">        metadata</span>
<span class="sd">            Optionally, a dictionary with metadata to be added to the TimeSeries.</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to copy the Series&#39; `values`. If `copy=False`, mutating the series data will affect the original</span>
<span class="sd">            data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The resulting series.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; from darts import TimeSeries</span>
<span class="sd">        &gt;&gt;&gt; from darts.utils.utils import generate_index</span>
<span class="sd">        &gt;&gt;&gt; # create values and times with daily frequency</span>
<span class="sd">        &gt;&gt;&gt; vals, times = range(3), generate_index(&quot;2020-01-01&quot;, length=3, freq=&quot;D&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # create from `pandas.Series`</span>
<span class="sd">        &gt;&gt;&gt; pd_series = pd.Series(vals, index=times)</span>
<span class="sd">        &gt;&gt;&gt; series = TimeSeries.from_series(pd_series)</span>
<span class="sd">        &gt;&gt;&gt; series.shape</span>
<span class="sd">        (3, 1, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nw_series</span> <span class="o">=</span> <span class="n">nw</span><span class="o">.</span><span class="n">from_native</span><span class="p">(</span><span class="n">pd_series</span><span class="p">,</span> <span class="n">series_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pass_through</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">nw_series</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span>
            <span class="n">time_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">value_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">fill_missing_dates</span><span class="o">=</span><span class="n">fill_missing_dates</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">fillna_value</span><span class="o">=</span><span class="n">fillna_value</span><span class="p">,</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="n">static_covariates</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.from_times_and_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_times_and_values">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_times_and_values</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">times</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">],</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">_typing</span><span class="o">.</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fillna_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">static_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hierarchy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a ``TimeSeries`` from a time index and value array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times</span>
<span class="sd">            A pandas DateTimeIndex, RangeIndex, or Index that can be converted to a RangeIndex representing the time</span>
<span class="sd">            axis for the time series. It is better if the index has no holes; alternatively setting</span>
<span class="sd">            `fill_missing_dates` can in some cases solve these issues (filling holes with NaN, or with the provided</span>
<span class="sd">            `fillna_value` numeric value, if any).</span>
<span class="sd">        values</span>
<span class="sd">            A Numpy array, or array-like of values for the TimeSeries. Both 2-dimensional arrays, for deterministic</span>
<span class="sd">            series, and 3-dimensional arrays, for probabilistic series, are accepted. In the former case the dimensions</span>
<span class="sd">            should be (time, component), and in the latter case (time, component, sample).</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates (or indices in case of integer index)</span>
<span class="sd">            with NaN values. This requires either a provided `freq` or the possibility to infer the frequency from the</span>
<span class="sd">            provided timestamps. See :meth:`_fill_missing_dates() &lt;TimeSeries._fill_missing_dates&gt;` for more info.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string or integer representing the frequency of the underlying index. This is useful in order</span>
<span class="sd">            to fill in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>
<span class="sd">            If a string, represents the frequency of the pandas DatetimeIndex (see `offset aliases</span>
<span class="sd">            &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_ for more info on</span>
<span class="sd">            supported frequencies).</span>
<span class="sd">            If an integer, represents the step size of the pandas Index or pandas RangeIndex.</span>
<span class="sd">        columns</span>
<span class="sd">            Optionally, some column names to use for the second `values` dimension.</span>
<span class="sd">        fillna_value</span>
<span class="sd">            Optionally, a numeric value to fill missing values (NaNs) with.</span>
<span class="sd">        static_covariates</span>
<span class="sd">            Optionally, a set of static covariates to be added to the TimeSeries. Either a pandas Series or a pandas</span>
<span class="sd">            DataFrame. If a Series, the index represents the static variables. The covariates are globally &#39;applied&#39;</span>
<span class="sd">            to all components of the TimeSeries. If a DataFrame, the columns represent the static variables and the</span>
<span class="sd">            rows represent the components of the uni/multivariate TimeSeries. If a single-row DataFrame, the covariates</span>
<span class="sd">            are globally &#39;applied&#39; to all components of the TimeSeries. If a multi-row DataFrame, the number of</span>
<span class="sd">            rows must match the number of components of the TimeSeries (in this case, the number of columns in</span>
<span class="sd">            ``values``). This adds control for component-specific static covariates.</span>
<span class="sd">        hierarchy</span>
<span class="sd">            Optionally, a dictionary describing the grouping(s) of the time series. The keys are component names, and</span>
<span class="sd">            for a given component name `c`, the value is a list of component names that `c` &quot;belongs&quot; to. For instance,</span>
<span class="sd">            if there is a `total` component, split both in two divisions `d1` and `d2` and in two regions `r1` and `r2`,</span>
<span class="sd">            and four products `d1r1` (in division `d1` and region `r1`), `d2r1`, `d1r2` and `d2r2`, the hierarchy would</span>
<span class="sd">            be encoded as follows.</span>

<span class="sd">            .. highlight:: python</span>
<span class="sd">            .. code-block:: python</span>

<span class="sd">                hierarchy={</span>
<span class="sd">                    &quot;d1r1&quot;: [&quot;d1&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d1r2&quot;: [&quot;d1&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d2r1&quot;: [&quot;d2&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d2r2&quot;: [&quot;d2&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;d2&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r2&quot;: [&quot;total&quot;]</span>
<span class="sd">                }</span>
<span class="sd">            ..</span>
<span class="sd">            The hierarchy can be used to reconcile forecasts (so that the sums of the forecasts at</span>
<span class="sd">            different levels are consistent), see `hierarchical reconciliation</span>
<span class="sd">            &lt;https://unit8co.github.io/darts/generated_api/darts.dataprocessing.transformers.reconciliation.html&gt;`_.</span>
<span class="sd">        metadata</span>
<span class="sd">            Optionally, a dictionary with metadata to be added to the TimeSeries.</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to copy the `times` and `values` objects. If `copy=False`, mutating the series data will affect the</span>
<span class="sd">            original data. Additionally, if `times` lack a frequency or step size, it will be assigned to the original</span>
<span class="sd">            object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The resulting series.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from darts import TimeSeries</span>
<span class="sd">        &gt;&gt;&gt; from darts.utils.utils import generate_index</span>
<span class="sd">        &gt;&gt;&gt; # create values and times with daily frequency</span>
<span class="sd">        &gt;&gt;&gt; vals, times = np.arange(3), generate_index(&quot;2020-01-01&quot;, length=3, freq=&quot;D&quot;)</span>
<span class="sd">        &gt;&gt;&gt; series = TimeSeries.from_times_and_values(times=times, values=vals)</span>
<span class="sd">        &gt;&gt;&gt; series.shape</span>
<span class="sd">        (3, 1, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
            <span class="n">fill_missing_dates</span><span class="o">=</span><span class="n">fill_missing_dates</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">fillna_value</span><span class="o">=</span><span class="n">fillna_value</span><span class="p">,</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="n">static_covariates</span><span class="p">,</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="n">hierarchy</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.from_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_values">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_values</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">_typing</span><span class="o">.</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fillna_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">static_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hierarchy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an ``TimeSeries`` from an array of values.</span>

<span class="sd">        The series will have an integer time index (RangeIndex).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values</span>
<span class="sd">            A Numpy array of values for the TimeSeries. Both 2-dimensional arrays, for deterministic series,</span>
<span class="sd">            and 3-dimensional arrays, for probabilistic series, are accepted. In the former case the dimensions</span>
<span class="sd">            should be (time, component), and in the latter case (time, component, sample).</span>
<span class="sd">        columns</span>
<span class="sd">            Columns to be used by the underlying pandas DataFrame.</span>
<span class="sd">        fillna_value</span>
<span class="sd">            Optionally, a numeric value to fill missing values (NaNs) with.</span>
<span class="sd">        static_covariates</span>
<span class="sd">            Optionally, a set of static covariates to be added to the TimeSeries. Either a pandas Series or a pandas</span>
<span class="sd">            DataFrame. If a Series, the index represents the static variables. The covariates are globally &#39;applied&#39;</span>
<span class="sd">            to all components of the TimeSeries. If a DataFrame, the columns represent the static variables and the</span>
<span class="sd">            rows represent the components of the uni/multivariate TimeSeries. If a single-row DataFrame, the covariates</span>
<span class="sd">            are globally &#39;applied&#39; to all components of the TimeSeries. If a multi-row DataFrame, the number of</span>
<span class="sd">            rows must match the number of components of the TimeSeries (in this case, the number of columns in</span>
<span class="sd">            ``values``). This adds control for component-specific static covariates.</span>
<span class="sd">        hierarchy</span>
<span class="sd">            Optionally, a dictionary describing the grouping(s) of the time series. The keys are component names, and</span>
<span class="sd">            for a given component name `c`, the value is a list of component names that `c` &quot;belongs&quot; to. For instance,</span>
<span class="sd">            if there is a `total` component, split both in two divisions `d1` and `d2` and in two regions `r1` and `r2`,</span>
<span class="sd">            and four products `d1r1` (in division `d1` and region `r1`), `d2r1`, `d1r2` and `d2r2`, the hierarchy would</span>
<span class="sd">            be encoded as follows.</span>

<span class="sd">            .. highlight:: python</span>
<span class="sd">            .. code-block:: python</span>

<span class="sd">                hierarchy={</span>
<span class="sd">                    &quot;d1r1&quot;: [&quot;d1&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d1r2&quot;: [&quot;d1&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d2r1&quot;: [&quot;d2&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d2r2&quot;: [&quot;d2&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;d2&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r2&quot;: [&quot;total&quot;]</span>
<span class="sd">                }</span>
<span class="sd">            ..</span>
<span class="sd">            The hierarchy can be used to reconcile forecasts (so that the sums of the forecasts at</span>
<span class="sd">            different levels are consistent), see `hierarchical reconciliation</span>
<span class="sd">            &lt;https://unit8co.github.io/darts/generated_api/darts.dataprocessing.transformers.reconciliation.html&gt;`_.</span>
<span class="sd">        metadata</span>
<span class="sd">            Optionally, a dictionary with metadata to be added to the TimeSeries.</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to copy the `values`. If `copy=False`, mutating the series data will affect the original data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The resulting series.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from darts import TimeSeries</span>
<span class="sd">        &gt;&gt;&gt; from darts.utils.utils import generate_index</span>
<span class="sd">        &gt;&gt;&gt; vals = np.arange(3)</span>
<span class="sd">        &gt;&gt;&gt; series = TimeSeries.from_times_and_values(times=times, values=vals)</span>
<span class="sd">        &gt;&gt;&gt; series.shape</span>
<span class="sd">        (3, 1, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
            <span class="n">fill_missing_dates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">fillna_value</span><span class="o">=</span><span class="n">fillna_value</span><span class="p">,</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="n">static_covariates</span><span class="p">,</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="n">hierarchy</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.from_json"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_json">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_json</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">json_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">static_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hierarchy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a ``TimeSeries`` from the JSON String representation of a ``TimeSeries``.</span>

<span class="sd">        The JSON String representation can be generated with :func:`TimeSeries.to_json()`.</span>

<span class="sd">        At the moment this only supports deterministic time series (i.e., made of 1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        json_str</span>
<span class="sd">            The JSON String to convert.</span>
<span class="sd">        static_covariates</span>
<span class="sd">            Optionally, a set of static covariates to be added to the TimeSeries. Either a pandas Series or a pandas</span>
<span class="sd">            DataFrame. If a Series, the index represents the static variables. The covariates are globally &#39;applied&#39;</span>
<span class="sd">            to all components of the TimeSeries. If a DataFrame, the columns represent the static variables and the</span>
<span class="sd">            rows represent the components of the uni/multivariate TimeSeries. If a single-row DataFrame, the covariates</span>
<span class="sd">            are globally &#39;applied&#39; to all components of the TimeSeries. If a multi-row DataFrame, the number of</span>
<span class="sd">            rows must match the number of components of the TimeSeries (in this case, the number of columns in</span>
<span class="sd">            ``value_cols``). This adds control for component-specific static covariates.</span>
<span class="sd">        hierarchy</span>
<span class="sd">            Optionally, a dictionary describing the grouping(s) of the time series. The keys are component names, and</span>
<span class="sd">            for a given component name `c`, the value is a list of component names that `c` &quot;belongs&quot; to. For instance,</span>
<span class="sd">            if there is a `total` component, split both in two divisions `d1` and `d2` and in two regions `r1` and `r2`,</span>
<span class="sd">            and four products `d1r1` (in division `d1` and region `r1`), `d2r1`, `d1r2` and `d2r2`, the hierarchy would</span>
<span class="sd">            be encoded as follows.</span>

<span class="sd">            .. highlight:: python</span>
<span class="sd">            .. code-block:: python</span>

<span class="sd">                hierarchy={</span>
<span class="sd">                    &quot;d1r1&quot;: [&quot;d1&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d1r2&quot;: [&quot;d1&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d2r1&quot;: [&quot;d2&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d2r2&quot;: [&quot;d2&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;d2&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r2&quot;: [&quot;total&quot;]</span>
<span class="sd">                }</span>
<span class="sd">            ..</span>
<span class="sd">            The hierarchy can be used to reconcile forecasts (so that the sums of the forecasts at</span>
<span class="sd">            different levels are consistent), see `hierarchical reconciliation</span>
<span class="sd">            &lt;https://unit8co.github.io/darts/generated_api/darts.dataprocessing.transformers.reconciliation.html&gt;`_.</span>
<span class="sd">        metadata</span>
<span class="sd">            Optionally, a dictionary with metadata to be added to the TimeSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The resulting series.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from darts import TimeSeries</span>
<span class="sd">        &gt;&gt;&gt; json_str = (</span>
<span class="sd">        &gt;&gt;&gt;     &#39;{&quot;columns&quot;:[&quot;vals&quot;],&quot;index&quot;:[&quot;2020-01-01&quot;,&quot;2020-01-02&quot;,&quot;2020-01-03&quot;],&quot;data&quot;:[[0.0],[1.0],[2.0]]}&#39;</span>
<span class="sd">        &gt;&gt;&gt; )</span>
<span class="sd">        &gt;&gt;&gt; series = TimeSeries.from_json(&quot;data.csv&quot;)</span>
<span class="sd">        &gt;&gt;&gt; series.shape</span>
<span class="sd">        (3, 1, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_json</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">json_str</span><span class="p">),</span> <span class="n">orient</span><span class="o">=</span><span class="s2">&quot;split&quot;</span><span class="p">),</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="n">static_covariates</span><span class="p">,</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="n">hierarchy</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># JSON is immutable, so no need to copy</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.from_pickle"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_pickle">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_pickle</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read a pickled ``TimeSeries``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : string</span>
<span class="sd">            path pointing to a pickle file that will be loaded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The resulting series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Properties</span>
<span class="sd">    ==========</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">static_covariates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The static covariates of this series.</span>

<span class="sd">        If defined, the static covariates are given as a `pandas.DataFrame`. The columns represent the static variables</span>
<span class="sd">        and the rows represent the components of the series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">STATIC_COV_TAG</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">hierarchy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The hierarchy of this series.</span>

<span class="sd">        If defined, the hierarchy is given as a dictionary. The keys are the individual components and values are the</span>
<span class="sd">        set of parent(s) of these components in the hierarchy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">HIERARCHY_TAG</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The metadata of this series.</span>

<span class="sd">        If defined, the metadata is given as a dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">METADATA_TAG</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">top_level_component</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The top level component name of this series, or `None` if the series has no hierarchy.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_level_component</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bottom_level_components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The bottom level component names of this series, or `None` if the series has no hierarchy.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bottom_level_components</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">top_level_series</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Self</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The univariate series containing the single top-level component of this series, or `None` if the series has</span>
<span class="sd">        no hierarchy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">top_level_component</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_hierarchy</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bottom_level_series</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Self</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The series containing the bottom-level components of this series in the same order as they appear in the</span>
<span class="sd">        series, or `None` if the series has no hierarchy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="p">[[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottom_level_components</span><span class="p">]]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_hierarchy</span>
            <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The shape of the series `(n_timesteps, n_components, n_samples)`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_timesteps</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of time steps in the series.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">TIME_AX</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of samples contained in the series.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">SMPL_AX</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of components (columns) in the series.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">COMP_AX</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">width</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The width (number of components) of the series.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the series is deterministic.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">SMPL_AX</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_stochastic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the series is stochastic (probabilistic).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_probabilistic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the series is stochastic (probabilistic).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stochastic</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_univariate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the series is univariate.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">COMP_AX</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">freq</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The frequency of the series.</span>

<span class="sd">        A ``pandas.DateOffset`` if the series is indexed with a ``pandas.DatetimeIndex``.</span>
<span class="sd">        An integer (step size) if the series is indexed with a ``pandas.RangeIndex``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">freq_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The string representation of the series&#39; frequency.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq_str</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The dtype of the series&#39; values.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The component (column) names of the series, as a ``pandas.Index``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_components</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The component (column) names of the series, as a ``pandas.Index``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">time_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The time index of the series.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">time_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The time dimension name of the series.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_datetime_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the series is indexed with a ``pandas.DatetimeIndex`` (otherwise it is indexed with an</span>
<span class="sd">        ``pandas.RangeIndex``).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_range_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the series is indexed with an ``pandas.RangeIndex`` (otherwise it is indexed with a</span>
<span class="sd">        ``pandas.DatetimeIndex``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_hierarchy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the series contains a hierarchy.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_static_covariates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the series contains static covariates.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the series contains metadata.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">duration</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The duration of the series (as a ``pandas.Timedelta`` or `int`).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Export functions</span>
<span class="sd">    ================</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TimeSeries.data_array"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.data_array">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">data_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an ``xarray.DataArray`` representation of the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the series. Leave it to True unless you know what you are doing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            An ``xarray.DataArray`` representation of  represents the time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">,)</span> <span class="o">+</span> <span class="n">DIMS</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span> <span class="n">DIMS</span><span class="p">[</span><span class="n">COMP_AX</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">},</span>
            <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">xa</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">xa</span></div>

<div class="viewcode-block" id="TimeSeries.to_series"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.to_series">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">to_series</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">backend</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ModuleType</span><span class="p">,</span> <span class="n">Implementation</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">PANDAS</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a `Series` representation of the series in a given `backend`.</span>

<span class="sd">        Works only for univariate series that are deterministic (i.e., made of 1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the series. Leave it to True unless you know what you are doing.</span>
<span class="sd">        backend</span>
<span class="sd">            The backend to which to export the `TimeSeries`. See the `narwhals documentation</span>
<span class="sd">            &lt;https://narwhals-dev.github.io/narwhals/api-reference/narwhals/#narwhals.from_dict&gt;`_ for all supported</span>
<span class="sd">            backends.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            A Series representation of the series in a given `backend`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_univariate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>

        <span class="n">backend</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">from_backend</span><span class="p">(</span><span class="n">backend</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">backend</span><span class="o">.</span><span class="n">is_pandas</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span> <span class="n">time_as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.to_dataframe"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.to_dataframe">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">to_dataframe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">backend</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ModuleType</span><span class="p">,</span> <span class="n">Implementation</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">PANDAS</span><span class="p">,</span>
        <span class="n">time_as_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">suppress_warnings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a DataFrame representation of the series in a given `backend`.</span>

<span class="sd">        Each of the series components will appear as a column in the DataFrame.</span>
<span class="sd">        If the series is stochastic, the samples are returned as columns of the dataframe with column names</span>
<span class="sd">        as &#39;component_s#&#39; (e.g. with two components and two samples:</span>
<span class="sd">        &#39;comp0_s0&#39;, &#39;comp0_s1&#39; &#39;comp1_s0&#39; &#39;comp1_s1&#39;).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the dataframe. Leave it to True unless you know what you are doing.</span>
<span class="sd">        backend</span>
<span class="sd">            The backend to which to export the `TimeSeries`. See the `narwhals documentation</span>
<span class="sd">            &lt;https://narwhals-dev.github.io/narwhals/api-reference/narwhals/#narwhals.from_dict&gt;`_ for all supported</span>
<span class="sd">            backends.</span>
<span class="sd">        time_as_index</span>
<span class="sd">            Whether to set the time index as the index of the dataframe or in the left-most column.</span>
<span class="sd">            Only effective with the pandas `backend`.</span>
<span class="sd">        suppress_warnings</span>
<span class="sd">            Whether to suppress the warnings for the `DataFrame` creation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            A DataFrame representation of the series in a given `backend`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">backend</span> <span class="o">=</span> <span class="n">Implementation</span><span class="o">.</span><span class="n">from_backend</span><span class="p">(</span><span class="n">backend</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time_as_index</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">backend</span><span class="o">.</span><span class="n">is_pandas</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">suppress_warnings</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s1">&#39;`time_as_index=True` is only supported with `backend=&quot;pandas&quot;`, and will be ignored.&#39;</span>
                <span class="p">)</span>
            <span class="n">time_as_index</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">suppress_warnings</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;You are transforming a stochastic TimeSeries (i.e., contains several samples). &quot;</span>
                    <span class="s2">&quot;The resulting DataFrame is a 2D object with all samples on the columns. &quot;</span>
                    <span class="s2">&quot;If this is not the expected behavior consider calling a function &quot;</span>
                    <span class="s2">&quot;adapted to stochastic TimeSeries like quantile_df().&quot;</span>
                <span class="p">)</span>

            <span class="n">comp_name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">)</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;_s&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">comp_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">sample_id</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">comp_name</span><span class="p">,</span> <span class="n">sample_id</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">comp_name</span><span class="p">,</span> <span class="n">samples</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">values</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">time_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">time_index</span> <span class="o">=</span> <span class="n">time_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">time_as_index</span><span class="p">:</span>
            <span class="c1"># special path for pandas with index</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">time_index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">time_index</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">time_index</span><span class="p">,</span>  <span class="c1"># set time_index as left-most column</span>
            <span class="o">**</span><span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">columns</span><span class="p">)},</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">nw</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">)</span><span class="o">.</span><span class="n">to_native</span><span class="p">()</span></div>

<div class="viewcode-block" id="TimeSeries.schema"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.schema">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the schema of the series as a dictionary.</span>

<span class="sd">        Can be used to create new `TimeSeries` with the same schema.</span>

<span class="sd">        The keys and values are:</span>

<span class="sd">        - &quot;time_freq&quot;: the frequency (or step size) of the time (or range) index</span>
<span class="sd">        - &quot;time_name&quot;: the name of the time index</span>
<span class="sd">        - &quot;columns&quot;: the columns / components</span>
<span class="sd">        - &quot;static_covariates&quot;: the static covariates</span>
<span class="sd">        - &quot;hierarchy&quot;: the hierarchy</span>
<span class="sd">        - &quot;metadata&quot;: the metadata</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;time_freq&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">,</span>
            <span class="s2">&quot;time_name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s2">&quot;columns&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="n">STATIC_COV_TAG</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span>
            <span class="n">HIERARCHY_TAG</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">,</span>
            <span class="n">METADATA_TAG</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">schema</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">schema</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">schema</span></div>

<div class="viewcode-block" id="TimeSeries.astype"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.astype">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with the values have been converted to the desired `dtype`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype</span>
<span class="sd">            A NumPy dtype (numpy.float32 or numpy.float64)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A series having the desired dtype.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">),</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.start_time"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.start_time">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">start_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Start time of the series.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pandas.Timestamp, int]</span>
<span class="sd">            A timestamp containing the first time of the TimeSeries (if indexed by DatetimeIndex),</span>
<span class="sd">            or an integer (if indexed by RangeIndex)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.end_time"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.end_time">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">end_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;End time of the series.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pandas.Timestamp, int]</span>
<span class="sd">            A timestamp containing the last time of the TimeSeries (if indexed by DatetimeIndex),</span>
<span class="sd">            or an integer (if indexed by RangeIndex)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.first_value"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.first_value">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">first_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;First value of the univariate series.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The first value of this univariate deterministic time series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_univariate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="TimeSeries.last_value"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.last_value">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">last_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Last value of the univariate series.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The last value of this univariate deterministic time series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_univariate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="TimeSeries.first_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.first_values">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">first_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;First values of the potentially multivariate series.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The first values of every component of this deterministic time series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="TimeSeries.last_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.last_values">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">last_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Last values of the potentially multivariate series.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The last values of every component of this deterministic time series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="TimeSeries.values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.values">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">sample</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a 2-D array of shape (time, component), containing the series&#39; values for one `sample`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the values, otherwise returns a view.</span>
<span class="sd">            Leave it to True unless you know what you are doing.</span>
<span class="sd">        sample</span>
<span class="sd">            For stochastic series, the sample for which to return values. Default: 0 (first sample).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The values composing the time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span> <span class="ow">and</span> <span class="n">sample</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;This series contains one sample only (deterministic),&quot;</span>
                    <span class="s2">&quot;so only sample=0 is accepted.&quot;</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">sample</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">values</span></div>

<div class="viewcode-block" id="TimeSeries.random_component_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.random_component_values">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">random_component_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a 2-D array of shape (time, component), containing the series&#39; values for one sample taken uniformly</span>
<span class="sd">        at random from all samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the values, otherwise returns a view.</span>
<span class="sd">            Leave it to True unless you know what you are doing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The values composing one sample taken at random from the time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">sample</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">values</span></div>

<div class="viewcode-block" id="TimeSeries.all_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.all_values">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">all_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a 3-D array of dimension (time, component, sample) containing the series&#39; values for all samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the values, otherwise returns a view.</span>
<span class="sd">            Leave it to True unless you know what you are doing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The values composing the time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">values</span></div>

<div class="viewcode-block" id="TimeSeries.univariate_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.univariate_values">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">univariate_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">sample</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a 1-D Numpy array of shape (time,) containing the univariate series&#39; values for one `sample`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the values. Leave it to True unless you know what you are doing.</span>
<span class="sd">        sample</span>
<span class="sd">            For stochastic series, the sample for which to return values. Default: 0 (first sample).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The values composing the time series guaranteed to be univariate.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_univariate</span><span class="p">()</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sample</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">values</span></div>

<div class="viewcode-block" id="TimeSeries.static_covariates_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.static_covariates_values">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">static_covariates_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a 2-D array of dimension (component, static variable) containing the series&#39; static covariate values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the values, otherwise returns a view.</span>
<span class="sd">            Can only return a view if all values have the same dtype.</span>
<span class="sd">            Leave it to True unless you know what you are doing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Optional[numpy.ndarray]</span>
<span class="sd">            The static covariate values if the series has static covariates, else `None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_static_covariates</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.head"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.head">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">head</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with the first `size` points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : int, default 5</span>
<span class="sd">               number of points to retain</span>
<span class="sd">        axis : str or int, optional, default: 0</span>
<span class="sd">               axis along which to slice the series</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The series made of the first `size` points along the desired `axis`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">display_n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">TIME_AX</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[:</span><span class="n">display_n</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">COMP_AX</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[:</span><span class="n">display_n</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
                <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">display_n</span><span class="p">],</span>
                <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.tail"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.tail">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">tail</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with the last `size` points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : int, default: 5</span>
<span class="sd">            number of points to retain</span>
<span class="sd">        axis : str or int, optional, default: 0 (time dimension)</span>
<span class="sd">            axis along which we intend to display records</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The series made of the last `size` points along the desired `axis`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">display_n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">TIME_AX</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="n">display_n</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">COMP_AX</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="o">-</span><span class="n">display_n</span><span class="p">:]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
                <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="n">display_n</span><span class="p">:],</span>
                <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.concatenate"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.concatenate">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">concatenate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">ignore_time_axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_static_covariates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">drop_hierarchy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">drop_metadata</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series where this series is concatenated with the `other` series along a given `axis`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : TimeSeries</span>
<span class="sd">            another timeseries to concatenate to this one</span>
<span class="sd">        axis : str or int</span>
<span class="sd">            axis along which timeseries will be concatenated. [&#39;time&#39;, &#39;component&#39; or &#39;sample&#39;; Default: 0 (time)]</span>
<span class="sd">        ignore_time_axis : bool, default False</span>
<span class="sd">            Ignore errors when time axis varies for some timeseries. Note that this may yield unexpected results</span>
<span class="sd">        ignore_static_covariates : bool</span>
<span class="sd">            whether to ignore all requirements for static covariate concatenation and only transfer the</span>
<span class="sd">            static covariates of the current (`self`) timeseries to the concatenated timeseries.</span>
<span class="sd">            Only effective when `axis=1`.</span>
<span class="sd">        drop_hierarchy : bool</span>
<span class="sd">            When `axis=1`, whether to drop hierarchy information. True by default.</span>
<span class="sd">            When False, the hierarchies will be &quot;concatenated&quot; as well</span>
<span class="sd">            (by merging the hierarchy dictionaries), which may cause issues if the component</span>
<span class="sd">            names of the resulting series and that of the merged hierarchy do not match.</span>
<span class="sd">            When `axis=0` or `axis=2`, the hierarchy of the first series is always kept.</span>
<span class="sd">        drop_metadata : bool</span>
<span class="sd">            Whether to drop the metadata information of the concatenated timeseries. False by default.</span>
<span class="sd">            When False, the concatenated series will inherit the metadata from the current (`self`) timeseries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The concatenated series.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        concatenate : a function to concatenate multiple series along a given axis.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When concatenating along the `time` dimension, the current series marks the start date of</span>
<span class="sd">        the resulting series, and the other series will have its time index ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span>
            <span class="n">series</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">ignore_time_axis</span><span class="o">=</span><span class="n">ignore_time_axis</span><span class="p">,</span>
            <span class="n">ignore_static_covariates</span><span class="o">=</span><span class="n">ignore_static_covariates</span><span class="p">,</span>
            <span class="n">drop_hierarchy</span><span class="o">=</span><span class="n">drop_hierarchy</span><span class="p">,</span>
            <span class="n">drop_metadata</span><span class="o">=</span><span class="n">drop_metadata</span><span class="p">,</span>
        <span class="p">)</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Other methods</span>
<span class="sd">    =============</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TimeSeries.gaps"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.gaps">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">gaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;any&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute and return gaps in the series.</span>

<span class="sd">        Works only on deterministic time series (1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode</span>
<span class="sd">            Only relevant for multivariate time series. The mode defines how gaps are defined. Set to</span>
<span class="sd">            &#39;any&#39; if a NaN value in any columns should be considered as as gaps. &#39;all&#39; will only</span>
<span class="sd">            consider periods where all columns&#39; values are NaN. Defaults to &#39;all&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            A pandas.DataFrame containing a row for every gap (rows with all-NaN values in underlying DataFrame)</span>
<span class="sd">            in this time series. The DataFrame contains three columns that include the start and end time stamps</span>
<span class="sd">            of the gap and the integer length of the gap (in `self.freq` units if the series is indexed</span>
<span class="sd">            by a DatetimeIndex).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">is_nan_series</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;any&quot;</span><span class="p">:</span>
            <span class="n">is_nan_series</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Keyword mode accepts only &#39;any&#39; or &#39;all&#39;. Provided </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">is_nan_series</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">is_nan_series</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">gap_starts</span> <span class="o">=</span> <span class="n">diff</span><span class="p">[</span><span class="n">diff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>
        <span class="n">gap_ends</span> <span class="o">=</span> <span class="n">diff</span><span class="p">[</span><span class="n">diff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>

        <span class="k">if</span> <span class="n">is_nan_series</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">gap_starts</span> <span class="o">=</span> <span class="n">gap_starts</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">is_nan_series</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">gap_ends</span> <span class="o">=</span> <span class="n">gap_ends</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gap_ends</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">())</span>

        <span class="n">gap_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;gap_start&quot;</span><span class="p">,</span> <span class="s2">&quot;gap_end&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">gap_starts</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gap_df</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">intvl</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">)</span><span class="o">.</span><span class="n">size</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">int</span><span class="p">((</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">gap_df</span><span class="p">[</span><span class="s2">&quot;gap_start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gap_starts</span>
            <span class="n">gap_df</span><span class="p">[</span><span class="s2">&quot;gap_end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gap_ends</span>
            <span class="n">gap_df</span><span class="p">[</span><span class="s2">&quot;gap_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gap_df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">intvl</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">row</span><span class="o">.</span><span class="n">gap_start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">row</span><span class="o">.</span><span class="n">gap_end</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="n">gap_df</span></div>

<div class="viewcode-block" id="TimeSeries.copy"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.copy">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a copy of the series.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A copy of the series.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># the data will be copied in the TimeSeries constructor.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.get_index_at_point"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.get_index_at_point">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_index_at_point</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">after</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a point along the time index into an integer index ranging from (0, len(series)-1) inclusive.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point</span>
<span class="sd">            This parameter supports 3 different data types: ``pandas.Timestamp``, ``float`` and ``int``.</span>

<span class="sd">            ``pandas.Timestamp`` work only on series that are indexed with a ``pandas.DatetimeIndex``. In such cases,</span>
<span class="sd">            the returned point will be the index of this timestamp if it is present in the series time index.</span>
<span class="sd">            If it&#39;s not present in the time index, the index of the next timestamp is returned if `after=True`</span>
<span class="sd">            (if it exists in the series), otherwise the index of the previous timestamp is returned</span>
<span class="sd">            (if it exists in the series).</span>

<span class="sd">            In case of a ``float``, the parameter will be treated as the proportion of the time series</span>
<span class="sd">            that should lie before the point.</span>

<span class="sd">            If an ``int`` and series is datetime-indexed, the value of `point` is returned.</span>
<span class="sd">            If an ``int`` and series is integer-indexed, the index position of `point` in the RangeIndex is returned</span>
<span class="sd">            (accounting for steps).</span>
<span class="sd">        after</span>
<span class="sd">            If the provided pandas Timestamp is not in the time series index, whether to return the index of the</span>
<span class="sd">            next timestamp or the index of the previous one.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The index position corresponding to the provided point in the series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">point_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">point</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;point (float) should be between 0.0 and 1.0.&quot;</span><span class="p">),</span> <span class="n">logger</span>
                <span class="p">)</span>
            <span class="n">point_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">point</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_datetime_index</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">point_index</span> <span class="o">=</span> <span class="n">point</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">point_index_float</span> <span class="o">=</span> <span class="p">(</span><span class="n">point</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">())</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
                <span class="n">point_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">point_index_float</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">point_index</span> <span class="o">!=</span> <span class="n">point_index_float</span><span class="p">:</span>
                    <span class="n">raise_log</span><span class="p">(</span>
                        <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;The provided point is not a valid index for this series.&quot;</span>
                        <span class="p">),</span>
                        <span class="n">logger</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">point_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The index corresponding to the provided point (</span><span class="si">{</span><span class="n">point</span><span class="si">}</span><span class="s2">) should be a valid index in series&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;A Timestamp has been provided, but this series is not time-indexed.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_not_within</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">point_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">point_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_first_timestamp_after</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">after</span>
                    <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_last_timestamp_before</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;`point` needs to be either `float`, `int` or `pandas.Timestamp`&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">point_index</span></div>

<div class="viewcode-block" id="TimeSeries.get_timestamp_at_point"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.get_timestamp_at_point">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_timestamp_at_point</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a point into a ``pandas.Timestamp`` (if datetime-indexed) or integer (if integer-indexed).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point</span>
<span class="sd">            This parameter supports 3 different data types: `float`, `int` and `pandas.Timestamp`.</span>
<span class="sd">            In case of a `float`, the parameter will be treated as the proportion of the time series</span>
<span class="sd">            that should lie before the point.</span>
<span class="sd">            In case of `int`, the parameter will be treated as an integer index to the time index of</span>
<span class="sd">            `series`. Will raise a ValueError if not a valid index in `series`.</span>
<span class="sd">            In case of a `pandas.Timestamp`, point will be returned as is provided that the timestamp</span>
<span class="sd">            is present in the series time index, otherwise will raise a ValueError.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pandas.Timestamp, int]</span>
<span class="sd">            The index value corresponding to the provided point in the series.</span>
<span class="sd">            If the series is indexed by a `pandas.DatetimeIndex`, returns a `pandas.Timestamp`.</span>
<span class="sd">            If the series is indexed by a `pandas.RangeIndex`, returns an integer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index_at_point</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">_split_at</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">split_point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">after</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Self</span><span class="p">,</span> <span class="n">Self</span><span class="p">]:</span>
        <span class="c1"># Get index with not after in order to avoid moving twice if split_point is not in self</span>
        <span class="n">point_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index_at_point</span><span class="p">(</span><span class="n">split_point</span><span class="p">,</span> <span class="ow">not</span> <span class="n">after</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="p">[:</span> <span class="n">point_index</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">after</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)],</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">point_index</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">after</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span> <span class="p">:],</span>
        <span class="p">)</span>

<div class="viewcode-block" id="TimeSeries.split_after"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.split_after">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">split_after</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">split_point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Self</span><span class="p">,</span> <span class="n">Self</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Split the series in two, after a provided `split_point`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        split_point</span>
<span class="sd">            A timestamp, float or integer. If float, represents the proportion of the series to include in the</span>
<span class="sd">            first TimeSeries (must be between 0.0 and 1.0). If integer, represents the index position after</span>
<span class="sd">            which the split is performed. A pandas.Timestamp can be provided for TimeSeries that are indexed by a</span>
<span class="sd">            pandas.DatetimeIndex. In such cases, the timestamp will be contained in the first TimeSeries, but not</span>
<span class="sd">            in the second one. The timestamp itself does not have to appear in the original TimeSeries index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[TimeSeries, TimeSeries]</span>
<span class="sd">            A tuple of two series. The first time series contains the first entries up to the `split_point` (inclusive),</span>
<span class="sd">            and the second contains the remaining ones.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_at</span><span class="p">(</span><span class="n">split_point</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.split_before"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.split_before">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">split_before</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">split_point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Self</span><span class="p">,</span> <span class="n">Self</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Split the series in two, before a provided `split_point`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        split_point</span>
<span class="sd">            A timestamp, float or integer. If float, represents the proportion of the series to include in the</span>
<span class="sd">            first TimeSeries (must be between 0.0 and 1.0). If integer, represents the index position before</span>
<span class="sd">            which the split is performed. A pandas.Timestamp can be provided for TimeSeries that are indexed by a</span>
<span class="sd">            pandas.DatetimeIndex. In such cases, the timestamp will be contained in the second TimeSeries, but not</span>
<span class="sd">            in the first one. The timestamp itself does not have to appear in the original TimeSeries index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[TimeSeries, TimeSeries]</span>
<span class="sd">            A tuple of two series. The first time series contains the first entries up to the `split_point` (exclusive),</span>
<span class="sd">            and the second contains the remaining ones.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_at</span><span class="p">(</span><span class="n">split_point</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.drop_after"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.drop_after">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">drop_after</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">split_point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">keep_point</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series where everything after (and in-/excluding) the provided time `split_point` was dropped.</span>

<span class="sd">        The timestamp may not be in the series. If it is, the timestamp will be dropped.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        split_point</span>
<span class="sd">            The timestamp that indicates cut-off time.</span>
<span class="sd">        keep_point</span>
<span class="sd">            Whether the provided `split_point` should be included in the returned series (if it exists in the series).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A series that contains all entries until `split_point` (exclusive).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span>
            <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index_at_point</span><span class="p">(</span><span class="n">split_point</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="ow">not</span> <span class="n">keep_point</span><span class="p">)</span>
            <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">keep_point</span><span class="p">)</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.drop_before"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.drop_before">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">drop_before</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">split_point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">keep_point</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series where everything before (and in-/excluding) the provided time `split_point` was dropped.</span>

<span class="sd">        The timestamp may not be in the series. If it is, the timestamp will be dropped.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        split_point</span>
<span class="sd">            The timestamp that indicates cut-off time.</span>
<span class="sd">        keep_point</span>
<span class="sd">            Whether the provided `split_point` should be included in the returned series (if it exists in the series).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A series that contains all entries starting after `split_point` (exclusive).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_index_at_point</span><span class="p">(</span><span class="n">split_point</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="n">keep_point</span><span class="p">)</span>
            <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="n">keep_point</span><span class="p">)</span> <span class="p">:</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.slice"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.slice">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">slice</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">start_ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">end_ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a slice of the series starting at `start_ts` and ending before `end_ts`.</span>

<span class="sd">        For series having DatetimeIndex, this is inclusive on both ends. For series having a RangeIndex,</span>
<span class="sd">        `end_ts` is exclusive.</span>

<span class="sd">        `start_ts` and `end_ts` don&#39;t have to be in the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_ts</span>
<span class="sd">            The timestamp that indicates the left cut-off.</span>
<span class="sd">        end_ts</span>
<span class="sd">            The timestamp that indicates the right cut-off.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series, with indices greater or equal than `start_ts` and smaller or equal than `end_ts`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">start_ts</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">end_ts</span><span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The two timestamps provided to slice() have to be of the same type.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_ts</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Timestamps have been provided to slice(), but the series is &quot;</span>
                        <span class="s2">&quot;indexed using an integer-based RangeIndex.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">start_ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span> <span class="ow">and</span> <span class="n">end_ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span>
                    <span class="n">start_ts</span><span class="p">:</span><span class="n">end_ts</span>
                <span class="p">]</span>  <span class="c1"># we assume this is faster than the filtering below</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span>
                    <span class="p">(</span><span class="n">start_ts</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span> <span class="o">&lt;=</span> <span class="n">end_ts</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;start and end times have been provided as integers to slice(), but &quot;</span>
                        <span class="s2">&quot;the series is indexed with a DatetimeIndex.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="c1"># get closest timestamp if either start or end are not in the index</span>
            <span class="n">effective_start_ts</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">start_ts</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span>
                <span class="k">else</span> <span class="n">start_ts</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">effective_start_ts</span> <span class="o">&lt;</span> <span class="n">start_ts</span><span class="p">:</span>
                <span class="c1"># if the requested start_ts is smaller than the start argument,</span>
                <span class="c1"># we have to increase it to be consistent with the docstring</span>
                <span class="n">effective_start_ts</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>

            <span class="n">effective_end_ts</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">end_ts</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">end_ts</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span>
                <span class="k">else</span> <span class="n">end_ts</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">end_ts</span> <span class="o">&gt;=</span> <span class="n">effective_end_ts</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">:</span>
                <span class="c1"># if the requested end_ts is further off from the end of the time series,</span>
                <span class="c1"># we have to increase effective_end_ts to make the last timestamp inclusive.</span>
                <span class="n">effective_end_ts</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span><span class="n">effective_start_ts</span><span class="p">,</span> <span class="n">effective_end_ts</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.slice_n_points_after"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.slice_n_points_after">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">slice_n_points_after</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a slice of the series starting at `start_ts` (inclusive) and having at most `n` points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_ts</span>
<span class="sd">            The timestamp or index that indicates the splitting time.</span>
<span class="sd">        n</span>
<span class="sd">            The maximal length of the new TimeSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series, with length at most `n`, starting at `start_ts`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n should be a positive integer.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_not_within</span><span class="p">(</span><span class="n">start_ts</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_ts</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start_ts</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">start_ts</span> <span class="o">+</span> <span class="n">n</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_ts</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="c1"># get first timestamp greater or equal to start_ts</span>
            <span class="n">tss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_first_timestamp_after</span><span class="p">(</span><span class="n">start_ts</span><span class="p">)</span>
            <span class="n">point_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index_at_point</span><span class="p">(</span><span class="n">tss</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">point_index</span> <span class="p">:</span> <span class="n">point_index</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;start_ts must be an int or a pandas Timestamp.&quot;</span><span class="p">),</span> <span class="n">logger</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.slice_n_points_before"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.slice_n_points_before">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">slice_n_points_before</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end_ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a slice of the series ending at `end_ts` (inclusive) and having at most `n` points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        end_ts</span>
<span class="sd">            The timestamp or index that indicates the splitting time.</span>
<span class="sd">        n</span>
<span class="sd">            The maximal length of the new TimeSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series, with length at most `n`, ending at `end_ts`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n should be a positive integer.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_not_within</span><span class="p">(</span><span class="n">end_ts</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end_ts</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">end_ts</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">end_ts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end_ts</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="c1"># get last timestamp smaller or equal to start_ts</span>
            <span class="n">tss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_last_timestamp_before</span><span class="p">(</span><span class="n">end_ts</span><span class="p">)</span>
            <span class="n">point_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index_at_point</span><span class="p">(</span><span class="n">tss</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">point_index</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="n">point_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;start_ts must be an int or a pandas Timestamp.&quot;</span><span class="p">),</span> <span class="n">logger</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.slice_intersect"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.slice_intersect">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">slice_intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a slice of the series where the time index was intersected with the `other` series.</span>

<span class="sd">        This method is in general *not* symmetric.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            the other time series</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series, containing the values of this series, over the time-span common to both series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">has_same_time_as</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">freq</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice_intersect_bounds</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">time_index</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">time_index</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.slice_intersect_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.slice_intersect_values">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">slice_intersect_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the sliced values of the series where the time index was intersected with the `other` series.</span>

<span class="sd">        This method is in general *not* symmetric.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            The other time series</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the values, otherwise returns a view.</span>
<span class="sd">            Leave it to True unless you know what you are doing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The values of this series, over the time-span common to both series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_values</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">has_same_time_as</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">vals</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">freq</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice_intersect_bounds</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vals</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">vals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_time_index</span><span class="p">)]</span></div>

<div class="viewcode-block" id="TimeSeries.slice_intersect_times"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.slice_intersect_times">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">slice_intersect_times</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the time index of the series where the time index was intersected with the `other` series.</span>

<span class="sd">        This method is in general *not* symmetric.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            The other time series</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the time index, otherwise returns a view. Leave it to True unless you know</span>
<span class="sd">            what you are doing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pandas.DatetimeIndex, pandas.RangeIndex]</span>
<span class="sd">            The time index of this series, over the time-span common to both series.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">time_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">has_same_time_as</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">time_index</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">freq</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice_intersect_bounds</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">time_index</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">time_index</span><span class="p">[</span><span class="n">time_index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_time_index</span><span class="p">)]</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">_slice_intersect_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the start (absolute index) and end (index relative to the end) indices that represent the time</span>
<span class="sd">        intersection from `self` and `other`.&quot;&quot;&quot;</span>
        <span class="n">shift_start</span> <span class="o">=</span> <span class="n">n_steps_between</span><span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">start_time</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">(),</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
        <span class="p">)</span>
        <span class="n">shift_end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="n">shift_start</span><span class="p">)</span>

        <span class="n">shift_start</span> <span class="o">=</span> <span class="n">shift_start</span> <span class="k">if</span> <span class="n">shift_start</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">shift_end</span> <span class="o">=</span> <span class="n">shift_end</span> <span class="k">if</span> <span class="n">shift_end</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">shift_start</span><span class="p">,</span> <span class="n">shift_end</span>

<div class="viewcode-block" id="TimeSeries.strip"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.strip">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">strip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">how</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a slice of the deterministic time series where NaN-containing entries at the beginning and the end</span>
<span class="sd">        were removed.</span>

<span class="sd">        No entries after (and including) the first non-NaN entry and before (and including) the last non-NaN entry are</span>
<span class="sd">        removed.</span>

<span class="sd">        This method is only applicable to deterministic series (i.e., having 1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        how</span>
<span class="sd">            Define if the entries containing `NaN` in all the components (&#39;all&#39;) or in any of the components (&#39;any&#39;)</span>
<span class="sd">            should be stripped. Default: &#39;all&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series where NaN-containing entries at start and end were removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_probabilistic</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`strip` cannot be applied to stochastic TimeSeries&quot;</span><span class="p">),</span> <span class="n">logger</span>
            <span class="p">)</span>

        <span class="n">first_finite_row</span><span class="p">,</span> <span class="n">last_finite_row</span> <span class="o">=</span> <span class="n">_finite_rows_boundaries</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="n">first_finite_row</span> <span class="p">:</span> <span class="n">last_finite_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">first_finite_row</span> <span class="p">:</span> <span class="n">last_finite_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.longest_contiguous_slice"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.longest_contiguous_slice">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">longest_contiguous_slice</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">max_gap_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the largest slice of the deterministic series without any gaps (contiguous all-NaN value entries)</span>
<span class="sd">        larger than `max_gap_size`.</span>

<span class="sd">        This method is only applicable to deterministic series (i.e., having 1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_gap_size</span>
<span class="sd">            Indicate the maximum gap size that the series can contain.</span>
<span class="sd">        mode</span>
<span class="sd">            Only relevant for multivariate time series. The mode defines how gaps are defined. Set to</span>
<span class="sd">            &#39;any&#39; if a NaN value in any columns should be considered as as gaps. &#39;all&#39; will only</span>
<span class="sd">            consider periods where all columns&#39; values are NaN. Defaults to &#39;all&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with the largest slice of the original that has no gaps longer than `max_gap_size`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.gaps : return the gaps in the TimeSeries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">))</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">stripped_series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">gaps</span> <span class="o">=</span> <span class="n">stripped_series</span><span class="o">.</span><span class="n">gaps</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="n">relevant_gaps</span> <span class="o">=</span> <span class="n">gaps</span><span class="p">[</span><span class="n">gaps</span><span class="p">[</span><span class="s2">&quot;gap_size&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_gap_size</span><span class="p">]</span>

        <span class="n">curr_slice_start</span> <span class="o">=</span> <span class="n">stripped_series</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span>
        <span class="n">max_size</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">max_slice_start</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">max_slice_end</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">relevant_gaps</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="c1"># evaluate size of the current slice. the slice ends one time step before row[&#39;gap_start&#39;]</span>
            <span class="n">curr_slice_end</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;gap_start&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">curr_slice_end</span> <span class="o">-</span> <span class="n">curr_slice_start</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">max_size</span><span class="p">:</span>
                <span class="n">max_size</span> <span class="o">=</span> <span class="n">size</span>
                <span class="n">max_slice_start</span> <span class="o">=</span> <span class="n">curr_slice_start</span>
                <span class="n">max_slice_end</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;gap_start&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>
            <span class="n">curr_slice_start</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;gap_end&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>

        <span class="k">if</span> <span class="n">stripped_series</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span> <span class="o">-</span> <span class="n">curr_slice_start</span> <span class="o">&gt;</span> <span class="n">max_size</span><span class="p">:</span>
            <span class="n">max_slice_start</span> <span class="o">=</span> <span class="n">curr_slice_start</span>
            <span class="n">max_slice_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">stripped_series</span><span class="p">[</span><span class="n">max_slice_start</span><span class="p">:</span><span class="n">max_slice_end</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.rescale_with_value"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.rescale_with_value">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">rescale_with_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_at_first_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series, which is a multiple of this series such that the first value is `value_at_first_step`.</span>

<span class="sd">        Note: Numerical errors can appear with `value_at_first_step &gt; 1e+24`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value_at_first_step</span>
<span class="sd">            The new value for the first entry of the TimeSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series, where the first value is `value_at_first_step` and other values have been scaled accordingly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot rescale with first value `0`.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">value_at_first_step</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">*</span> <span class="n">coef</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.shift"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.shift">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series where the time index was shifted by `n` steps.</span>

<span class="sd">        If :math:`n &gt; 0`, shifts into the future. If :math:`n &lt; 0`, shifts into the past.</span>

<span class="sd">        For example, with :math:`n=2` and `freq=&#39;M&#39;`, March 2013 becomes May 2013.</span>
<span class="sd">        With :math:`n=-2`, March 2013 becomes Jan 2013.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n</span>
<span class="sd">            The number of time steps (in self.freq unit) to shift by. Can be negative.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series, with a shifted time index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;TimeSeries.shift(): converting n to int from </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
        <span class="k">except</span> <span class="n">pd</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">OutOfBoundsDatetime</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">OverflowError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;the add operation between </span><span class="si">{</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> will &quot;</span>
                    <span class="s2">&quot;overflow&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_range_index</span><span class="p">:</span>
            <span class="n">new_time_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_time_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">ts</span><span class="p">:</span> <span class="n">ts</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_time_index</span><span class="o">.</span><span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_time_index</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">new_time_index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.diff"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.diff">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">diff</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">periods</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">dropna</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with differenced values.</span>

<span class="sd">        This is often used to make a time series stationary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n</span>
<span class="sd">            Optionally, a positive integer indicating the number of differencing steps (default = 1).</span>
<span class="sd">            For instance, n=2 computes the second order differences.</span>
<span class="sd">        periods</span>
<span class="sd">            Optionally, periods to shift for calculating difference. For instance, periods=12 computes the</span>
<span class="sd">            difference between values at time `t` and times `t-12`.</span>
<span class="sd">        dropna</span>
<span class="sd">            Whether to drop the missing values after each differencing steps. If set to `False`, the corresponding</span>
<span class="sd">            first `periods` time steps will be filled with NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series, with the differenced values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;n&#39; must be a positive integer &gt;= 1.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">periods</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;periods&#39; must be an integer &gt;= 1.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_compute_diff</span><span class="p">(</span><span class="n">values_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">times_</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dropna</span><span class="p">:</span>
                <span class="c1"># In this case the new DataArray will have the same size and filled with NaNs</span>
                <span class="n">values_diff</span> <span class="o">=</span> <span class="n">values_</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">values_diff</span><span class="p">[:</span><span class="n">periods</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">values_diff</span><span class="p">[</span><span class="n">periods</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">values_</span><span class="p">[</span><span class="n">periods</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">values_</span><span class="p">[:</span><span class="o">-</span><span class="n">periods</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># In this case the new DataArray will be shorter</span>
                <span class="n">times_</span> <span class="o">=</span> <span class="n">times_</span><span class="p">[</span><span class="n">periods</span><span class="p">:]</span>
                <span class="n">values_diff</span> <span class="o">=</span> <span class="n">values_</span><span class="p">[</span><span class="n">periods</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">values_diff</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">values_</span><span class="p">[</span><span class="n">periods</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">values_</span><span class="p">[:</span><span class="o">-</span><span class="n">periods</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">return</span> <span class="n">values_diff</span><span class="p">,</span> <span class="n">times_</span>

        <span class="n">values</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">_compute_diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">values</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">_compute_diff</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">times</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.cumsum"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.cumsum">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with the cumulative sum along the time axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series, with the cumulatively summed values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.has_same_time_as"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.has_same_time_as">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">has_same_time_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the series has the same time index as the `other` series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            the other series</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            `True` if both series have the same index, `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">freq</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="TimeSeries.append"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.append">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with the `other` series appended to this series along the time axis (added to the end).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            A second TimeSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series, obtained by appending the second series to the first.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.concatenate : concatenate another series along a given axis.</span>
<span class="sd">        TimeSeries.prepend : prepend another series along the time axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">has_datetime_index</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_datetime_index</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Both series must have the same type of time index (either DatetimeIndex or RangeIndex).&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">freq</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both series must have the same frequency.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">n_components</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both series must have the same number of components.&quot;</span><span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both series must have the same number of samples.&quot;</span><span class="p">),</span> <span class="n">logger</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Appended TimeSeries must start one (time) step after current one.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_time_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.append_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.append_values">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">append_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with `values` appended to this series along the time axis (added to the end).</span>

<span class="sd">        This adds time steps to the end of the new series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values</span>
<span class="sd">            An array with the values to append.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with the new values appended.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.prepend_values : prepend the values of another series along the time axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">values</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">expand_arr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">DIMS</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The (expanded) values must have the same number of components and samples &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(second and third dims) as the series to append to. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Received shape: </span><span class="si">{</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, expected: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">generate_index</span><span class="p">(</span>
            <span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span>
            <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.prepend"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.prepend">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">prepend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with the `other` series prepended to this series along the time axis (added to the</span>
<span class="sd">        beginning).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            A second TimeSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series, obtained by prepending the second series to the first.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.concatenate : concatenate another series along a given axis.</span>
<span class="sd">        TimeSeries.append : append another series along the time axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;`other` to prepend must be a </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> object.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.prepend_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.prepend_values">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">prepend_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with `values` prepended to this series along the time axis (added to the beginning).</span>

<span class="sd">        This adds time steps to the beginning of the new series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values</span>
<span class="sd">            An array with the values to prepend to the start.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with the new values prepended.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.append_values : append the values of another series along the time axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">values</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">expand_arr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">DIMS</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The (expanded) values must have the same number of components and samples &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(second and third dims) as the series to prepend to. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Received shape: </span><span class="si">{</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, expected: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">generate_index</span><span class="p">(</span>
            <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span>
            <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepend</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="n">times</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span>
                <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
                <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.with_times_and_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.with_times_and_values">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">with_times_and_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">times</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">],</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fillna_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series similar to this one but with new `times` and `values`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times</span>
<span class="sd">            A pandas DateTimeIndex, RangeIndex (or Index that can be converted to a RangeIndex) representing the new</span>
<span class="sd">            time axis for the time series. It is better if the index has no holes; alternatively setting</span>
<span class="sd">            `fill_missing_dates` can in some cases solve these issues (filling holes with NaN, or with the provided</span>
<span class="sd">            `fillna_value` numeric value, if any).</span>
<span class="sd">        values</span>
<span class="sd">            A Numpy array with new values. It must have the dimensions for `times` and components, but may contain a</span>
<span class="sd">            different number of samples.</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates (or indices in case of integer index)</span>
<span class="sd">            with NaN values. This requires either a provided `freq` or the possibility to infer the frequency from the</span>
<span class="sd">            provided timestamps. See :meth:`_fill_missing_dates() &lt;TimeSeries._fill_missing_dates&gt;` for more info.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string or integer representing the frequency of the underlying index. This is useful in order</span>
<span class="sd">            to fill in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>
<span class="sd">            If a string, represents the frequency of the pandas DatetimeIndex (see `offset aliases</span>
<span class="sd">            &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_ for more info on</span>
<span class="sd">            supported frequencies).</span>
<span class="sd">            If an integer, represents the step size of the pandas Index or pandas RangeIndex.</span>
<span class="sd">        fillna_value</span>
<span class="sd">            Optionally, a numeric value to fill missing values (NaNs) with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with the new time index and values but identical static covariates and hierarchy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">values</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">expand_arr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">DIMS</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The new values must have the same number of components as the present series. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Received: </span><span class="si">{</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, expected: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
            <span class="n">fill_missing_dates</span><span class="o">=</span><span class="n">fill_missing_dates</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="n">fillna_value</span><span class="o">=</span><span class="n">fillna_value</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.with_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.with_values">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">with_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series similar to this one but with new `values`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values</span>
<span class="sd">            A Numpy array with new values. It must have the dimensions for time</span>
<span class="sd">            and components, but may contain a different number of samples.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with the new values but same index, static covariates and hierarchy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">values</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">expand_arr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">DIMS</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The new values must have the same shape (time, components) as the present series. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Received: </span><span class="si">{</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">, expected: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.with_static_covariates"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.with_static_covariates">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">with_static_covariates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with added static covariates.</span>

<span class="sd">        Static covariates hold information / data about the time series which does not vary over time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        covariates</span>
<span class="sd">            Optionally, a set of static covariates to be added to the TimeSeries. Either a pandas Series, a pandas</span>
<span class="sd">            DataFrame, or `None`. If `None`, will set the static covariates to `None`. If a Series, the index</span>
<span class="sd">            represents the static variables. The covariates are then globally &#39;applied&#39; to all components of the</span>
<span class="sd">            TimeSeries. If a DataFrame, the columns represent the static variables and the rows represent the</span>
<span class="sd">            components of the uni/multivariate TimeSeries. If a single-row DataFrame, the covariates are globally</span>
<span class="sd">            &#39;applied&#39; to all components of the TimeSeries. If a multi-row DataFrame, the number of rows must match the</span>
<span class="sd">            number of components of the TimeSeries. This adds component-specific static covariates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with the given static covariates.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If there are a large number of static covariates variables (i.e., the static covariates have a very large</span>
<span class="sd">        dimension), there might be a noticeable performance penalty for creating ``TimeSeries``, unless the covariates</span>
<span class="sd">        already have the same ``dtype`` as the series data.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; from darts.utils.timeseries_generation import linear_timeseries</span>
<span class="sd">        &gt;&gt;&gt; # add global static covariates</span>
<span class="sd">        &gt;&gt;&gt; static_covs = pd.Series([0., 1.], index=[&quot;static_cov_1&quot;, &quot;static_cov_2&quot;])</span>
<span class="sd">        &gt;&gt;&gt; series = linear_timeseries(length=3)</span>
<span class="sd">        &gt;&gt;&gt; series_new1 = series.with_static_covariates(static_covs)</span>
<span class="sd">        &gt;&gt;&gt; series_new1.static_covariates</span>
<span class="sd">                           static_cov_1  static_cov_2</span>
<span class="sd">        component</span>
<span class="sd">        linear              0.0           1.0</span>

<span class="sd">        &gt;&gt;&gt; # add component specific static covariates</span>
<span class="sd">        &gt;&gt;&gt; static_covs_multi = pd.DataFrame([[0., 1.], [2., 3.]], columns=[&quot;static_cov_1&quot;, &quot;static_cov_2&quot;])</span>
<span class="sd">        &gt;&gt;&gt; series_multi = series.stack(series)</span>
<span class="sd">        &gt;&gt;&gt; series_new2 = series_multi.with_static_covariates(static_covs_multi)</span>
<span class="sd">        &gt;&gt;&gt; series_new2.static_covariates</span>
<span class="sd">                           static_cov_1  static_cov_2</span>
<span class="sd">        component</span>
<span class="sd">        linear              0.0           1.0</span>
<span class="sd">        linear_1            2.0           3.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="n">covariates</span><span class="p">,</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.with_hierarchy"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.with_hierarchy">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">with_hierarchy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hierarchy</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with added hierarchy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hierarchy</span>
<span class="sd">            A dictionary mapping components to a list of their parent(s) in the hierarchy.</span>
<span class="sd">            Single parents may be specified as string or list containing one string.</span>
<span class="sd">            For example, assume the series contains the components</span>
<span class="sd">            ``[&quot;total&quot;, &quot;a&quot;, &quot;b&quot;, &quot;x&quot;, &quot;y&quot;, &quot;ax&quot;, &quot;ay&quot;, &quot;bx&quot;, &quot;by&quot;]``,</span>
<span class="sd">            the following dictionary would encode the groupings shown on</span>
<span class="sd">            `this figure &lt;https://otexts.com/fpp3/hts.html#fig:GroupTree&gt;`_:</span>

<span class="sd">            .. highlight:: python</span>
<span class="sd">            .. code-block:: python</span>

<span class="sd">                hierarchy = {&#39;ax&#39;: [&#39;a&#39;, &#39;x&#39;],</span>
<span class="sd">                             &#39;ay&#39;: [&#39;a&#39;, &#39;y&#39;],</span>
<span class="sd">                             &#39;bx&#39;: [&#39;b&#39;, &#39;x&#39;],</span>
<span class="sd">                             &#39;by&#39;: [&#39;b&#39;, &#39;y&#39;],</span>
<span class="sd">                             &#39;a&#39;: [&#39;total&#39;],</span>
<span class="sd">                             &#39;b&#39;: [&#39;total&#39;],</span>
<span class="sd">                             &#39;x&#39;: &#39;total&#39;,  # or use a single string</span>
<span class="sd">                             &#39;y&#39;: &#39;total&#39;}</span>
<span class="sd">            ..</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with the given hierarchy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="n">hierarchy</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.with_metadata"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.with_metadata">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">with_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with added metadata.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        metadata</span>
<span class="sd">            A dictionary with metadata to be added to the TimeSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with the given metadata.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from darts.utils.timeseries_generation import linear_timeseries</span>
<span class="sd">        &gt;&gt;&gt; series = linear_timeseries(length=3)</span>
<span class="sd">        &gt;&gt;&gt; # add metadata</span>
<span class="sd">        &gt;&gt;&gt; metadata = {&#39;name&#39;: &#39;my_series&#39;}</span>
<span class="sd">        &gt;&gt;&gt; series = series.with_metadata(metadata)</span>
<span class="sd">        &gt;&gt;&gt; series.metadata</span>
<span class="sd">        {&#39;name&#39;: &#39;my_series&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.stack"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.stack">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with the `other` series stacked to this series along the component axis.</span>

<span class="sd">        The resulting TimeSeries will have the same name for its time dimension as this TimeSeries, and the</span>
<span class="sd">        same number of samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            A TimeSeries instance with the same index and the same number of samples as the current one.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with the components of the other series added to the original.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.drop_columns"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.drop_columns">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">drop_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with dropped components (columns).</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------</span>
<span class="sd">        col_names</span>
<span class="sd">            String or list of strings corresponding to the columns to be dropped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with the specified columns dropped.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">col_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_names</span><span class="p">]</span>

        <span class="n">comp_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="n">comp_list</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">col_names</span><span class="p">]):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Some column names in `col_names` don&#39;t exist in the time series.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comp_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">col_names</span><span class="p">:</span>
                <span class="n">indexer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[:,</span> <span class="n">indexer</span><span class="p">],</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="n">indexer</span><span class="p">],</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="kc">None</span>
            <span class="p">),</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.univariate_component"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.univariate_component">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">univariate_component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new univariate series with a selected component.</span>

<span class="sd">        This drops the hierarchy (if any), and retains only the relevant static covariates column.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index</span>
<span class="sd">            If a string, the name of the component to retrieve. If an integer, the positional index of the component.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with a selected component.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span></div>

<div class="viewcode-block" id="TimeSeries.add_datetime_attribute"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.add_datetime_attribute">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">add_datetime_attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">,</span>
        <span class="n">one_hot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cyclic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">tz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with one (or more) additional component(s) that contain an attribute of the series&#39; time</span>
<span class="sd">        index.</span>

<span class="sd">        The additional components are specified with `attribute`, such as &#39;weekday&#39;, &#39;day&#39; or &#39;month&#39;.</span>

<span class="sd">        This works only for deterministic time series (i.e., made of 1 sample).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        0-indexing is enforced across all the encodings, see</span>
<span class="sd">        :meth:`datetime_attribute_timeseries() &lt;darts.utils.timeseries_generation.datetime_attribute_timeseries&gt;`</span>
<span class="sd">        for more information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attribute</span>
<span class="sd">            A pandas.DatatimeIndex attribute which will serve as the basis of the new column(s).</span>
<span class="sd">        one_hot</span>
<span class="sd">            Boolean value indicating whether to add the specified attribute as a one hot encoding</span>
<span class="sd">            (results in more columns).</span>
<span class="sd">        cyclic</span>
<span class="sd">            Boolean value indicating whether to add the specified attribute as a cyclic encoding.</span>
<span class="sd">            Alternative to one_hot encoding, enable only one of the two.</span>
<span class="sd">            (adds 2 columns, corresponding to sin and cos transformation).</span>
<span class="sd">        tz</span>
<span class="sd">            Optionally, a time zone to convert the time index to before computing the attributes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with an added datetime attribute component(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">darts.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">timeseries_generation</span> <span class="k">as</span> <span class="n">tg</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="n">tg</span><span class="o">.</span><span class="n">datetime_attribute_timeseries</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">,</span>
                <span class="n">attribute</span><span class="o">=</span><span class="n">attribute</span><span class="p">,</span>
                <span class="n">one_hot</span><span class="o">=</span><span class="n">one_hot</span><span class="p">,</span>
                <span class="n">cyclic</span><span class="o">=</span><span class="n">cyclic</span><span class="p">,</span>
                <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.add_holidays"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.add_holidays">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">add_holidays</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">country_code</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">prov</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">state</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with an added holiday component.</span>

<span class="sd">        The holiday component is binary where `1` corresponds to a time step falling on a holiday.</span>

<span class="sd">        Available countries can be found `here &lt;https://github.com/dr-prodigy/python-holidays#available-countries&gt;`_.</span>

<span class="sd">        This works only for deterministic time series (i.e., made of 1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        country_code</span>
<span class="sd">            The country ISO code</span>
<span class="sd">        prov</span>
<span class="sd">            The province</span>
<span class="sd">        state</span>
<span class="sd">            The state</span>
<span class="sd">        tz</span>
<span class="sd">            Optionally, a time zone to convert the time index to before computing the attributes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with an added holiday component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">darts.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">timeseries_generation</span> <span class="k">as</span> <span class="n">tg</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="n">tg</span><span class="o">.</span><span class="n">holidays_timeseries</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">,</span>
                <span class="n">country_code</span><span class="o">=</span><span class="n">country_code</span><span class="p">,</span>
                <span class="n">prov</span><span class="o">=</span><span class="n">prov</span><span class="p">,</span>
                <span class="n">state</span><span class="o">=</span><span class="n">state</span><span class="p">,</span>
                <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.resample"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.resample">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">resample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">],</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pad&quot;</span><span class="p">,</span>
        <span class="n">method_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series where the time index and values were resampled with a given frequency.</span>

<span class="sd">        The provided `method` is used to aggregate/fill holes in the resampled series, by default &#39;pad&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq</span>
<span class="sd">            The new time difference between two adjacent entries in the returned TimeSeries.</span>
<span class="sd">            Expects a `pandas.DateOffset` or `DateOffset` alias.</span>
<span class="sd">        method</span>
<span class="sd">            A method to either aggregate grouped values (for down-sampling) or fill holes (for up-sampling)</span>
<span class="sd">            in the reindexed TimeSeries. For more information, see the `xarray DataArrayResample documentation</span>
<span class="sd">            &lt;https://docs.xarray.dev/en/stable/generated/xarray.core.resample.DataArrayResample.html&gt;`_.</span>
<span class="sd">            Supported methods: [&quot;all&quot;, &quot;any&quot;, &quot;asfreq&quot;, &quot;backfill&quot;, &quot;bfill&quot;, &quot;count&quot;, &quot;ffill&quot;, &quot;first&quot;, &quot;interpolate&quot;,</span>
<span class="sd">            &quot;last&quot;, &quot;max&quot;, &quot;mean&quot;, &quot;median&quot;, &quot;min&quot;, &quot;nearest&quot;, &quot;pad&quot;, &quot;prod&quot;, &quot;quantile&quot;, &quot;reduce&quot;, &quot;std&quot;, &quot;sum&quot;,</span>
<span class="sd">            &quot;var&quot;].</span>
<span class="sd">        method_kwargs</span>
<span class="sd">            Additional keyword arguments for the specified `method`. Some methods require additional arguments.</span>
<span class="sd">            Xarray&#39;s errors will be raised on invalid keyword arguments.</span>
<span class="sd">        kwargs</span>
<span class="sd">            some keyword arguments for the `xarray.resample` method, notably `offset` or `base` to indicate where</span>
<span class="sd">            to start the resampling and avoid nan at the first value of the resampled TimeSeries</span>
<span class="sd">            For more information, see the `xarray resample() documentation</span>
<span class="sd">            &lt;https://docs.xarray.dev/en/stable/generated/xarray.DataArray.resample.html&gt;`_.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A resampled series with given frequency.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; times = pd.date_range(start=pd.Timestamp(&quot;20200101233000&quot;), periods=6, freq=&quot;15min&quot;)</span>
<span class="sd">        &gt;&gt;&gt; pd_series = pd.Series(range(6), index=times)</span>
<span class="sd">        &gt;&gt;&gt; ts = TimeSeries.from_series(pd_series)</span>
<span class="sd">        &gt;&gt;&gt; print(ts.time_index)</span>
<span class="sd">        DatetimeIndex([&#39;2020-01-01 23:30:00&#39;, &#39;2020-01-01 23:45:00&#39;,</span>
<span class="sd">                       &#39;2020-01-02 00:00:00&#39;, &#39;2020-01-02 00:15:00&#39;,</span>
<span class="sd">                       &#39;2020-01-02 00:30:00&#39;, &#39;2020-01-02 00:45:00&#39;],</span>
<span class="sd">                       dtype=&#39;datetime64[ns]&#39;, name=&#39;time&#39;, freq=&#39;15T&#39;)</span>
<span class="sd">        &gt;&gt;&gt; resampled_nokwargs_ts = ts.resample(freq=&quot;1h&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(resampled_nokwargs_ts.time_index)</span>
<span class="sd">        DatetimeIndex([&#39;2020-01-01 23:00:00&#39;, &#39;2020-01-02 00:00:00&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, name=&#39;time&#39;, freq=&#39;H&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(resampled_nokwargs_ts.values())</span>
<span class="sd">        [[nan]</span>
<span class="sd">        [ 2.]]</span>
<span class="sd">        &gt;&gt;&gt; resampled_ts = ts.resample(freq=&quot;1h&quot;, offset=pd.Timedelta(&quot;30min&quot;))</span>
<span class="sd">        &gt;&gt;&gt; print(resampled_ts.time_index)</span>
<span class="sd">        DatetimeIndex([&#39;2020-01-01 23:30:00&#39;, &#39;2020-01-02 00:30:00&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, name=&#39;time&#39;, freq=&#39;H&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(resampled_ts.values())</span>
<span class="sd">        [[0.]</span>
<span class="sd">        [4.]]</span>
<span class="sd">        &gt;&gt;&gt; resampled_ts = ts.resample(freq=&quot;1h&quot;, offset=pd.Timedelta(&quot;30min&quot;))</span>
<span class="sd">        &gt;&gt;&gt; downsampled_mean_ts = ts.resample(freq=&quot;30min&quot;, method=&quot;mean&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(downsampled_mean_ts.values())</span>
<span class="sd">        [[0.5]</span>
<span class="sd">        [2.5]</span>
<span class="sd">        [4.5]]</span>
<span class="sd">        &gt;&gt;&gt; downsampled_reduce_ts = ts.resample(freq=&quot;30min&quot;, method=&quot;reduce&quot;, method_args={&quot;func&quot;: np.mean})</span>
<span class="sd">        &gt;&gt;&gt; print(downsampled_reduce_ts.values())</span>
<span class="sd">        [[0.5]</span>
<span class="sd">        [2.5]</span>
<span class="sd">        [4.5]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">method_kwargs</span> <span class="o">=</span> <span class="n">method_kwargs</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">):</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">freqstr</span>

        <span class="n">resample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span>
            <span class="n">indexer</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="n">freq</span><span class="p">},</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">SUPPORTED_RESAMPLE_METHODS</span><span class="p">:</span>
            <span class="n">applied_method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">xr</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">resample</span><span class="o">.</span><span class="n">DataArrayResample</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
            <span class="n">new_xa</span> <span class="o">=</span> <span class="n">applied_method</span><span class="p">(</span><span class="n">resample</span><span class="p">,</span> <span class="o">**</span><span class="n">method_kwargs</span><span class="p">)</span>

            <span class="c1"># Convert boolean to int as Timeseries must contain numeric values only</span>
            <span class="c1"># method: &quot;all&quot;, &quot;any&quot;</span>
            <span class="k">if</span> <span class="n">new_xa</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
                <span class="n">new_xa</span> <span class="o">=</span> <span class="n">new_xa</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">from_xarray</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.is_within_range"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.is_within_range">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">is_within_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the given timestamp or integer is within the time interval of the series.</span>

<span class="sd">        `ts` does not need to be an element of the series&#39; time index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ts</span>
<span class="sd">            The `pandas.Timestamp` (if indexed with DatetimeIndex) or integer (if indexed with RangeIndex) to check.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether `ts` is contained within the interval of this series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.map"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.map">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">],</span>
            <span class="n">Callable</span><span class="p">[[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">],</span>
        <span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>  <span class="c1"># noqa: E501</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with the function `fn` applied to the values of this series.</span>

<span class="sd">        If `fn` takes 1 argument it is simply applied on the values array of shape `(time, n_components, n_samples)`.</span>
<span class="sd">        If `fn` takes 2 arguments, it is applied repeatedly on the `(ts, value[ts])` tuples, where `ts` denotes a</span>
<span class="sd">        timestamp value, and `value[ts]` denotes the array of values at this timestamp, of shape</span>
<span class="sd">        `(n_components, n_samples)`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fn</span>
<span class="sd">            Either a function which takes a NumPy array and returns a NumPy array of same shape;</span>
<span class="sd">            e.g., `lambda x: x ** 2`, `lambda x: x / x.shape[0]` or `np.log`.</span>
<span class="sd">            It can also be a function which takes a timestamp and array, and returns a new array of same shape;</span>
<span class="sd">            e.g., `lambda ts, x: x / ts.days_in_month`.</span>
<span class="sd">            The type of `ts` is either `pandas.Timestamp` (if the series is indexed with a DatetimeIndex),</span>
<span class="sd">            or an integer otherwise (if the series is indexed with an RangeIndex).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with the function `fn` applied to the values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;fn should be callable&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ufunc</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fn</span><span class="o">.</span><span class="n">nin</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">fn</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">num_args</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">fn</span><span class="o">.</span><span class="n">nin</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">fn</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">num_args</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;fn must have either one or two arguments and return a single value&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">num_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;inspect.signature(fn) failed. Try wrapping fn in a lambda, e.g. lambda x: fn(x)&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">num_args</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># apply fn on values directly</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">num_args</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># map function uses timestamp f(timestamp, x)</span>
            <span class="c1"># go over shortest amount of iterations, either over time steps or components and samples</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_timesteps</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">:</span>
                <span class="n">new_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
                        <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_timesteps</span><span class="p">)</span>
                <span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span>
                            <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">)</span>
                        <span class="p">])</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">)</span>
                    <span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">new_vals</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fn must have either one or two arguments&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.window_transform"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.window_transform">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">window_transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">transforms</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">dict</span><span class="p">]],</span>
        <span class="n">treat_na</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">forecasting_safe</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">keep_non_transformed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">include_current</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">keep_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with the specified window transformations applied.</span>

<span class="sd">        Supports moving/rolling, expanding or exponentially weighted window transformations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        transforms</span>
<span class="sd">            A dictionary or a list of dictionaries.</span>
<span class="sd">            Each dictionary specifies a different window transform.</span>

<span class="sd">            The dictionaries can contain the following keys:</span>

<span class="sd">            :``&quot;function&quot;``: Mandatory. The name of one of the pandas builtin transformation functions,</span>
<span class="sd">                            or a callable function that can be applied to the input series.</span>
<span class="sd">                            Pandas&#39; functions can be found in the</span>
<span class="sd">                            `documentation &lt;https://pandas.pydata.org/docs/reference/window.html&gt;`_.</span>

<span class="sd">            :``&quot;mode&quot;``: Optional. The name of the pandas windowing mode on which the ``&quot;function&quot;`` is going to be</span>
<span class="sd">                        applied. The options are &quot;rolling&quot;, &quot;expanding&quot; and &quot;ewm&quot;.</span>
<span class="sd">                        If not provided, Darts defaults to &quot;expanding&quot;.</span>
<span class="sd">                        User defined functions can use either &quot;rolling&quot; or &quot;expanding&quot; modes.</span>
<span class="sd">                        More information on pandas windowing operations can be found in the `documentation</span>
<span class="sd">                        &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/window.html&gt;`_.</span>

<span class="sd">            :``&quot;components&quot;``: Optional. A string or list of strings specifying the TimeSeries components on which the</span>
<span class="sd">                               transformation should be applied. If not specified, the transformation will be</span>
<span class="sd">                               applied on all components.</span>

<span class="sd">            :``&quot;function_name&quot;``: Optional. A string specifying the function name referenced as part of</span>
<span class="sd">                                  the transformation output name. For example, given a user-provided function</span>
<span class="sd">                                  transformation on rolling window size of 5 on the component &quot;comp&quot;, the</span>
<span class="sd">                                  default transformation output name is &quot;rolling_udf_5_comp&quot; whereby &quot;udf&quot;</span>
<span class="sd">                                  refers to &quot;user defined function&quot;. If specified, the ``&quot;function_name&quot;`` will</span>
<span class="sd">                                  replace the default name &quot;udf&quot;. Similarly, the ``&quot;function_name&quot;`` will replace</span>
<span class="sd">                                  the name of the pandas builtin transformation function name in the output name.</span>

<span class="sd">            All other dictionary items provided will be treated as keyword arguments for the windowing mode</span>
<span class="sd">            (i.e., ``rolling/ewm/expanding``) or for the specific function</span>
<span class="sd">            in that mode (i.e., ``pandas.DataFrame.rolling.mean/std/max/min...`` or</span>
<span class="sd">            ``pandas.DataFrame.ewm.mean/std/sum``).</span>
<span class="sd">            This allows for more flexibility in configuring the transformation, by providing for</span>
<span class="sd">            example:</span>

<span class="sd">            * :``&quot;window&quot;``: Size of the moving window for the &quot;rolling&quot; mode.</span>
<span class="sd">                            If an integer, the fixed number of observations used for each window.</span>
<span class="sd">                            If an offset, the time period of each window with data type :class:`pandas.Timedelta`</span>
<span class="sd">                            representing a fixed duration.</span>
<span class="sd">            * :``&quot;min_periods&quot;``: The minimum number of observations in the window required to have a value (otherwise</span>
<span class="sd">                NaN). Darts reuses pandas defaults of 1 for &quot;rolling&quot; and &quot;expanding&quot; modes and of 0 for &quot;ewm&quot; mode.</span>
<span class="sd">            * :``&quot;win_type&quot;``: The type of weigthing to apply to the window elements.</span>
<span class="sd">                If provided, it should be one of `scipy.signal.windows</span>
<span class="sd">                &lt;https://docs.scipy.org/doc/scipy/reference/signal.windows.html#module-scipy.signal.windows&gt;`_.</span>
<span class="sd">            * :``&quot;center&quot;``: ``True``/``False`` to set the observation at the current timestep at the center of the</span>
<span class="sd">                window (when ``forecasting_safe`` is `True`, Darts enforces ``&quot;center&quot;`` to ``False``).</span>
<span class="sd">            * :``&quot;closed&quot;``: ``&quot;right&quot;``/``&quot;left&quot;``/``&quot;both&quot;``/``&quot;neither&quot;`` to specify whether the right,</span>
<span class="sd">                left or both ends of the window are included in the window, or neither of them.</span>
<span class="sd">                Darts defaults to pandas default of ``&quot;right&quot;``.</span>

<span class="sd">            More information on the available functions and their parameters can be found in the</span>
<span class="sd">            `Pandas documentation &lt;https://pandas.pydata.org/docs/reference/window.html&gt;`_.</span>

<span class="sd">            For user-provided functions, extra keyword arguments in the transformation dictionary are passed to the</span>
<span class="sd">            user-defined function.</span>
<span class="sd">            By default, Darts expects user-defined functions to receive numpy arrays as input.</span>
<span class="sd">            This can be modified by adding item ``&quot;raw&quot;: False`` in the transformation dictionary.</span>
<span class="sd">            It is expected that the function returns a single</span>
<span class="sd">            value for each window. Other possible configurations can be found in the</span>
<span class="sd">            `pandas.DataFrame.rolling().apply()</span>
<span class="sd">            documentation &lt;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.rolling.html&gt;`_</span>
<span class="sd">            and `pandas.DataFrame.expanding().apply()</span>
<span class="sd">            documentation &lt;https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.expanding.html&gt;`_.</span>

<span class="sd">        treat_na</span>
<span class="sd">            Specifies how to treat missing values that were added by the window transformations</span>
<span class="sd">            at the beginning of the resulting TimeSeries. By default, Darts will leave NaNs in the resulting TimeSeries.</span>
<span class="sd">            This parameter can be one of the following:</span>

<span class="sd">            * :``&quot;dropna&quot;``: to truncate the TimeSeries and drop rows containing missing values.</span>
<span class="sd">                If multiple columns contain different numbers of missing values, only the minimum number</span>
<span class="sd">                of rows is dropped. This operation might reduce the length of the resulting TimeSeries.</span>

<span class="sd">            * :``&quot;bfill&quot;`` or ``&quot;backfill&quot;``: to specify that NaNs should be filled with the last transformed</span>
<span class="sd">                and valid observation. If the original TimeSeries starts with NaNs, those are kept.</span>
<span class="sd">                When ``forecasting_safe`` is ``True``, this option returns an exception to avoid future observation</span>
<span class="sd">                contaminating the past.</span>

<span class="sd">            * :an integer or float: in which case NaNs will be filled with this value.</span>
<span class="sd">                All columns will be filled with the same provided value.</span>

<span class="sd">        forecasting_safe</span>
<span class="sd">            If True, Darts enforces that the resulting TimeSeries is safe to be used in forecasting models as target</span>
<span class="sd">            or as feature. The window transformation will not allow future values to be included in the computations</span>
<span class="sd">            at their corresponding current timestep. Default is ``True``.</span>
<span class="sd">            &quot;ewm&quot; and &quot;expanding&quot; modes are forecasting safe by default.</span>
<span class="sd">            &quot;rolling&quot; mode is forecasting safe if ``&quot;center&quot;: False`` is guaranteed.</span>

<span class="sd">        keep_non_transformed</span>
<span class="sd">            ``False`` to return the transformed components only, ``True`` to return all original components along</span>
<span class="sd">            the transformed ones. Default is ``False``. If the series has a hierarchy, must be set to ``False``.</span>

<span class="sd">        include_current</span>
<span class="sd">            ``True`` to include the current time step in the window, ``False`` to exclude it. Default is ``True``.</span>

<span class="sd">        keep_names</span>
<span class="sd">            Whether the transformed components should keep the original component names or. Must be set to ``False``</span>
<span class="sd">            if `keep_non_transformed = True` or the number of transformation is greater than 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            Returns a new series with the transformed components. If ``keep_non_transformed`` is ``True``,</span>
<span class="sd">            the series will contain the original non-transformed components along the transformed ones.</span>
<span class="sd">            If the input series is stochastic, all samples are identically transformed.</span>
<span class="sd">            The naming convention for the transformed components is as follows:</span>
<span class="sd">            [window_mode]_[function_name]_[window_size if provided]_[min_periods if not default]_[original_comp_name],</span>
<span class="sd">            e.g., rolling_sum_3_comp_0 (i.e., window_mode= rolling, function_name = sum, window_size=3,</span>
<span class="sd">            original_comp_name=comp_0) ;</span>
<span class="sd">            ewm_mean_comp_1 (i.e., window_mode= ewm, function_name = mean, original_comp_name=comp_1);</span>
<span class="sd">            expanding_sum_3_comp_2 (i.e., window_mode= expanding, function_name = sum, window_size=3,</span>
<span class="sd">            original_comp_name=comp_2). For user-defined functions, function_name = udf.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">VALID_BFILL_NA</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;bfill&quot;</span><span class="p">,</span> <span class="s2">&quot;backfill&quot;</span><span class="p">}</span>
        <span class="n">VALID_TREAT_NA</span> <span class="o">=</span> <span class="n">VALID_BFILL_NA</span><span class="o">.</span><span class="n">union</span><span class="p">({</span><span class="s2">&quot;dropna&quot;</span><span class="p">})</span>

        <span class="n">PD_WINDOW_OPERATIONS</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;rolling&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">rolling</span><span class="p">,</span>
            <span class="s2">&quot;expanding&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">expanding</span><span class="p">,</span>
            <span class="s2">&quot;ewm&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">ewm</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># helper function to read and format kwargs</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_get_kwargs</span><span class="p">(</span><span class="n">transformation</span><span class="p">,</span> <span class="n">forecasting_safe</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Builds the kwargs dictionary for the transformation function.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            transformation</span>
<span class="sd">                The transformation dictionary.</span>
<span class="sd">            builtins</span>
<span class="sd">                The built-in transformations read from the WindowTransformer class.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            dict, dict</span>
<span class="sd">                The kwargs dictionaries for both the function group and the specific function.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># take expanding as the default window operation if not specified, safer than rolling</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">transformation</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mode&quot;</span><span class="p">,</span> <span class="s2">&quot;expanding&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">PD_WINDOW_OPERATIONS</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Invalid window operation: &#39;</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&#39;. Must be one of </span><span class="si">{</span><span class="n">PD_WINDOW_OPERATIONS</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">window_mode</span> <span class="o">=</span> <span class="n">PD_WINDOW_OPERATIONS</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>

            <span class="c1"># minimum number of observations in window required to have a value (otherwise result in NaN)</span>
            <span class="k">if</span> <span class="s2">&quot;min_periods&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">transformation</span><span class="p">:</span>
                <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;min_periods&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;ewm&quot;</span> <span class="k">else</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;rolling&quot;</span><span class="p">:</span>
                <span class="c1"># pandas default for &#39;center&#39; is False, no need to set it explicitly</span>
                <span class="k">if</span> <span class="s2">&quot;center&quot;</span> <span class="ow">in</span> <span class="n">transformation</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">forecasting_safe</span><span class="p">:</span>
                        <span class="n">raise_log</span><span class="p">(</span>
                            <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s2">&quot;When `forecasting_safe` is True, `center` must be False.&quot;</span>
                            <span class="p">),</span>
                            <span class="n">logger</span><span class="p">,</span>
                        <span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">],</span> <span class="n">Callable</span><span class="p">):</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="s2">&quot;apply&quot;</span>
                <span class="n">udf</span> <span class="o">=</span> <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]</span>
                <span class="c1"># make sure that we provide a numpy array to the user function, &quot;raw&quot;: True</span>
                <span class="k">if</span> <span class="s2">&quot;raw&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">transformation</span><span class="p">:</span>
                    <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;raw&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Transformation function must be a string or a callable. &quot;</span>
                        <span class="s2">&quot;String can be the name of any function available for pandas window. &quot;</span>
                        <span class="s2">&quot;A list of those function can be found in the `documentation &quot;</span>
                        <span class="s2">&quot;&lt;https://pandas.pydata.org/pandas-docs/stable/reference/window.html&gt;`.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">available_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">transformation</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="p">{</span>
                <span class="s2">&quot;function&quot;</span><span class="p">,</span>
                <span class="s2">&quot;group&quot;</span><span class="p">,</span>
                <span class="s2">&quot;components&quot;</span><span class="p">,</span>
                <span class="s2">&quot;function_name&quot;</span><span class="p">,</span>
            <span class="p">}</span>

            <span class="n">window_mode_expected_args</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">window_mode</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">co_varnames</span><span class="p">)</span>
            <span class="n">window_mode_available_keys</span> <span class="o">=</span> <span class="n">window_mode_expected_args</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                <span class="n">available_keys</span>
            <span class="p">)</span>

            <span class="n">window_mode_available_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">transformation</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">window_mode_available_keys</span>
            <span class="p">}</span>

            <span class="n">available_keys</span> <span class="o">-=</span> <span class="n">window_mode_available_keys</span>

            <span class="n">function_expected_args</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="nb">getattr</span><span class="p">(</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(),</span> <span class="n">window_mode</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)(</span>
                        <span class="o">**</span><span class="n">window_mode_available_kwargs</span>
                    <span class="p">),</span>
                    <span class="n">fn</span><span class="p">,</span>
                <span class="p">)</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">co_varnames</span>
            <span class="p">)</span>

            <span class="n">function_available_keys</span> <span class="o">=</span> <span class="n">function_expected_args</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="n">available_keys</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">function_available_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">transformation</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">function_available_keys</span>
            <span class="p">}</span>

            <span class="n">available_keys</span> <span class="o">-=</span> <span class="n">function_available_keys</span>

            <span class="n">udf_expected_args</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">udf</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">co_varnames</span><span class="p">)</span> <span class="k">if</span> <span class="n">fn</span> <span class="o">==</span> <span class="s2">&quot;apply&quot;</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">udf_available_keys</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">udf_expected_args</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">available_keys</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">fn</span> <span class="o">==</span> <span class="s2">&quot;apply&quot;</span>
                <span class="k">else</span> <span class="kc">None</span>
            <span class="p">)</span>

            <span class="n">udf_kwargs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">transformation</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">udf_available_keys</span><span class="p">}</span>
                <span class="k">if</span> <span class="n">fn</span> <span class="o">==</span> <span class="s2">&quot;apply&quot;</span>
                <span class="k">else</span> <span class="kc">None</span>
            <span class="p">)</span>

            <span class="n">function_available_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="n">udf</span><span class="p">,</span> <span class="s2">&quot;kwargs&quot;</span><span class="p">:</span> <span class="n">udf_kwargs</span><span class="p">}</span> <span class="k">if</span> <span class="n">fn</span> <span class="o">==</span> <span class="s2">&quot;apply&quot;</span> <span class="k">else</span> <span class="p">{}</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">window_mode</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">window_mode_available_kwargs</span><span class="p">),</span> <span class="p">(</span>
                <span class="n">fn</span><span class="p">,</span>
                <span class="n">function_available_kwargs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># make sure we have a list in transforms</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transforms</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="n">transforms</span><span class="p">]</span>

        <span class="c1"># check if some transformations are applied to the same components</span>
        <span class="n">overlapping_transforms</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">transformed_components</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Every entry in `transforms` must be a dictionary&quot;</span><span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">tr_comps</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">tr</span><span class="p">[</span><span class="s2">&quot;components&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;components&quot;</span> <span class="ow">in</span> <span class="n">tr</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">transformed_components</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tr_comps</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">overlapping_transforms</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">transformed_components</span> <span class="o">=</span> <span class="n">transformed_components</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">tr_comps</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">keep_names</span> <span class="ow">and</span> <span class="n">overlapping_transforms</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot keep the original component names as some transforms are overlapping &quot;</span>
                    <span class="s2">&quot;(applied to the same components). Set `keep_names` to `False`.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># actually, this could be allowed to allow transformation &quot;in place&quot;?</span>
        <span class="c1"># keep_non_transformed can be changed to False/ignored if the transforms are not partial</span>
        <span class="k">if</span> <span class="n">keep_names</span> <span class="ow">and</span> <span class="n">keep_non_transformed</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;`keep_names = True` and `keep_non_transformed = True` cannot be used together.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">partial_transforms</span> <span class="o">=</span> <span class="n">transformed_components</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
        <span class="n">new_hierarchy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">convert_hierarchy</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">comp_names_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">:</span>
            <span class="c1"># the partial_transform covers for scenario keep_non_transformed = True</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">partial_transforms</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;The hierarchy cannot be retained, either because there is more than one transform or &quot;</span>
                    <span class="s2">&quot;because the transform is not applied to all the components of the series.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">convert_hierarchy</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">]):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;`transforms` must be a non-empty dictionary or a non-empty list of dictionaries.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># read series dataframe</span>
        <span class="n">ts_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># store some original attributes of the series</span>
        <span class="n">original_components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span>
        <span class="n">original_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span>

        <span class="n">resulting_transformations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">new_columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">added_na</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># run through all transformations in transforms</span>
        <span class="k">for</span> <span class="n">transformation</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;components&quot;</span> <span class="ow">in</span> <span class="n">transformation</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;components&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;components&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;components&quot;</span><span class="p">]]</span>
                <span class="n">comps_to_transform</span> <span class="o">=</span> <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;components&quot;</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">comps_to_transform</span> <span class="o">=</span> <span class="n">original_components</span>

            <span class="n">df_cols</span> <span class="o">=</span> <span class="n">ts_df</span><span class="o">.</span><span class="n">columns</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">:</span>
                <span class="n">filter_df_columns</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">df_col</span>
                    <span class="k">for</span> <span class="n">df_col</span> <span class="ow">in</span> <span class="n">df_cols</span>
                    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;_s.*$&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">df_col</span><span class="p">)</span> <span class="ow">in</span> <span class="n">comps_to_transform</span>
                <span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">filter_df_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">df_col</span> <span class="k">for</span> <span class="n">df_col</span> <span class="ow">in</span> <span class="n">comps_to_transform</span><span class="p">]</span>

            <span class="p">(</span><span class="n">window_mode</span><span class="p">,</span> <span class="n">window_mode_kwargs</span><span class="p">),</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">function_kwargs</span><span class="p">)</span> <span class="o">=</span> <span class="n">_get_kwargs</span><span class="p">(</span>
                <span class="n">transformation</span><span class="p">,</span> <span class="n">forecasting_safe</span>
            <span class="p">)</span>

            <span class="n">closed</span> <span class="o">=</span> <span class="n">transformation</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;closed&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">include_current</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">window_mode</span> <span class="o">==</span> <span class="s2">&quot;rolling&quot;</span><span class="p">:</span>
                    <span class="n">shifts</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">closed</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span> <span class="k">else</span> <span class="mi">1</span>  <span class="c1"># avoid shifting twice</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">shifts</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shifts</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">resulting_transformations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">resulting_transformations</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span>
                        <span class="nb">getattr</span><span class="p">(</span><span class="n">ts_df</span><span class="p">[</span><span class="n">filter_df_columns</span><span class="p">],</span> <span class="n">window_mode</span><span class="p">)(</span>
                            <span class="o">**</span><span class="n">window_mode_kwargs</span>
                        <span class="p">),</span>
                        <span class="n">fn</span><span class="p">,</span>
                    <span class="p">)(</span><span class="o">**</span><span class="n">function_kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="n">shifts</span><span class="p">),</span>
                <span class="p">],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">min_periods</span> <span class="o">=</span> <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;min_periods&quot;</span><span class="p">]</span>
            <span class="c1"># set new columns names</span>
            <span class="n">fn_name</span> <span class="o">=</span> <span class="n">transformation</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;function_name&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fn_name</span><span class="p">:</span>
                <span class="n">function_name</span> <span class="o">=</span> <span class="n">fn_name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">function_name</span> <span class="o">=</span> <span class="n">fn</span> <span class="k">if</span> <span class="n">fn</span> <span class="o">!=</span> <span class="s2">&quot;apply&quot;</span> <span class="k">else</span> <span class="s2">&quot;udf&quot;</span>
            <span class="n">name_prefix</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">window_mode</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">function_name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;_&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">str</span><span class="p">(</span><span class="n">transformation</span><span class="p">[</span><span class="s1">&#39;window&#39;</span><span class="p">])</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="s1">&#39;window&#39;</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">transformation</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;_&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">str</span><span class="p">(</span><span class="n">min_periods</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">min_periods</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">keep_names</span><span class="p">:</span>
                <span class="n">new_columns</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">comps_to_transform</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">names_w_prefix</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name_prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">comp_name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">comp_name</span> <span class="ow">in</span> <span class="n">comps_to_transform</span>
                <span class="p">]</span>
                <span class="n">new_columns</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">names_w_prefix</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">convert_hierarchy</span><span class="p">:</span>
                    <span class="n">comp_names_map</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                        <span class="n">c_name</span><span class="p">:</span> <span class="n">new_c_name</span>
                        <span class="k">for</span> <span class="n">c_name</span><span class="p">,</span> <span class="n">new_c_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                            <span class="n">comps_to_transform</span><span class="p">,</span> <span class="n">names_w_prefix</span>
                        <span class="p">)</span>
                    <span class="p">})</span>

            <span class="c1"># track how many NaN rows are added by each transformation on each transformed column</span>
            <span class="c1"># NaNs would appear only if user changes &quot;min_periods&quot; to else than 1, if not,</span>
            <span class="c1"># by default there should be no NaNs unless the original series starts with NaNs (those would be maintained)</span>
            <span class="n">total_na</span> <span class="o">=</span> <span class="n">min_periods</span> <span class="o">+</span> <span class="n">shifts</span> <span class="o">+</span> <span class="p">(</span><span class="n">closed</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>
            <span class="n">added_na</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span>
                <span class="n">total_na</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">min_periods</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">total_na</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">filter_df_columns</span>
            <span class="p">])</span>

        <span class="c1"># keep all original components</span>
        <span class="k">if</span> <span class="n">keep_non_transformed</span><span class="p">:</span>
            <span class="n">resulting_transformations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span><span class="n">resulting_transformations</span><span class="p">,</span> <span class="n">ts_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">new_columns</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">original_components</span><span class="p">)</span>

        <span class="c1"># Treat NaNs that were introduced by the transformations only</span>
        <span class="c1"># Default to leave NaNs</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">treat_na</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">treat_na</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">VALID_TREAT_NA</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;`treat_na` must be one of </span><span class="si">{</span><span class="n">VALID_TREAT_NA</span><span class="si">}</span><span class="s2"> or a scalar, but found </span><span class="si">{</span><span class="n">treat_na</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">treat_na</span> <span class="ow">in</span> <span class="n">VALID_BFILL_NA</span> <span class="ow">and</span> <span class="n">forecasting_safe</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;when `forecasting_safe` is True, back filling NaNs is not allowed as &quot;</span>
                        <span class="s2">&quot;it risks contaminating past time steps with future values.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">treat_na</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">treat_na</span> <span class="ow">in</span> <span class="n">VALID_BFILL_NA</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">added_na</span><span class="p">),</span> <span class="n">n_samples</span><span class="p">):</span>
                <span class="n">s_idx</span> <span class="o">=</span> <span class="n">added_na</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">n_samples</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">treat_na</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">treat_na</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
                    <span class="k">else</span> <span class="n">resulting_transformations</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">s_idx</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">n_samples</span><span class="p">)]</span>
                <span class="p">)</span>
                <span class="n">resulting_transformations</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">s_idx</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">n_samples</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">treat_na</span> <span class="o">==</span> <span class="s2">&quot;dropna&quot;</span><span class="p">:</span>
            <span class="c1"># can only drop the NaN rows that are common among the columns</span>
            <span class="n">drop_before_index</span> <span class="o">=</span> <span class="n">original_index</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">added_na</span><span class="p">)]</span>
            <span class="n">resulting_transformations</span> <span class="o">=</span> <span class="n">resulting_transformations</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                <span class="n">drop_before_index</span><span class="p">:</span>
            <span class="p">]</span>

        <span class="c1"># revert dataframe to TimeSeries</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="n">original_index</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">resulting_transformations</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">convert_hierarchy</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">keep_names</span><span class="p">:</span>
                <span class="n">new_hierarchy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_hierarchy</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">comp_names_map</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span> <span class="p">[</span><span class="n">comp_names_map</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span> <span class="k">for</span> <span class="n">old_name</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>

        <span class="n">transformed_time_series</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">new_index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">resulting_transformations</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">new_index</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_samples</span>
            <span class="p">),</span>
            <span class="n">components</span><span class="o">=</span><span class="n">new_columns</span><span class="p">,</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="n">new_hierarchy</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_time_series</span></div>

<div class="viewcode-block" id="TimeSeries.to_json"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.to_json">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a JSON string representation of the deterministic series.</span>

<span class="sd">        At the moment this function works only on deterministic time series (i.e., made of 1 sample).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Static covariates are not returned in the JSON string. When using `TimeSeries.from_json()`, the static</span>
<span class="sd">        covariates can be added with input argument `static_covariates`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            A JSON String representing the series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;split&quot;</span><span class="p">,</span> <span class="n">date_format</span><span class="o">=</span><span class="s2">&quot;iso&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.to_csv"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.to_csv">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">to_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write the deterministic series to a CSV file.</span>

<span class="sd">        For a list of parameters, refer to the documentation of :func:`pandas.DataFrame.to_csv()` [1]_.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_csv.html?highlight=to_csv</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Writing to csv is only supported for deterministic time series &quot;</span>
                    <span class="s2">&quot;(a series with only one sample per time and component).&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.to_pickle"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.to_pickle">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">to_pickle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">protocol</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save the series in pickle format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : string</span>
<span class="sd">            path to a file where current object will be pickled</span>
<span class="sd">        protocol : integer, default highest</span>
<span class="sd">            pickling protocol. The default is best in most cases, use it only if having backward compatibility issues</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fh</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">protocol</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.plot"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.plot">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">central_quantile</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">low_quantile</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
        <span class="n">high_quantile</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.95</span><span class="p">,</span>
        <span class="n">default_formatting</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">title</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">max_nr_components</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">c</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the series.</span>

<span class="sd">        This is a wrapper method around :func:`xarray.DataArray.plot()`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_plot</span>
<span class="sd">            Whether to spawn a new axis to plot on. See also parameter `ax`.</span>
<span class="sd">        central_quantile</span>
<span class="sd">            The quantile (between 0 and 1) to plot as a &quot;central&quot; value, if the series is stochastic (i.e., if</span>
<span class="sd">            it has multiple samples). This will be applied on each component separately (i.e., to display quantiles</span>
<span class="sd">            of the components&#39; marginal distributions). For instance, setting `central_quantile=0.5` will plot the</span>
<span class="sd">            median of each component. `central_quantile` can also be set to &#39;mean&#39;.</span>
<span class="sd">        low_quantile</span>
<span class="sd">            The quantile to use for the lower bound of the plotted confidence interval. Similar to `central_quantile`,</span>
<span class="sd">            this is applied to each component separately (i.e., displaying marginal distributions). No confidence</span>
<span class="sd">            interval is shown if `confidence_low_quantile` is None (default 0.05).</span>
<span class="sd">        high_quantile</span>
<span class="sd">            The quantile to use for the upper bound of the plotted confidence interval. Similar to `central_quantile`,</span>
<span class="sd">            this is applied to each component separately (i.e., displaying marginal distributions). No confidence</span>
<span class="sd">            interval is shown if `high_quantile` is None (default 0.95).</span>
<span class="sd">        default_formatting</span>
<span class="sd">            Whether to use the darts default scheme.</span>
<span class="sd">        title</span>
<span class="sd">            Optionally, a custom plot title. If `None`, will use the name of the underlying `xarray.DataArray`.</span>
<span class="sd">        label</span>
<span class="sd">            Can either be a string or list of strings. If a string and the series only has a single component, it is</span>
<span class="sd">            used as the label for that component. If a string and the series has multiple components, it is used as</span>
<span class="sd">            a prefix for each component name. If a list of strings with length equal to the number of components in</span>
<span class="sd">            the series, the labels will be mapped to the components in order.</span>
<span class="sd">        max_nr_components</span>
<span class="sd">            The maximum number of components of a series to plot. -1 means all components will be plotted.</span>
<span class="sd">        ax</span>
<span class="sd">            Optionally, an axis to plot on. If `None`, and `new_plot=False`, will use the current axis. If</span>
<span class="sd">            `new_plot=True`, will create a new axis.</span>
<span class="sd">        alpha</span>
<span class="sd">            Optionally, set the line alpha for deterministic series, or the confidence interval alpha for</span>
<span class="sd">            probabilistic series.</span>
<span class="sd">        color</span>
<span class="sd">            Can either be a single color or list of colors. Any matplotlib color is accepted (string, hex string,</span>
<span class="sd">            RGB/RGBA tuple). If a single color and the series only has a single component, it is used as the color</span>
<span class="sd">            for that component. If a single color and the series has multiple components, it is used as the color</span>
<span class="sd">            for each component. If a list of colors with length equal to the number of components in the series, the</span>
<span class="sd">            colors will be mapped to the components in order.</span>
<span class="sd">        c</span>
<span class="sd">            An alias for `color`.</span>
<span class="sd">        args</span>
<span class="sd">            some positional arguments for the `plot()` method</span>
<span class="sd">        kwargs</span>
<span class="sd">            some keyword arguments for the `plot()` method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matplotlib.axes.Axes</span>
<span class="sd">            Either the passed `ax` axis, a newly created one if `new_plot=True`, or the existing one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha_confidence_intvls</span> <span class="o">=</span> <span class="mf">0.25</span>

        <span class="k">if</span> <span class="n">central_quantile</span> <span class="o">!=</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">central_quantile</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">central_quantile</span> <span class="o">&lt;=</span> <span class="mf">1.0</span>
            <span class="p">):</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;central_quantile must be either &quot;mean&quot;, or a float between 0 and 1.&#39;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">high_quantile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">low_quantile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">low_quantile</span> <span class="o">&lt;=</span> <span class="mf">1.0</span> <span class="ow">and</span> <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">high_quantile</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">):</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;confidence interval low and high quantiles must be between 0 and 1.&quot;</span><span class="p">,</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">max_nr_components</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">n_components_to_plot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_components_to_plot</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> <span class="n">max_nr_components</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">&gt;</span> <span class="n">n_components_to_plot</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Number of series components (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="si">}</span><span class="s2">) is larger than the maximum number of &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;components to plot (</span><span class="si">{</span><span class="n">max_nr_components</span><span class="si">}</span><span class="s2">). Plotting only the first `</span><span class="si">{</span><span class="n">max_nr_components</span><span class="si">}</span><span class="s2">` &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;components. You can adjust the number of components to plot using `max_nr_components`.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_components_to_plot</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The `label` sequence must have the same length as the number of series components &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="si">}</span><span class="s2">) or as the number of plotted components (</span><span class="si">{</span><span class="n">n_components_to_plot</span><span class="si">}</span><span class="s2">). &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Received length `</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="si">}</span><span class="s2">`.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">custom_labels</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">custom_labels</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">color</span> <span class="ow">and</span> <span class="n">c</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;`color` and `c` must not be used simultaneously, use one or the other.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">color</span> <span class="ow">or</span> <span class="n">c</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_components_to_plot</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The `color` sequence must have the same length as the number of series components &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="si">}</span><span class="s2">) or as the number of plotted components (</span><span class="si">{</span><span class="n">n_components_to_plot</span><span class="si">}</span><span class="s2">). &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Received length `</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="si">}</span><span class="s2">`.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">custom_colors</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">custom_colors</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;alpha&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">lw</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">for</span> <span class="n">lw</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;lw&quot;</span><span class="p">,</span> <span class="s2">&quot;linewidth&quot;</span><span class="p">]):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;lw&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">new_plot</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="c1"># TODO: migrate from xarray plotting to something else</span>
        <span class="n">data_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_array</span><span class="o">.</span><span class="n">component</span><span class="p">[:</span><span class="n">n_components_to_plot</span><span class="p">]):</span>
            <span class="n">comp_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="n">data_array</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">component</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">central_quantile</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
                    <span class="n">central_series</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">central_series</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">central_quantile</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">central_series</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">custom_labels</span><span class="p">:</span>
                <span class="n">label_to_use</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="n">label_to_use</span> <span class="o">=</span> <span class="n">comp_name</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">label_to_use</span> <span class="o">=</span> <span class="n">label</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">label_to_use</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">comp_name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">label_to_use</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">custom_colors</span> <span class="k">else</span> <span class="n">color</span>

            <span class="n">kwargs_central</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">:</span>
                <span class="n">kwargs_central</span><span class="p">[</span><span class="s2">&quot;alpha&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">central_series</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">central_series</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_central</span><span class="p">)</span>
            <span class="c1"># empty TimeSeries</span>
            <span class="k">elif</span> <span class="n">central_series</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                    <span class="p">[],</span>
                    <span class="p">[],</span>
                    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs_central</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">()],</span>
                    <span class="n">central_series</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;o&quot;</span><span class="p">,</span>
                    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs_central</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_dim</span><span class="p">)</span>
            <span class="n">color_used</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_color</span><span class="p">()</span> <span class="k">if</span> <span class="n">default_formatting</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="c1"># Optionally show confidence intervals</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">comp</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="n">low_quantile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="n">high_quantile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="n">low_series</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">low_quantile</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">high_series</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">high_quantile</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">low_series</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">,</span>
                        <span class="n">low_series</span><span class="p">,</span>
                        <span class="n">high_series</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">color_used</span><span class="p">,</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="p">(</span><span class="n">alpha</span> <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">alpha_confidence_intvls</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">()],</span>
                        <span class="p">[</span><span class="n">low_series</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high_series</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="s2">&quot;-+&quot;</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">color_used</span><span class="p">,</span>
                        <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span> <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">data_array</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="TimeSeries.with_columns_renamed"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.with_columns_renamed">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">with_columns_renamed</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">col_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">],</span> <span class="n">col_names_new</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with new columns/components names.</span>

<span class="sd">        It also adapts the names in the hierarchy, if any.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------</span>
<span class="sd">        col_names</span>
<span class="sd">            String or list of strings corresponding the the column names to be changed.</span>
<span class="sd">        col_names_new</span>
<span class="sd">            String or list of strings corresponding to the new column names. Must be the same length as col_names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with renamed columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">col_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col_names_new</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">col_names_new</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_names_new</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([(</span><span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">to_list</span><span class="p">())</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">col_names</span><span class="p">]):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Some column names in col_names don&#39;t exist in the time series.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_names_new</span><span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Length of col_names_new list should be equal to the length of col_names list.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">old2new</span> <span class="o">=</span> <span class="p">{</span><span class="n">old</span><span class="p">:</span> <span class="n">new</span> <span class="k">for</span> <span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">col_names</span><span class="p">,</span> <span class="n">col_names_new</span><span class="p">)}</span>

        <span class="c1"># update component names</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">old2new</span><span class="p">[</span><span class="n">old</span><span class="p">]</span> <span class="k">if</span> <span class="n">old</span> <span class="ow">in</span> <span class="n">old2new</span> <span class="k">else</span> <span class="n">old</span> <span class="k">for</span> <span class="n">old</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">]</span>

        <span class="c1"># update hierarchy names</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hierarchy</span> <span class="o">=</span> <span class="p">{</span>
                <span class="p">(</span><span class="n">old2new</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">old2new</span> <span class="k">else</span> <span class="n">key</span><span class="p">):</span> <span class="p">[</span>
                    <span class="n">old2new</span><span class="p">[</span><span class="n">old</span><span class="p">]</span> <span class="k">if</span> <span class="n">old</span> <span class="ow">in</span> <span class="n">old2new</span> <span class="k">else</span> <span class="n">old</span>
                    <span class="k">for</span> <span class="n">old</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hierarchy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cols</span><span class="p">),</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="n">hierarchy</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple statistic and aggregation functions. Calculate various statistics over the samples of stochastic time series</span>
<span class="sd">    or aggregate over components/time for deterministic series.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TimeSeries.mean"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.mean">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with the mean computed over the specified `axis`.</span>

<span class="sd">        If we reduce over time (``axis=0``), the series will have length one and will use the first entry of the</span>
<span class="sd">        original ``time_index``. If we perform the calculation over the components (``axis=1``), the resulting single</span>
<span class="sd">        component will be renamed to &quot;components_mean&quot;.  When applied to the samples (``axis=2``), a deterministic</span>
<span class="sd">        series is returned.</span>

<span class="sd">        If ``axis=1``, the static covariates and the hierarchy are discarded from the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis</span>
<span class="sd">            The axis to reduce over. The default is to calculate over samples, i.e. axis=2.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with mean applied to the indicated axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">times</span><span class="p">,</span> <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_agg_dims</span><span class="p">(</span><span class="s2">&quot;components_mean&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
            <span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.median"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.median">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">median</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with the median computed over the specified `axis`.</span>

<span class="sd">        If we reduce over time (``axis=0``), the series will have length one and will use the first entry of the</span>
<span class="sd">        original ``time_index``. If we perform the calculation over the components (``axis=1``), the resulting single</span>
<span class="sd">        component will be renamed to &quot;components_median&quot;.  When applied to the samples (``axis=2``), a deterministic</span>
<span class="sd">        series is returned.</span>

<span class="sd">        If ``axis=1``, the static covariates and the hierarchy are discarded from the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis</span>
<span class="sd">            The axis to reduce over. The default is to calculate over samples, i.e. axis=2.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with median applied to the indicated axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">times</span><span class="p">,</span> <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_agg_dims</span><span class="p">(</span><span class="s2">&quot;components_median&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
            <span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.sum"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.sum">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with the sum computed over the specified `axis`.</span>

<span class="sd">        If we reduce over time (``axis=0``), the series will have length one and will use the first entry of the</span>
<span class="sd">        original ``time_index``. If we perform the calculation over the components (``axis=1``), the resulting single</span>
<span class="sd">        component will be renamed to &quot;components_sum&quot;.  When applied to the samples (``axis=2``), a deterministic</span>
<span class="sd">        series is returned.</span>

<span class="sd">        If ``axis=1``, the static covariates and the hierarchy are discarded from the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis</span>
<span class="sd">            The axis to reduce over. The default is to calculate over samples, i.e. axis=2.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with sum applied to the indicated axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">times</span><span class="p">,</span> <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_agg_dims</span><span class="p">(</span><span class="s2">&quot;components_sum&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
            <span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.min"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.min">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with the minimum computed over the specified `axis`.</span>

<span class="sd">        If we reduce over time (``axis=0``), the series will have length one and will use the first entry of the</span>
<span class="sd">        original ``time_index``. If we perform the calculation over the components (``axis=1``), the resulting single</span>
<span class="sd">        component will be renamed to &quot;components_min&quot;.  When applied to the samples (``axis=2``), a deterministic</span>
<span class="sd">        series is returned.</span>

<span class="sd">        If ``axis=1``, the static covariates and the hierarchy are discarded from the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis</span>
<span class="sd">            The axis to reduce over. The default is to calculate over samples, i.e. axis=2.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with min applied to the indicated axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">times</span><span class="p">,</span> <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_agg_dims</span><span class="p">(</span><span class="s2">&quot;components_min&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
            <span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.max"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.max">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with the maximum computed over the specified `axis`.</span>

<span class="sd">        If we reduce over time (``axis=0``), the series will have length one and will use the first entry of the</span>
<span class="sd">        original ``time_index``. If we perform the calculation over the components (``axis=1``), the resulting single</span>
<span class="sd">        component will be renamed to &quot;components_max&quot;.  When applied to the samples (``axis=2``), a deterministic</span>
<span class="sd">        series is returned.</span>

<span class="sd">        If ``axis=1``, the static covariates and the hierarchy are discarded from the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis</span>
<span class="sd">            The axis to reduce over. The default is to calculate over samples, i.e. axis=2.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series with max applied to the indicated axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">times</span><span class="p">,</span> <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_agg_dims</span><span class="p">(</span><span class="s2">&quot;components_max&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
            <span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.quantile"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.quantile">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">quantile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a deterministic series with the desired quantile(s) `q` of each component computed over the samples</span>
<span class="sd">        of the stochastic series.</span>

<span class="sd">        The component quantiles in the new series are named &quot;&lt;component&gt;_q&lt;quantile&gt;&quot;, where &quot;&lt;component&gt;&quot; is the</span>
<span class="sd">        column name, and &quot;&lt;quantile&gt;&quot; is the quantile value.</span>

<span class="sd">        The order of the component quantiles is: `[&lt;c_1&gt;_q&lt;q_1&gt;, ... &lt;c_1&gt;_q&lt;q_2&gt;, ..., &lt;c_n&gt;_q&lt;q_n&gt;]`.</span>

<span class="sd">        This works only on stochastic series (i.e., with more than 1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q</span>
<span class="sd">            The desired quantile value or sequence of quantile values. Each value must be between 0. and 1. inclusive.</span>
<span class="sd">            For instance, `0.5` will return a TimeSeries containing the median of the (marginal) distribution of each</span>
<span class="sd">            component.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Other keyword arguments are passed down to `numpy.quantile()`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series containing the desired quantile(s) of each component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_stochastic</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">q_i</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">q_i</span> <span class="ow">in</span> <span class="n">q</span><span class="p">]):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The quantile values must be expressed as fraction (between 0 and 1 inclusive).&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># component names</span>
        <span class="n">cnames</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_q</span><span class="si">{</span><span class="n">q_i</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="k">for</span> <span class="n">q_i</span> <span class="ow">in</span> <span class="n">q</span><span class="p">]</span>

        <span class="c1"># get quantiles of shape (n quantiles, n times, n components)</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># transpose and reshape into (n times, n components * n quantiles, 1)</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">cnames</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># only add static covariates and hierarchy if the number of output components matches the input components</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">new_data</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">cnames</span><span class="p">,</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.var"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.var">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ddof</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a deterministic series with the variance of each component computed over the samples of the</span>
<span class="sd">        stochastic series.</span>

<span class="sd">        This works only on stochastic series (i.e., with more than 1 sample)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ddof</span>
<span class="sd">            &quot;Delta Degrees of Freedom&quot;: the divisor used in the calculation is N - ddof where N represents the</span>
<span class="sd">            number of elements. By default, ddof is 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series containing the variance of each component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_stochastic</span><span class="p">()</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_values</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.std"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.std">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ddof</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a deterministic series with the standard deviation of each component computed over the samples of the</span>
<span class="sd">        stochastic series.</span>

<span class="sd">        This works only on stochastic series (i.e., with more than 1 sample)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ddof</span>
<span class="sd">            &quot;Delta Degrees of Freedom&quot;: the divisor used in the calculation is N - ddof where N represents the</span>
<span class="sd">            number of elements. By default, ddof is 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series containing the standard deviation of each component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_stochastic</span><span class="p">()</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_values</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.skew"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.skew">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">skew</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a deterministic series with the skew of each component computed over the samples of the</span>
<span class="sd">        stochastic series.</span>

<span class="sd">        This works only on stochastic series (i.e., with more than 1 sample)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs</span>
<span class="sd">            Other keyword arguments are passed down to `scipy.stats.skew()`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series containing the skew of each component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_stochastic</span><span class="p">()</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">skew</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_values</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.kurtosis"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.kurtosis">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">kurtosis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a deterministic series with the kurtosis of each component computed over the samples of the</span>
<span class="sd">        stochastic series.</span>

<span class="sd">        This works only on stochastic series (i.e., with more than 1 sample)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs</span>
<span class="sd">            Other keyword arguments are passed down to `scipy.stats.kurtosis()`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series containing the kurtosis of each component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_stochastic</span><span class="p">()</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">kurtosis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_values</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dunder methods</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_extract_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Self</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract values from another series or array and check for compatible shapes.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">other_vals</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_values</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="n">other_vals</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_vals</span> <span class="o">=</span> <span class="n">other</span>

        <span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">other_shape</span> <span class="o">=</span> <span class="n">other_vals</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="c1"># can combine arrays if shapes are equal (t, c, s)</span>
            <span class="n">other_shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
            <span class="c1"># or broadcast [t, 1, 1] onto [t, c, s]</span>
            <span class="ow">or</span> <span class="n">other_shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># or broadcast [t, c, 1] onto [t, c, s]</span>
            <span class="ow">or</span> <span class="n">other_shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># or broadcast [t, 1, s] onto [t, c, s]</span>
            <span class="ow">or</span> <span class="n">other_shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span>
        <span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Attempted to perform operation on two TimeSeries of unequal shapes.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">other_vals</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_fill_missing_dates</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">times</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">],</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the time index and values with missing dates inserted.</span>

<span class="sd">        This requires either a provided `freq` or the possibility to infer a unique frequency from `times` (see</span>
<span class="sd">        `offset aliases &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_</span>
<span class="sd">        for more info on supported frequencies).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times</span>
<span class="sd">            The time index.</span>
<span class="sd">        values</span>
<span class="sd">            The values.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, the target frequency to fill in the missing times. A pandas frequency offset (string) if</span>
<span class="sd">            `times` is a `pandas.DatetimeIndex`, or a step step size if `times` is an integer index.</span>
<span class="sd">            It must represent a target frequency that allows to maintain all dates / integers from `times`.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `times` contains less than 3 elements,</span>
<span class="sd">            if no unique frequency can be inferred from `times`,</span>
<span class="sd">            if the resampled index does not contain all dates from `times`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple[Union[pandas.DatetimeIndex, pandas.RangeIndex], numpy.ndarray]</span>
<span class="sd">            The `times` with inserted missing dates and `values` with `numpy.nan` for the newly inserted dates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_restore_from_frequency</span><span class="p">(</span><span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Input time series must be of (length&gt;=3) when fill_missing_dates=True and freq=None.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">times</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_sort_index</span><span class="p">(</span><span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="n">has_datetime_index</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">observed_freqs</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_observed_freq_datetime_index</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># integer index (non RangeIndex)</span>
            <span class="n">has_datetime_index</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">observed_freqs</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_observed_freq_integer_index</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">observed_freqs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">offset_alias_info</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span>
                    <span class="s2">&quot; For more information about frequency aliases, read &quot;</span>
                    <span class="s2">&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">has_datetime_index</span>
                <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="p">)</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Could not observe an inferred frequency. An explicit frequency must be evident over a span of &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;at least 3 consecutive time stamps in the input data. </span><span class="si">{</span><span class="n">offset_alias_info</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">observed_freqs</span><span class="p">)</span>
                    <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;Could not find a unique inferred frequency (not constant). Observed frequencies: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">observed_freqs</span><span class="si">}</span><span class="s2">. If any of those is the actual frequency, try passing it with &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;`fill_missing_dates=True` and `freq=your_frequency`.</span><span class="si">{</span><span class="n">offset_alias_info</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">freq</span> <span class="o">=</span> <span class="n">observed_freqs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_restore_from_frequency</span><span class="p">(</span><span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_sort_index</span><span class="p">(</span>
        <span class="n">times</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">],</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sort `times` and `values` by ascending dates.</span>

<span class="sd">        Only performed if `times` is not already monotonically increasing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">times</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">values</span>
        <span class="n">times</span><span class="p">,</span> <span class="n">idx_sorted</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">return_indexer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="n">idx_sorted</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_observed_freq_datetime_index</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return all observed/inferred frequencies of a `pandas.DatetimeIndex`.</span>

<span class="sd">        The frequencies are inferred from all combinations of three consecutive time steps.</span>

<span class="sd">        Assumes that `index` is sorted in ascending order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># find unique time deltas indices from three consecutive time stamps</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">unq_td_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([(</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">index</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])]),</span>
            <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># for each unique index, take one example including the left time stamp, and one including the right</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">index</span><span class="p">[</span><span class="n">unq_td_index</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>

        <span class="c1"># find all unique inferred frequencies</span>
        <span class="n">observed_freqs</span> <span class="o">=</span> <span class="p">{</span><span class="n">pd</span><span class="o">.</span><span class="n">infer_freq</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">}</span>
        <span class="n">observed_freqs</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">observed_freqs</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_observed_freq_integer_index</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return all observed/inferred frequencies of a ``pandas.Index`` (an integer-valued index).</span>

<span class="sd">        The inferred frequencies are given by all unique differences between two consecutive elements.</span>

<span class="sd">        Assumes that `index` is sorted in ascending order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">index</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_restore_range_indexed</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">times</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `times` re-indexed into a `pandas.RangeIndex` and `values` in the re-indexed order.</span>

<span class="sd">        An integer `pandas.Index` can be converted to a `pandas.RangeIndex`, if the sorted index has a constant step</span>
<span class="sd">        size. Raises a `ValueError` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_sort_index</span><span class="p">(</span><span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>
        <span class="n">observed_freqs</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_observed_freq_integer_index</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">observed_freqs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Could not convert integer index to a `pandas.RangeIndex`. Found non-unique step &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;sizes/frequencies: `</span><span class="si">{</span><span class="n">observed_freqs</span><span class="si">}</span><span class="s2">`. If any of those is the actual frequency, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;try passing it with `fill_missing_dates=True` and `freq=your_frequency`.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">observed_freqs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span>
            <span class="n">start</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">times</span><span class="p">),</span>
            <span class="n">stop</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">+</span> <span class="n">freq</span><span class="p">,</span>
            <span class="n">step</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">times</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">values</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_restore_from_frequency</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">times</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">],</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `times` resampled with frequency `freq` and values with `np.nan` for the newly inserted dates.</span>

<span class="sd">        The frequency `freq` must represent a target frequency that allows to maintain all dates from `times`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times</span>
<span class="sd">            The time index.</span>
<span class="sd">        values</span>
<span class="sd">            The values.</span>
<span class="sd">        freq</span>
<span class="sd">            The target frequency to fill in the missing times. A pandas frequency offset (string) if</span>
<span class="sd">            `times` is a `pandas.DatetimeIndex`, or a step size if `times` is an integer index.</span>
<span class="sd">            It must represent a target frequency that allows to maintain all dates / integers from `times`.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the resampled/re-indexed DateTimeIndex/RangeIndex does not contain all dates from `times`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple[Union[pandas.DatetimeIndex, pandas.RangeIndex], numpy.ndarray]</span>
<span class="sd">            The resampled `times` with frequency `freq` and `values` with `numpy.nan` for the newly inserted dates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_sort_index</span><span class="p">(</span><span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>

        <span class="n">resampled_times</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="n">has_datetime_index</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">resampled_times</span> <span class="o">=</span> <span class="n">resampled_times</span><span class="o">.</span><span class="n">asfreq</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># integer index (non RangeIndex) -&gt; resampled to RangeIndex</span>
            <span class="n">has_datetime_index</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">resampled_times</span> <span class="o">=</span> <span class="n">resampled_times</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">+</span> <span class="n">freq</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># check if new time index with inferred frequency contains all input data</span>
        <span class="n">contains_all_data</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">resampled_times</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">contains_all_data</span><span class="p">:</span>
            <span class="n">offset_alias_info</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span>
                    <span class="s2">&quot; For more information about frequency aliases, read &quot;</span>
                    <span class="s2">&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">has_datetime_index</span>
                <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="p">)</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Could not correctly fill missing </span><span class="si">{</span><span class="s1">&#39;dates&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">has_datetime_index</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;indices&#39;</span><span class="si">}</span><span class="s2"> with the &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;observed/passed </span><span class="si">{</span><span class="s1">&#39;frequency&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">has_datetime_index</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;step size&#39;</span><span class="si">}</span><span class="s2"> `freq=&#39;</span><span class="si">{</span><span class="n">freq</span><span class="si">}</span><span class="s2">&#39;`. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Not all input </span><span class="si">{</span><span class="s1">&#39;time stamps&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">has_datetime_index</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;indices&#39;</span><span class="si">}</span><span class="s2"> contained in the newly &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;created TimeSeries.</span><span class="si">{</span><span class="n">offset_alias_info</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># convert to float as for instance integer arrays cannot accept nans</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">values</span><span class="o">.</span><span class="n">dtype</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
        <span class="p">)</span>
        <span class="n">resampled_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">resampled_times</span><span class="p">),)</span> <span class="o">+</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="n">resampled_values</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">resampled_values</span><span class="p">[</span><span class="n">resampled_times</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">times</span><span class="p">)]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">return</span> <span class="n">resampled_times</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">resampled_values</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert different `axis` types to an integer axis.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">axis</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If `axis` is an integer it must be between 0 and 2.&quot;</span><span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">axis</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">DIMS</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;`axis` must be a known dimension of this series: </span><span class="si">{</span><span class="n">DIMS</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">DIMS</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_agg_dims</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">new_cname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get output time index and components based on a aggregation `axis` and potential new column name</span>
<span class="sd">        `new_cname`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># set time_index to first day</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># rename components</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="n">new_cname</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># do nothing</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid `axis=</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">`. Must be one of `(1, 2, 3)`.&quot;</span><span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_first_timestamp_after</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="n">ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_last_timestamp_before</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_assert_univariate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_univariate</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="s2">&quot;Only univariate TimeSeries instances support this method&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_assert_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="s2">&quot;Only deterministic TimeSeries (with 1 sample) instances support this method&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_assert_stochastic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stochastic</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="s2">&quot;Only non-deterministic TimeSeries (with more than 1 samples) &quot;</span>
                    <span class="s2">&quot;instances support this method&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_raise_if_not_within</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="c1"># Not that the converse doesn&#39;t apply (a time-indexed series can be called with an integer)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Function called with a timestamp, but series not time-indexed.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">is_inside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
                <span class="n">is_inside</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_inside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_inside</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Timestamp must be between </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_time_index</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">components</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">sc_self</span><span class="p">,</span> <span class="n">sc_other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">static_covariates</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sc_self</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">sc_other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sc_self</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sc_self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">sc_other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">hr_self</span><span class="p">,</span> <span class="n">hr_other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">hierarchy</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hr_self</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">hr_other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hr_self</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">hr_self</span> <span class="o">!=</span> <span class="n">hr_other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">md_self</span><span class="p">,</span> <span class="n">md_other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">metadata</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">md_self</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">md_other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">md_self</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">md_self</span> <span class="o">!=</span> <span class="n">md_other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_values</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;unsupported operand type(s) for + or add(): &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ts</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_values</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;unsupported operand type(s) for - or sub(): &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ts</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_values</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;unsupported operand type(s) for * or mul(): &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ts</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">other</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Attempted to raise a series to a negative power.&quot;</span><span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_values</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="c1"># elementwise power</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;unsupported operand type(s) for ** or pow(): &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ts</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span><span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s2">&quot;Cannot divide by 0.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_values</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">other</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s2">&quot;Cannot divide by a TimeSeries with a value 0.&quot;</span><span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;unsupported operand type(s) for / or truediv():&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ts</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ts</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">negative</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ts</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__round__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ts</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_values</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;unsupported operand type(s) for &lt; : &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_values</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;unsupported operand type(s) for &gt; : &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_values</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;unsupported operand type(s) for &lt;= : &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_values</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;unsupported operand type(s) for &gt;= : &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="s2">&quot;xarray.DataArray&quot;</span><span class="p">,</span> <span class="s2">&quot;TimeSeries (DataArray)&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;xarray.DataArray&quot;</span><span class="p">,</span> <span class="s2">&quot;TimeSeries&quot;</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="o">.</span><span class="n">_repr_html_</span><span class="p">()</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;xarray.DataArray&quot;</span><span class="p">,</span> <span class="s2">&quot;TimeSeries&quot;</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span> <span class="n">memo</span><span class="p">),</span>
            <span class="n">values</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">memo</span><span class="p">),</span>
            <span class="n">components</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="n">memo</span><span class="p">),</span>
            <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span> <span class="n">memo</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">,</span>
            <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
            <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
            <span class="nb">list</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">],</span>
            <span class="nb">str</span><span class="p">,</span>
            <span class="nb">int</span><span class="p">,</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span>
            <span class="n">Any</span><span class="p">,</span>
        <span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new series with elements selected by `key`.</span>

<span class="sd">        The supported index types are the following base types as a single value, a list or a slice:</span>

<span class="sd">        - pandas.Timestamp -&gt; return a TimeSeries corresponding to the value(s) at the given timestamp(s).</span>
<span class="sd">        - str -&gt; return a TimeSeries including the column(s) (components) specified as str.</span>
<span class="sd">        - int -&gt; return a TimeSeries with the value(s) at the given row (time) index.</span>

<span class="sd">        `pandas.DatetimeIndex` and `pandas.RangeIndex` are also supported and will return the corresponding value(s)</span>
<span class="sd">        at the provided time indices.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            slices use pandas convention of including both ends of the slice.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For integer-indexed series; passing integers or slices of integers act as positional indices. For example,</span>
<span class="sd">        passing `series[i]` will return the ``i``-th value along the series, which is not necessarily the value where</span>
<span class="sd">        the time index is equal to ``i`` (if the time index does not start at 0 and / or has a step size &gt; 1). In</span>
<span class="sd">        contrast, calling this method with a ``pandas.RangeIndex`` returns the values where the time index matches the</span>
<span class="sd">        provided range index.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_check_dt</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Attempted indexing a series with a DatetimeIndex or a timestamp, &quot;</span>
                        <span class="s2">&quot;but the series uses a RangeIndex.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_check_range</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Attempted indexing a series with a RangeIndex, &quot;</span>
                        <span class="s2">&quot;but the series uses a DatetimeIndex.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">adapt_covs_on_component</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_static_covariates</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="k">else</span> <span class="kc">False</span>
        <span class="p">)</span>

        <span class="c1"># handle DatetimeIndex and RangeIndex:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">)):</span>
            <span class="n">is_dti</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)</span>
            <span class="n">_check_dt</span><span class="p">()</span> <span class="k">if</span> <span class="n">is_dti</span> <span class="k">else</span> <span class="n">_check_range</span><span class="p">()</span>
            <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># keep original frequency in case of empty index</span>
                <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">raise_log</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Not all indices found in time index.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>
                <span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

                <span class="c1"># make sure the frequency is transferred</span>
                <span class="k">if</span> <span class="n">is_dti</span><span class="p">:</span>
                    <span class="n">times</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">freq</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># `get_indexer()` converts `RangeIndex` into regular `Index`</span>
                    <span class="n">times</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span>
                        <span class="n">start</span><span class="o">=</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stop</span><span class="o">=</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">key</span><span class="o">.</span><span class="n">step</span>
                    <span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span>
            <span class="p">)</span>
        <span class="c1"># handle slices:</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">raise_log</span><span class="p">(</span>
                        <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Indexing a `TimeSeries` with a `slice` of `step&lt;=0` (reverse) is not &quot;</span>
                            <span class="s2">&quot;possible since `TimeSeries` must have a monotonically increasing time index.&quot;</span>
                        <span class="p">),</span>
                        <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                        <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                        <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                        <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
                        <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># selecting components discards the hierarchy, if any</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">]))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">raise_log</span><span class="p">(</span>
                        <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Not all components found in time index.&quot;</span><span class="p">),</span> <span class="n">logger</span>
                    <span class="p">)</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[:,</span> <span class="n">indexer</span><span class="p">]</span>
                <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span>
                <span class="n">static_covariates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                    <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
                    <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
                    <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
                    <span class="n">static_covariates</span><span class="o">=</span><span class="p">(</span>
                        <span class="n">static_covariates</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">adapt_covs_on_component</span>
                        <span class="k">else</span> <span class="n">static_covariates</span>
                    <span class="p">),</span>
                    <span class="n">hierarchy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                    <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                    <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                    <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
                    <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">raise_log</span><span class="p">(</span>
                        <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Indexing a `TimeSeries` with a `slice` of `step&lt;=0` (reverse) is not &quot;</span>
                            <span class="s2">&quot;possible since `TimeSeries` must have a monotonically increasing time index.&quot;</span>
                        <span class="p">),</span>
                        <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="n">_check_dt</span><span class="p">()</span>
                <span class="n">start_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">n_steps_between</span><span class="p">(</span>
                        <span class="n">end</span><span class="o">=</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># shift start a round-multip of `step` ahead until it lies within the index</span>
                        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">start</span> <span class="o">%</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">n_steps_between</span><span class="p">(</span>
                        <span class="n">end</span><span class="o">=</span><span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">key</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                    <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                    <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                    <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
                    <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># handle simple types:</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">col_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">static_covariates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
                <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[:,</span> <span class="n">col_idx</span> <span class="p">:</span> <span class="n">col_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="n">col_idx</span> <span class="p">:</span> <span class="n">col_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">static_covariates</span><span class="o">=</span><span class="p">(</span>
                    <span class="n">static_covariates</span><span class="o">.</span><span class="n">loc</span><span class="p">[[</span><span class="n">key</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="n">adapt_covs_on_component</span>
                    <span class="k">else</span> <span class="n">static_covariates</span>
                <span class="p">),</span>
                <span class="n">hierarchy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span><span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Integer index out of range.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ts</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="n">_check_dt</span><span class="p">()</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># handle lists:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
                <span class="c1"># when string(s) are provided, we consider it as (a list of) component(s)</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">indexer</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">raise_log</span><span class="p">(</span>
                        <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Not all components found in time index.&quot;</span><span class="p">),</span> <span class="n">logger</span>
                    <span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[:,</span> <span class="n">indexer</span><span class="p">]</span>
                <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span>
                <span class="n">static_covariates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                    <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
                    <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
                    <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
                    <span class="n">static_covariates</span><span class="o">=</span><span class="p">(</span>
                        <span class="n">static_covariates</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">adapt_covs_on_component</span>
                        <span class="k">else</span> <span class="n">static_covariates</span>
                    <span class="p">),</span>
                    <span class="n">hierarchy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
                <span class="c1"># convert list of integers to slice (must have constant step size)</span>
                <span class="n">step_sizes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">step_sizes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">raise_log</span><span class="p">(</span>
                        <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Cannot index a `TimeSeries` with a list of integers with non-constant step sizes. &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Observed step sizes: `</span><span class="si">{</span><span class="n">step_sizes</span><span class="si">}</span><span class="s2">`.&quot;</span>
                        <span class="p">),</span>
                        <span class="n">logger</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">step_sizes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">step_size</span> <span class="o">=</span> <span class="n">step_sizes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">step_size</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">step_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">raise_log</span><span class="p">(</span>
                        <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Indexing a `TimeSeries` with a list of integers with `step&lt;=0` is not &quot;</span>
                            <span class="s2">&quot;possible since `TimeSeries` must have a monotonically increasing time index.&quot;</span>
                        <span class="p">),</span>
                        <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">step_size</span> <span class="p">:</span> <span class="n">step_size</span><span class="p">]</span>

            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
                <span class="n">_check_dt</span><span class="p">()</span>
                <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                    <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                    <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                    <span class="n">components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
                    <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">raise_log</span><span class="p">(</span><span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;The type of your index was not matched.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">_concat_static_covs</span><span class="p">(</span><span class="n">series</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Concatenate static covariates along the component axis (rows of static covariates). Use this for stacking or</span>
<span class="sd">    concatenating time series along component dimension (axis=1).</span>

<span class="sd">    Some context for stacking or concatenating two or more TimeSeries with static covariates:</span>

<span class="sd">    - Concat along axis=0 (time): Along the time dimension, we only take the static covariates of the first series (as</span>
<span class="sd">      static covariates are time-independent).</span>
<span class="sd">    - Concat along axis=1 (components) or stacking: Along the component dimension, we either concatenate or transfer</span>
<span class="sd">      the static covariates of the series if one of below cases applies:</span>
<span class="sd">      1) concatenate along component dimension (rows of static covariates) when for each series the number of static</span>
<span class="sd">         covariate components is equal to the number of components in the series. The static variable names (columns in</span>
<span class="sd">         series.static_covariates) must be identical across all series</span>
<span class="sd">      2) if only the first series contains static covariates transfer only those</span>
<span class="sd">      3) if `ignore_static_covariates=True` (with `concatenate()`), case 1) is ignored and only the static covariates</span>
<span class="sd">         of the first series are transferred</span>
<span class="sd">    - Concat along axis=2 (samples): Along the sample dimension, we only take the static covariates of the first series</span>
<span class="sd">      (as the components and time don&#39;t change).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">ts</span><span class="o">.</span><span class="n">has_static_covariates</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">only_first</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">has_static_covariates</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">has_static_covariates</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="p">])</span>
    <span class="n">all_have</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">ts</span><span class="o">.</span><span class="n">has_static_covariates</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">only_first</span> <span class="ow">or</span> <span class="n">all_have</span><span class="p">):</span>
        <span class="n">raise_log</span><span class="p">(</span>
            <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Either none, only the first or all TimeSeries must have `static_covariates`.&quot;</span>
            <span class="p">),</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">only_first</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">static_covariates</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
        <span class="nb">all</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">)</span> <span class="o">==</span> <span class="n">ts</span><span class="o">.</span><span class="n">n_components</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">])</span>
        <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">static_covariates</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">static_covariates</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span>
        <span class="p">])</span>
    <span class="p">):</span>
        <span class="n">raise_log</span><span class="p">(</span>
            <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Concatenation of multiple TimeSeries with static covariates requires all `static_covariates` &quot;</span>
                <span class="s2">&quot;DataFrames to have identical columns (static variable names), and the number of each TimeSeries&#39; &quot;</span>
                <span class="s2">&quot;components must match the number of corresponding static covariate components (the number of rows &quot;</span>
                <span class="s2">&quot;in `series.static_covariates`).&quot;</span>
            <span class="p">),</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
        <span class="p">[</span><span class="n">ts</span><span class="o">.</span><span class="n">static_covariates</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span> <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">has_static_covariates</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_concat_hierarchy</span><span class="p">(</span><span class="n">series</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Concatenate the hierarchies of multiple series, when concatenating series along axis 1 (components). This simply</span>
<span class="sd">    merges the hierarchy dictionaries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">concat_hierarchy</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">series</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">has_hierarchy</span><span class="p">:</span>
            <span class="n">concat_hierarchy</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">concat_hierarchy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">concat_hierarchy</span>


<div class="viewcode-block" id="concatenate"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.concatenate">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">concatenate</span><span class="p">(</span>
    <span class="n">series</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">ignore_time_axis</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">ignore_static_covariates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">drop_hierarchy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">drop_metadata</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Concatenate multiple series along a given axis.</span>

<span class="sd">    ``axis`` can be an integer in (0, 1, 2) to denote (time, component, sample) or, alternatively, a string denoting</span>
<span class="sd">    the corresponding dimension of the underlying ``DataArray``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    series : Sequence[TimeSeries]</span>
<span class="sd">        Sequence of ``TimeSeries`` to concatenate.</span>
<span class="sd">    axis : Union[str, int]</span>
<span class="sd">        Axis along which the series will be concatenated.</span>
<span class="sd">    ignore_time_axis : bool</span>
<span class="sd">        Allow concatenation even when some series do not have matching time axes.</span>
<span class="sd">        When done along component or sample dimensions, concatenation will work as long as the series</span>
<span class="sd">        have the same lengths (in this case the resulting series will have the time axis of the first</span>
<span class="sd">        provided series). When done along time dimension, concatenation will work even if the time axes</span>
<span class="sd">        are not contiguous (in this case, the resulting series will have a start time matching the start time</span>
<span class="sd">        of the first provided series). Default: False.</span>
<span class="sd">    ignore_static_covariates : bool</span>
<span class="sd">        Whether to ignore all requirements for static covariate concatenation and only transfer the static covariates</span>
<span class="sd">        of the first TimeSeries element in `series` to the concatenated TimeSeries. Only effective when `axis=1`.</span>
<span class="sd">    drop_hierarchy : bool</span>
<span class="sd">        When `axis=1`, whether to drop hierarchy information. True by default. When False, the hierarchies will be</span>
<span class="sd">        &quot;concatenated&quot; as well (by merging the hierarchy dictionaries), which may cause issues if the component</span>
<span class="sd">        names of the resulting series and that of the merged hierarchy do not match.</span>
<span class="sd">        When `axis=0` or `axis=2`, the hierarchy of the first series is always kept.</span>
<span class="sd">    drop_metadata : bool</span>
<span class="sd">        Whether to drop the metadata information of the concatenated series. False by default.</span>
<span class="sd">        When False, the concatenated series will inherit the metadata from the first TimeSeries element in `series`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    TimeSeries</span>
<span class="sd">        The concatenated series.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">ts</span><span class="o">.</span><span class="n">all_values</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">]</span>

    <span class="n">component_axis_equal</span> <span class="o">=</span> <span class="nb">len</span><span class="p">({</span><span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">COMP_AX</span><span class="p">]</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">})</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">sample_axis_equal</span> <span class="o">=</span> <span class="nb">len</span><span class="p">({</span><span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">SMPL_AX</span><span class="p">]</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">})</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">times</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_time_index</span>
    <span class="n">components</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">components</span>
    <span class="n">static_covariates</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">static_covariates</span>
    <span class="n">hierarchy</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hierarchy</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">drop_metadata</span> <span class="k">else</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">metadata</span>

    <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># time</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">component_axis_equal</span> <span class="ow">and</span> <span class="n">sample_axis_equal</span><span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;when concatenating along time dimension, the component and sample dimensions of all &quot;</span>
                    <span class="s2">&quot;provided series must match.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># check, if timeseries are consecutive</span>
        <span class="n">consecutive_time_axes</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">series</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span> <span class="o">+</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">freq</span> <span class="o">!=</span> <span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span><span class="p">():</span>
                <span class="n">consecutive_time_axes</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">consecutive_time_axes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_time_axis</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;When concatenating over time axis, all series need to be contiguous &quot;</span>
                        <span class="s2">&quot;in the time dimension. Use `ignore_time_axis=True` to override &quot;</span>
                        <span class="s2">&quot;this behavior and concatenate the series by extending the time axis &quot;</span>
                        <span class="s2">&quot;of the first series.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">times</span> <span class="o">=</span> <span class="n">generate_index</span><span class="p">(</span>
            <span class="n">start</span><span class="o">=</span><span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span><span class="p">(),</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span>
            <span class="n">name</span><span class="o">=</span><span class="n">times</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ignore_time_axis</span><span class="p">:</span>
            <span class="n">time_axes_ok</span> <span class="o">=</span> <span class="nb">len</span><span class="p">({</span><span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">})</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time_axes_ok</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span>
                <span class="n">ts</span><span class="o">.</span><span class="n">has_same_time_as</span><span class="p">(</span><span class="n">ts_next</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ts</span><span class="p">,</span> <span class="n">ts_next</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">series</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="p">])</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="ow">not</span> <span class="n">time_axes_ok</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sample_axis_equal</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">component_axis_equal</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;When concatenating along component or sample dimensions, all the series must have the same time &quot;</span>
                    <span class="s2">&quot;axes (unless `ignore_time_axis` is True), or time axes of same lengths (if `ignore_time_axis` is &quot;</span>
                    <span class="s2">&quot;True), and all series must have the same number of samples (if concatenating along component &quot;</span>
                    <span class="s2">&quot;dimension), or the same number of components (if concatenating along sample dimension).&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># When concatenating along component dimension, we have to re-create a component index</span>
            <span class="c1"># we rely on the factory method of TimeSeries to disambiguate names later on if needed.</span>
            <span class="n">components</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span>
                <span class="n">c</span> <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ts</span><span class="o">.</span><span class="n">components</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cl</span>
            <span class="p">])</span>
            <span class="n">static_covariates</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">_concat_static_covs</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_static_covariates</span>
                <span class="k">else</span> <span class="n">static_covariates</span>
            <span class="p">)</span>
            <span class="n">hierarchy</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">drop_hierarchy</span> <span class="k">else</span> <span class="n">_concat_hierarchy</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
        <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span>
        <span class="n">values</span><span class="o">=</span><span class="n">vals</span><span class="p">,</span>
        <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
        <span class="n">static_covariates</span><span class="o">=</span><span class="n">static_covariates</span><span class="p">,</span>
        <span class="n">hierarchy</span><span class="o">=</span><span class="n">hierarchy</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="slice_intersect"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.slice_intersect">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">slice_intersect</span><span class="p">(</span><span class="n">series</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a list of series, where all series have been intersected along the time index.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    series : Sequence[TimeSeries]</span>
<span class="sd">        sequence of ``TimeSeries`` to intersect</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Sequence[TimeSeries]</span>
<span class="sd">        The intersected series.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">series</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># find global intersection on first series</span>
    <span class="n">intersection</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">series_</span> <span class="ow">in</span> <span class="n">series</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">intersection</span> <span class="o">=</span> <span class="n">intersection</span><span class="o">.</span><span class="n">slice_intersect</span><span class="p">(</span><span class="n">series_</span><span class="p">)</span>

    <span class="c1"># intersect all other series</span>
    <span class="n">series_intersected</span> <span class="o">=</span> <span class="p">[</span><span class="n">intersection</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">series_</span> <span class="ow">in</span> <span class="n">series</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">series_intersected</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">series_</span><span class="o">.</span><span class="n">slice_intersect</span><span class="p">(</span><span class="n">intersection</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">series_intersected</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">_finite_rows_boundaries</span><span class="p">(</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">how</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the indices of the first rows containing finite values starting from the start and the end of the first</span>
<span class="sd">    dimension of the ndarray.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values</span>
<span class="sd">        1D, 2D or 3D numpy array where the first dimension correspond to entries/rows, and the second to components/</span>
<span class="sd">        columns</span>
<span class="sd">    how</span>
<span class="sd">        Define if the entries containing `NaN` in all the components (&#39;all&#39;) or in any of the components (&#39;any&#39;)</span>
<span class="sd">        should be stripped. Default: &#39;all&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">raise_log</span><span class="p">(</span>
            <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected 1D to 3D array, received </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">D array&quot;</span><span class="p">),</span> <span class="n">logger</span>
        <span class="p">)</span>

    <span class="n">finite_rows</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">finite_rows</span> <span class="o">=</span> <span class="n">finite_rows</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;any&quot;</span><span class="p">:</span>
            <span class="n">finite_rows</span> <span class="o">=</span> <span class="n">finite_rows</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">finite_rows</span> <span class="o">=</span> <span class="n">finite_rows</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;`how` parameter value not recognized, should be either &#39;all&#39; or &#39;any&#39;, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;received </span><span class="si">{</span><span class="n">how</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="n">first_finite_row</span> <span class="o">=</span> <span class="n">finite_rows</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
    <span class="n">last_finite_row</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">finite_rows</span><span class="p">)</span> <span class="o">-</span> <span class="n">finite_rows</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">first_finite_row</span><span class="p">,</span> <span class="n">last_finite_row</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_clean_components</span><span class="p">(</span><span class="n">components</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a `pandas.Index` with unique string component / column names&quot;&quot;&quot;</span>
    <span class="c1"># convert everything to string if needed</span>
    <span class="n">clist</span> <span class="o">=</span> <span class="p">[(</span><span class="n">col</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">col</span><span class="p">))</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">components</span><span class="p">]</span>

    <span class="n">has_duplicate</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">clist</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clist</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">has_duplicate</span><span class="p">:</span>
        <span class="c1"># we may have to loop several times (e.g. we could have components [&quot;0&quot;, &quot;0_1&quot;, &quot;0&quot;] and not</span>
        <span class="c1"># noticing when renaming the last &quot;0&quot; into &quot;0_1&quot; that &quot;0_1&quot; already exists...)</span>
        <span class="n">name_to_occurence</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clist</span><span class="p">)):</span>
            <span class="n">name_to_occurence</span><span class="p">[</span><span class="n">clist</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">name_to_occurence</span><span class="p">[</span><span class="n">clist</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">clist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">clist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">name_to_occurence</span><span class="p">[</span><span class="n">clist</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">has_duplicate</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">clist</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clist</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">clist</span><span class="p">)</span>
</pre></div>

              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2020 - 2025, Unit8 SA (Apache 2.0 License).<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.0.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>