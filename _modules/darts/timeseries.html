
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>darts.timeseries &#8212; darts  documentation</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet">
  <link href="../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/blank.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="shortcut icon" href="../../_static/docs-favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../index.html">
  <img src="../../_static/darts-logo-trim.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../README.html">
  Home
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../quickstart/00-quickstart.html">
  Quickstart
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../userguide.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../generated_api/darts.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../examples.html">
  Examples
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/unit8co/darts" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/unit8co" rel="noopener" target="_blank" title="Twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for darts.timeseries</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Timeseries</span>
<span class="sd">----------</span>

<span class="sd">``TimeSeries`` is the main class in `darts`.</span>
<span class="sd">It represents a univariate or multivariate time series, deterministic or stochastic.</span>

<span class="sd">The values are stored in an array of shape `(time, dimensions, samples)`, where</span>
<span class="sd">`dimensions` are the dimensions (or &quot;components&quot;, or &quot;columns&quot;) of multivariate series,</span>
<span class="sd">and `samples` are samples of stochastic series.</span>

<span class="sd">Definitions:</span>
<span class="sd">    - A series with `dimensions = 1` is **univariate** and a series with `dimensions &gt; 1` is **multivariate**.</span>
<span class="sd">    - | A series with `samples = 1` is **deterministic** and a series with `samples &gt; 1` is</span>
<span class="sd">      | **stochastic** (or **probabilistic**).</span>

<span class="sd">Each series also stores a `time_index`, which contains either datetimes (:class:`pandas.DateTimeIndex`)</span>
<span class="sd">or integer indices (:class:`pandas.RangeIndex`).</span>

<span class="sd">``TimeSeries`` are guaranteed to:</span>
<span class="sd">    - Have a monotonically increasing time index, without holes (without missing dates)</span>
<span class="sd">    - Contain numeric types only</span>
<span class="sd">    - Have distinct components/columns names</span>
<span class="sd">    - Have a well defined frequency (`date offset aliases</span>
<span class="sd">      &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_</span>
<span class="sd">      for ``DateTimeIndex``, or step size for ``RangeIndex``)</span>
<span class="sd">    - Have static covariates consistent with their components, or no static covariates</span>
<span class="sd">    - Have a hierarchy consistent with their components, or no hierarchy</span>

<span class="sd">``TimeSeries`` can contain global or component-specific static covariate data. Static covariates in `darts` refers</span>
<span class="sd">to external time-invariant data that can be used by some models to help improve predictions.</span>
<span class="sd">Read our `user guide on covariates &lt;https://unit8co.github.io/darts/userguide/covariates.html&gt;`__ and the</span>
<span class="sd">``TimeSeries`` documentation for more information on covariates.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">matplotlib.axes</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">from</span> <span class="nn">pandas.tseries.frequencies</span> <span class="kn">import</span> <span class="n">to_offset</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">kurtosis</span><span class="p">,</span> <span class="n">skew</span>

<span class="kn">from</span> <span class="nn">.logging</span> <span class="kn">import</span> <span class="n">get_logger</span><span class="p">,</span> <span class="n">raise_if</span><span class="p">,</span> <span class="n">raise_if_not</span><span class="p">,</span> <span class="n">raise_log</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Literal</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Self</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Self</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># dimension names in the DataArray</span>
<span class="c1"># the &quot;time&quot; one can be different, if it has a name in the underlying Series/DataFrame.</span>
<span class="n">DIMS</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;component&quot;</span><span class="p">,</span> <span class="s2">&quot;sample&quot;</span><span class="p">)</span>

<span class="n">VALID_INDEX_TYPES</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">)</span>
<span class="n">STATIC_COV_TAG</span> <span class="o">=</span> <span class="s2">&quot;static_covariates&quot;</span>
<span class="n">DEFAULT_GLOBAL_STATIC_COV_NAME</span> <span class="o">=</span> <span class="s2">&quot;global_components&quot;</span>
<span class="n">HIERARCHY_TAG</span> <span class="o">=</span> <span class="s2">&quot;hierarchy&quot;</span>


<div class="viewcode-block" id="TimeSeries"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries">[docs]</a><span class="k">class</span> <span class="nc">TimeSeries</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xa</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a TimeSeries from a (well formed) DataArray.</span>
<span class="sd">        It is recommended to use the factory methods to create TimeSeries instead.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.from_dataframe : Create from a :class:`pandas.DataFrame`.</span>
<span class="sd">        TimeSeries.from_group_dataframe : Create multiple TimeSeries by groups from a :class:`pandas.DataFrame`.</span>
<span class="sd">        TimeSeries.from_series : Create from a :class:`pandas.Series`.</span>
<span class="sd">        TimeSeries.from_values : Create from a NumPy :class:`ndarray`.</span>
<span class="sd">        TimeSeries.from_times_and_values : Create from a time index and a Numpy :class:`ndarray`.</span>
<span class="sd">        TimeSeries.from_csv : Create from a CSV file.</span>
<span class="sd">        TimeSeries.from_json : Create from a JSON file.</span>
<span class="sd">        TimeSeries.from_xarray : Create from an :class:`xarray.DataArray`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">),</span>
            <span class="s2">&quot;Data must be provided as an xarray DataArray instance. &quot;</span>
            <span class="s2">&quot;If you need to create a TimeSeries from another type &quot;</span>
            <span class="s2">&quot;(e.g. a DataFrame), look at TimeSeries factory methods &quot;</span>
            <span class="s2">&quot;(e.g. TimeSeries.from_dataframe(), &quot;</span>
            <span class="s2">&quot;TimeSeries.from_xarray(), TimeSeries.from_values()&quot;</span>
            <span class="s2">&quot;TimeSeries.from_times_and_values(), etc...).&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;TimeSeries require DataArray of dimensionality 3 (</span><span class="si">{</span><span class="n">DIMS</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Ideally values should be np.float, otherwise certain functionalities like diff()</span>
        <span class="c1"># relying on np.nan (which is a float) won&#39;t work very properly.</span>
        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">),</span>
            <span class="s2">&quot;The time series must contain numeric values only.&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">val_dtype</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">val_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">val_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;TimeSeries is using a numeric type different from np.float32 or np.float64. &quot;</span>
                <span class="s2">&quot;Not all functionalities may work properly. It is recommended casting your data to floating &quot;</span>
                <span class="s2">&quot;point numbers before using TimeSeries.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">DIMS</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]:</span>
            <span class="c1"># The first dimension represents the time and may be named differently.</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The last two dimensions of the DataArray must be named </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">DIMS</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
                    <span class="p">)</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># check that columns/component names are unique</span>
        <span class="n">components</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">components</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">),</span>
            <span class="s2">&quot;The components (columns) names must be unique. Provided: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">components</span>
            <span class="p">),</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span>
            <span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># how the time dimension is named; we convert hashable to string</span>

        <span class="c1"># The following sorting returns a copy, which we are relying on.</span>
        <span class="c1"># As of xarray 0.18.2, this sorting discards the freq of the index for some reason</span>
        <span class="c1"># https://github.com/pydata/xarray/issues/5466</span>
        <span class="c1"># We sort only if the time axis is not already sorted (monotonically increasing).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_index</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span> <span class="n">VALID_INDEX_TYPES</span><span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The time dimension of the DataArray must be indexed either with a DatetimeIndex &quot;</span>
                    <span class="s2">&quot;or with an RangeIndex.&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
            <span class="n">freq_tmp</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span>
            <span class="p">)</span><span class="o">.</span><span class="n">freq</span>  <span class="c1"># store original freq (see bug of sortby() above).</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">freq_tmp</span>
                <span class="k">if</span> <span class="n">freq_tmp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="n">to_offset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">)</span><span class="o">.</span><span class="n">inferred_freq</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">raise_if</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s2">&quot;The time index of the provided DataArray is missing the freq attribute, and the frequency could &quot;</span>
                <span class="s2">&quot;not be directly inferred. &quot;</span>
                <span class="s2">&quot;This probably comes from inconsistent date frequencies with missing dates. &quot;</span>
                <span class="s2">&quot;If you know the actual frequency, try setting `fill_missing_dates=True, freq=actual_frequency`. &quot;</span>
                <span class="s2">&quot;If not, try setting `fill_missing_dates=True, freq=None` to see if a frequency can be inferred.&quot;</span><span class="p">,</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_freq_str</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="o">.</span><span class="n">freqstr</span>

            <span class="c1"># reset freq inside the xarray index (see bug of sortby() above).</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">)</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>

            <span class="c1"># We have to check manually if the index is complete for non-empty series. Another way could</span>
            <span class="c1"># be to rely on `inferred_freq` being present, but this fails for series of length &lt; 3.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">is_index_complete</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span>
                        <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
                            <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">,</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="o">==</span> <span class="mi">0</span>
                <span class="p">)</span>

                <span class="n">raise_if_not</span><span class="p">(</span>
                    <span class="n">is_index_complete</span><span class="p">,</span>
                    <span class="s2">&quot;Not all timestamps seem to be present in the time index. Does &quot;</span>
                    <span class="s2">&quot;the series contain holes? If you are using a factory method, &quot;</span>
                    <span class="s2">&quot;try specifying `fill_missing_dates=True` &quot;</span>
                    <span class="s2">&quot;or specify the `freq` parameter.&quot;</span><span class="p">,</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">step</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_freq_str</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># check static covariates</span>
        <span class="n">static_covariates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">STATIC_COV_TAG</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">static_covariates</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">))</span>
            <span class="ow">or</span> <span class="n">static_covariates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;`static_covariates` must be either a pandas Series, DataFrame or None&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># check if valid static covariates for multivariate TimeSeries</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">static_covariates</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">n_components</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">static_covariates</span><span class="p">)</span>
            <span class="n">raise_if</span><span class="p">(</span>
                <span class="n">n_components</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n_components</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span>
                <span class="s2">&quot;When passing a multi-row pandas DataFrame, the number of rows must match the number of &quot;</span>
                <span class="s2">&quot;components of the TimeSeries object (multi-component/multi-row static covariates must map to each &quot;</span>
                <span class="s2">&quot;TimeSeries component).&quot;</span><span class="p">,</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">static_covariates</span> <span class="o">=</span> <span class="n">static_covariates</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">static_covariates</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="n">static_covariates</span> <span class="o">=</span> <span class="n">static_covariates</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># None</span>
            <span class="k">pass</span>

        <span class="c1"># prepare static covariates:</span>
        <span class="k">if</span> <span class="n">static_covariates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">static_covariates</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">static_covariates</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span>
                <span class="k">else</span> <span class="p">[</span><span class="n">DEFAULT_GLOBAL_STATIC_COV_NAME</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">static_covariates</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">STATIC_COV_TAG</span>
            <span class="c1"># convert numerical columns to same dtype as series</span>
            <span class="c1"># we get all numerical columns, except those that have right dtype already</span>
            <span class="n">cols_to_cast</span> <span class="o">=</span> <span class="n">static_covariates</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span>
                <span class="n">include</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
            <span class="p">)</span><span class="o">.</span><span class="n">columns</span>

            <span class="n">changes</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols_to_cast</span><span class="p">}</span>
            <span class="c1"># Calling astype is costly even when there&#39;s no change...</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">changes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">static_covariates</span> <span class="o">=</span> <span class="n">static_covariates</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">changes</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># handle hierarchy</span>
        <span class="n">hierarchy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">HIERARCHY_TAG</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_top_level_component</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bottom_level_components</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">hierarchy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">hierarchy</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span>
                <span class="s2">&quot;The hierarchy must be a dict mapping (non-top) component names to their parent(s) in the hierarchy.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># pre-compute grouping informations</span>
            <span class="n">components_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
            <span class="n">children</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">hierarchy</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="c1"># convert string ancestors to list of strings</span>
            <span class="n">hierarchy</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="p">([</span><span class="n">v</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">hierarchy</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="nb">all</span><span class="p">(</span><span class="n">c</span> <span class="ow">in</span> <span class="n">components_set</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">),</span>
                <span class="s2">&quot;The keys of the hierarchy must be time series components&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ancestors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">hierarchy</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="nb">all</span><span class="p">(</span><span class="n">a</span> <span class="ow">in</span> <span class="n">components_set</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ancestors</span><span class="p">),</span>
                <span class="s2">&quot;The values of the hierarchy must only contain component names matching those of the series.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">hierarchy_top</span> <span class="o">=</span> <span class="n">components_set</span> <span class="o">-</span> <span class="n">children</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">hierarchy_top</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s2">&quot;The hierarchy must be such that only one component does &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;not appear as a key (the top level component).&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_top_level_component</span> <span class="o">=</span> <span class="n">hierarchy_top</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_top_level_component</span> <span class="ow">in</span> <span class="n">ancestors</span><span class="p">,</span>
                <span class="s2">&quot;Invalid hierarchy. Component </span><span class="si">{}</span><span class="s2"> appears as it should be top-level, but &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;does not appear as an ancestor in the hierarchy dict.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">bottom_level</span> <span class="o">=</span> <span class="n">components_set</span> <span class="o">-</span> <span class="n">ancestors</span>

            <span class="c1"># maintain the same order as the original components</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bottom_level_components</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">bottom_level</span>
            <span class="p">]</span>

        <span class="c1"># Store static covariates and hierarchy in attributes (potentially storing None)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">=</span> <span class="n">_xarray_with_attrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">,</span> <span class="n">static_covariates</span><span class="p">,</span> <span class="n">hierarchy</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Factory Methods</span>
<span class="sd">    ===============</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TimeSeries.from_xarray"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_xarray">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_xarray</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">xa</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fillna_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a TimeSeries instance built from an xarray DataArray.</span>
<span class="sd">        The dimensions of the DataArray have to be (time, component, sample), in this order. The time</span>
<span class="sd">        dimension can have an arbitrary name, but component and sample must be named &quot;component&quot; and &quot;sample&quot;,</span>
<span class="sd">        respectively.</span>

<span class="sd">        The first dimension (time), and second dimension (component) must be indexed (i.e., have coordinates).</span>
<span class="sd">        The time must be indexed either with a pandas DatetimeIndex, a pandas RangeIndex, or a pandas Index that can</span>
<span class="sd">        be converted to a RangeIndex. It is better if the index has no holes; alternatively setting</span>
<span class="sd">        `fill_missing_dates` can in some cases solve these issues (filling holes with NaN, or with the provided</span>
<span class="sd">        `fillna_value` numeric value, if any).</span>

<span class="sd">        If two components have the same name or are not strings, this method will disambiguate the components</span>
<span class="sd">        names by appending a suffix of the form &quot;&lt;name&gt;_N&quot; to the N-th column with name &quot;name&quot;.</span>
<span class="sd">        The component names in the static covariates and hierarchy (if any) are *not* disambiguated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xa</span>
<span class="sd">            The xarray DataArray</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates (or indices in case of integer index)</span>
<span class="sd">            with NaN values. This requires either a provided `freq` or the possibility to infer the frequency from the</span>
<span class="sd">            provided timestamps. See :meth:`_fill_missing_dates() &lt;TimeSeries._fill_missing_dates&gt;` for more info.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string or integer representing the frequency of the underlying index. This is useful in order</span>
<span class="sd">            to fill in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>
<span class="sd">            If a string, represents the frequency of the pandas DatetimeIndex (see `offset aliases</span>
<span class="sd">            &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_ for more info on</span>
<span class="sd">            supported frequencies).</span>
<span class="sd">            If an integer, represents the step size of the pandas Index or pandas RangeIndex.</span>
<span class="sd">        fillna_value</span>
<span class="sd">            Optionally, a numeric value to fill missing values (NaNs) with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A univariate or multivariate deterministic TimeSeries constructed from the inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xa_index</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">has_datetime_index</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xa_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)</span>
        <span class="n">has_range_index</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xa_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">)</span>
        <span class="n">has_integer_index</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">has_datetime_index</span> <span class="ow">or</span> <span class="n">has_range_index</span><span class="p">)</span>

        <span class="n">has_frequency</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">has_datetime_index</span> <span class="ow">and</span> <span class="n">xa_index</span><span class="o">.</span><span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="n">has_range_index</span>

        <span class="c1"># optionally fill missing dates; do it only when there is a DatetimeIndex (and not a RangeIndex)</span>
        <span class="k">if</span> <span class="n">fill_missing_dates</span><span class="p">:</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_fill_missing_dates</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
        <span class="c1"># provided index does not have a freq; using the provided freq</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">has_datetime_index</span> <span class="ow">or</span> <span class="n">has_integer_index</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_frequency</span>
        <span class="p">):</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_restore_xarray_from_frequency</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
        <span class="c1"># index is an integer index and no freq is provided; try convert it to pd.RangeIndex</span>
        <span class="k">elif</span> <span class="n">has_integer_index</span> <span class="ow">and</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_integer_to_range_indexed_xarray</span><span class="p">(</span><span class="n">xa</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="n">xa</span>
        <span class="k">if</span> <span class="n">fillna_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="n">xa_</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fillna_value</span><span class="p">)</span>

        <span class="c1"># clean components (columns) names if needed (if names are not unique, or not strings)</span>
        <span class="n">components</span> <span class="o">=</span> <span class="n">xa_</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">components</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">[</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">components</span><span class="p">]</span>
        <span class="p">):</span>

            <span class="k">def</span> <span class="nf">_clean_component_list</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
                <span class="c1"># return a list of string containing column names</span>
                <span class="c1"># make each column name unique in case some columns have the same names</span>
                <span class="n">clist</span> <span class="o">=</span> <span class="n">columns</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>

                <span class="c1"># convert everything to string if needed</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clist</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="n">clist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

                <span class="n">has_duplicate</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">clist</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clist</span><span class="p">)</span>
                <span class="k">while</span> <span class="n">has_duplicate</span><span class="p">:</span>
                    <span class="c1"># we may have to loop several times (e.g. we could have columns [&quot;0&quot;, &quot;0_1&quot;, &quot;0&quot;] and not</span>
                    <span class="c1"># noticing when renaming the last &quot;0&quot; into &quot;0_1&quot; that &quot;0_1&quot; already exists...)</span>
                    <span class="n">name_to_occurence</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clist</span><span class="p">):</span>
                        <span class="n">name_to_occurence</span><span class="p">[</span><span class="n">clist</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="k">if</span> <span class="n">name_to_occurence</span><span class="p">[</span><span class="n">clist</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">clist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">clist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">name_to_occurence</span><span class="p">[</span><span class="n">clist</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span>
                            <span class="p">)</span>

                    <span class="n">has_duplicate</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">clist</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clist</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">clist</span>

            <span class="n">time_index_name</span> <span class="o">=</span> <span class="n">xa_</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">columns_list</span> <span class="o">=</span> <span class="n">_clean_component_list</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>

            <span class="c1"># Note: an option here could be to also rename the component names in the static covariates</span>
            <span class="c1"># and/or hierarchy, if any. However, we decide not to do so as those are directly dependent on the</span>
            <span class="c1"># component names to work properly, so in case there&#39;s any name conflict it&#39;s better solved</span>
            <span class="c1"># by the user than handled by silent renaming, which can change the way things work.</span>

            <span class="c1"># TODO: is there a way to just update the component index without re-creating a new DataArray?</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">xa_</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="n">xa_</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
                <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                    <span class="n">time_index_name</span><span class="p">:</span> <span class="n">xa_</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">time_index_name</span><span class="p">),</span>
                    <span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">columns_list</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">attrs</span><span class="o">=</span><span class="n">xa_</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># We cast the array to float</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">xa_</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span>
            <span class="n">xa_</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">xa_</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span></div>

<div class="viewcode-block" id="TimeSeries.from_csv"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_csv">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_csv</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">filepath_or_buffer</span><span class="p">,</span>
        <span class="n">time_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">value_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fillna_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">static_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hierarchy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a deterministic TimeSeries instance built from a single CSV file.</span>
<span class="sd">        One column can be used to represent the time (if not present, the time index will be a RangeIndex)</span>
<span class="sd">        and a list of columns `value_cols` can be used to indicate the values for this time series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filepath_or_buffer</span>
<span class="sd">            The path to the CSV file, or the file object; consistent with the argument of `pandas.read_csv` function</span>
<span class="sd">        time_col</span>
<span class="sd">            The time column name. If set, the column will be cast to a pandas DatetimeIndex (if it contains</span>
<span class="sd">            timestamps) or a RangeIndex (if it contains integers).</span>
<span class="sd">            If not set, the pandas RangeIndex will be used.</span>
<span class="sd">        value_cols</span>
<span class="sd">            A string or list of strings representing the value column(s) to be extracted from the CSV file. If set to</span>
<span class="sd">            `None`, all columns from the CSV file will be used (except for the time_col, if specified)</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates (or indices in case of integer index)</span>
<span class="sd">            with NaN values. This requires either a provided `freq` or the possibility to infer the frequency from the</span>
<span class="sd">            provided timestamps. See :meth:`_fill_missing_dates() &lt;TimeSeries._fill_missing_dates&gt;` for more info.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string or integer representing the frequency of the underlying index. This is useful in order</span>
<span class="sd">            to fill in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>
<span class="sd">            If a string, represents the frequency of the pandas DatetimeIndex (see `offset aliases</span>
<span class="sd">            &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_ for more info on</span>
<span class="sd">            supported frequencies).</span>
<span class="sd">            If an integer, represents the step size of the pandas Index or pandas RangeIndex.</span>
<span class="sd">        fillna_value</span>
<span class="sd">            Optionally, a numeric value to fill missing values (NaNs) with.</span>
<span class="sd">        static_covariates</span>
<span class="sd">            Optionally, a set of static covariates to be added to the TimeSeries. Either a pandas Series or a pandas</span>
<span class="sd">            DataFrame. If a Series, the index represents the static variables. The covariates are globally &#39;applied&#39;</span>
<span class="sd">            to all components of the TimeSeries. If a DataFrame, the columns represent the static variables and the</span>
<span class="sd">            rows represent the components of the uni/multivariate TimeSeries. If a single-row DataFrame, the covariates</span>
<span class="sd">            are globally &#39;applied&#39; to all components of the TimeSeries. If a multi-row DataFrame, the number of</span>
<span class="sd">            rows must match the number of components of the TimeSeries (in this case, the number of columns in the CSV</span>
<span class="sd">            file). This adds control for component-specific static covariates.</span>
<span class="sd">        hierarchy</span>
<span class="sd">            Optionally, a dictionary describing the grouping(s) of the time series. The keys are component names, and</span>
<span class="sd">            for a given component name `c`, the value is a list of component names that `c` &quot;belongs&quot; to. For instance,</span>
<span class="sd">            if there is a `total` component, split both in two divisions `d1` and `d2` and in two regions `r1` and `r2`,</span>
<span class="sd">            and four products `d1r1` (in division `d1` and region `r1`), `d2r1`, `d1r2` and `d2r2`, the hierarchy would</span>
<span class="sd">            be encoded as follows.</span>

<span class="sd">            .. highlight:: python</span>
<span class="sd">            .. code-block:: python</span>

<span class="sd">                hierarchy={</span>
<span class="sd">                    &quot;d1r1&quot;: [&quot;d1&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d1r2&quot;: [&quot;d1&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d2r1&quot;: [&quot;d2&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d2r2&quot;: [&quot;d2&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;d2&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r2&quot;: [&quot;total&quot;]</span>
<span class="sd">                }</span>
<span class="sd">            ..</span>
<span class="sd">            The hierarchy can be used to reconcile forecasts (so that the sums of the forecasts at</span>
<span class="sd">            different levels are consistent), see `hierarchical reconciliation</span>
<span class="sd">            &lt;https://unit8co.github.io/darts/generated_api/darts.dataprocessing.transformers.reconciliation.html&gt;`_.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Optional arguments to be passed to `pandas.read_csv` function</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A univariate or multivariate deterministic TimeSeries constructed from the inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">filepath_or_buffer</span><span class="o">=</span><span class="n">filepath_or_buffer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
            <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
            <span class="n">value_cols</span><span class="o">=</span><span class="n">value_cols</span><span class="p">,</span>
            <span class="n">fill_missing_dates</span><span class="o">=</span><span class="n">fill_missing_dates</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">fillna_value</span><span class="o">=</span><span class="n">fillna_value</span><span class="p">,</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="n">static_covariates</span><span class="p">,</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="n">hierarchy</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.from_dataframe"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_dataframe">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dataframe</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">time_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">value_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fillna_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">static_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hierarchy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a deterministic TimeSeries instance built from a selection of columns of a DataFrame.</span>
<span class="sd">        One column (or the DataFrame index) has to represent the time,</span>
<span class="sd">        and a list of columns `value_cols` has to represent the values for this time series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df</span>
<span class="sd">            The DataFrame</span>
<span class="sd">        time_col</span>
<span class="sd">            The time column name. If set, the column will be cast to a pandas DatetimeIndex (if it contains</span>
<span class="sd">            timestamps) or a RangeIndex (if it contains integers).</span>
<span class="sd">            If not set, the DataFrame index will be used. In this case the DataFrame must contain an index that is</span>
<span class="sd">            either a pandas DatetimeIndex, a pandas RangeIndex, or a pandas Index that can be converted to a</span>
<span class="sd">            RangeIndex. It is better if the index has no holes; alternatively setting `fill_missing_dates` can in some</span>
<span class="sd">            cases solve these issues (filling holes with NaN, or with the provided `fillna_value` numeric value, if</span>
<span class="sd">            any).</span>
<span class="sd">        value_cols</span>
<span class="sd">            A string or list of strings representing the value column(s) to be extracted from the DataFrame. If set to</span>
<span class="sd">            `None`, the whole DataFrame will be used.</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates (or indices in case of integer index)</span>
<span class="sd">            with NaN values. This requires either a provided `freq` or the possibility to infer the frequency from the</span>
<span class="sd">            provided timestamps. See :meth:`_fill_missing_dates() &lt;TimeSeries._fill_missing_dates&gt;` for more info.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string or integer representing the frequency of the underlying index. This is useful in order</span>
<span class="sd">            to fill in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>
<span class="sd">            If a string, represents the frequency of the pandas DatetimeIndex (see `offset aliases</span>
<span class="sd">            &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_ for more info on</span>
<span class="sd">            supported frequencies).</span>
<span class="sd">            If an integer, represents the step size of the pandas Index or pandas RangeIndex.</span>
<span class="sd">        fillna_value</span>
<span class="sd">            Optionally, a numeric value to fill missing values (NaNs) with.</span>
<span class="sd">        static_covariates</span>
<span class="sd">            Optionally, a set of static covariates to be added to the TimeSeries. Either a pandas Series or a pandas</span>
<span class="sd">            DataFrame. If a Series, the index represents the static variables. The covariates are globally &#39;applied&#39;</span>
<span class="sd">            to all components of the TimeSeries. If a DataFrame, the columns represent the static variables and the</span>
<span class="sd">            rows represent the components of the uni/multivariate TimeSeries. If a single-row DataFrame, the covariates</span>
<span class="sd">            are globally &#39;applied&#39; to all components of the TimeSeries. If a multi-row DataFrame, the number of</span>
<span class="sd">            rows must match the number of components of the TimeSeries (in this case, the number of columns in</span>
<span class="sd">            ``value_cols``). This adds control for component-specific static covariates.</span>
<span class="sd">        hierarchy</span>
<span class="sd">            Optionally, a dictionary describing the grouping(s) of the time series. The keys are component names, and</span>
<span class="sd">            for a given component name `c`, the value is a list of component names that `c` &quot;belongs&quot; to. For instance,</span>
<span class="sd">            if there is a `total` component, split both in two divisions `d1` and `d2` and in two regions `r1` and `r2`,</span>
<span class="sd">            and four products `d1r1` (in division `d1` and region `r1`), `d2r1`, `d1r2` and `d2r2`, the hierarchy would</span>
<span class="sd">            be encoded as follows.</span>

<span class="sd">            .. highlight:: python</span>
<span class="sd">            .. code-block:: python</span>

<span class="sd">                hierarchy={</span>
<span class="sd">                    &quot;d1r1&quot;: [&quot;d1&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d1r2&quot;: [&quot;d1&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d2r1&quot;: [&quot;d2&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d2r2&quot;: [&quot;d2&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;d2&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r2&quot;: [&quot;total&quot;]</span>
<span class="sd">                }</span>
<span class="sd">            ..</span>
<span class="sd">            The hierarchy can be used to reconcile forecasts (so that the sums of the forecasts at</span>
<span class="sd">            different levels are consistent), see `hierarchical reconciliation</span>
<span class="sd">            &lt;https://unit8co.github.io/darts/generated_api/darts.dataprocessing.transformers.reconciliation.html&gt;`_.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A univariate or multivariate deterministic TimeSeries constructed from the inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get values</span>
        <span class="k">if</span> <span class="n">value_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">series_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">!=</span> <span class="n">time_col</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value_cols</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">value_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">value_cols</span><span class="p">]</span>
            <span class="n">series_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">value_cols</span><span class="p">]</span>

        <span class="c1"># get time index</span>
        <span class="k">if</span> <span class="n">time_col</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">time_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span><span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;time_col=&#39;</span><span class="si">{</span><span class="n">time_col</span><span class="si">}</span><span class="s2">&#39; is not present.&quot;</span><span class="p">))</span>

            <span class="n">time_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([])</span>
            <span class="n">time_col_vals</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">time_col_vals</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">object</span><span class="p">):</span>
                <span class="c1"># Try to convert to integers if needed</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">time_col_vals</span> <span class="o">=</span> <span class="n">time_col_vals</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">time_col_vals</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                <span class="c1"># We have to check all integers appear only once to have a valid index</span>
                <span class="n">raise_if</span><span class="p">(</span>
                    <span class="n">time_col_vals</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">(),</span>
                    <span class="s2">&quot;The provided integer time index column contains duplicate values.&quot;</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Temporarily use an integer Index to sort the values, and replace by a</span>
                <span class="c1"># RangeIndex in `TimeSeries.from_xarray()`</span>
                <span class="n">time_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">time_col_vals</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">time_col_vals</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">object</span><span class="p">):</span>
                <span class="c1"># The integer conversion failed; try datetimes</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">time_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">time_col_vals</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">raise_log</span><span class="p">(</span>
                        <span class="ne">AttributeError</span><span class="p">(</span>
                            <span class="s2">&quot;&#39;time_col&#39; is of &#39;object&#39; dtype but doesn&#39;t contain valid timestamps&quot;</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">time_col_vals</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">):</span>
                <span class="n">time_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">time_col_vals</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">AttributeError</span><span class="p">(</span>
                        <span class="s2">&quot;Invalid type of `time_col`: it needs to be of either &#39;str&#39;, &#39;datetime&#39; or &#39;int&#39; dtype.&quot;</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">time_index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">time_col</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">VALID_INDEX_TYPES</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">),</span>
                <span class="s2">&quot;If time_col is not specified, the DataFrame must be indexed either with &quot;</span>
                <span class="s2">&quot;a DatetimeIndex, a RangeIndex, or an integer Index that can be converted into a RangeIndex&quot;</span><span class="p">,</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># BUGFIX : force time-index to be timezone naive as xarray doesn&#39;t support it</span>
            <span class="c1"># pandas.DataFrame loses the tz information if it&#39;s not its index</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;The provided DatetimeIndex was associated with a timezone, which is currently not supported &quot;</span>
                    <span class="s2">&quot;by xarray. To avoid unexpected behaviour, the tz information was removed. Consider calling &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;`ts.time_index.tz_localize(</span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz</span><span class="si">}</span><span class="s2">)` when exporting the results.&quot;</span>
                    <span class="s2">&quot;To plot the series with the right time steps, consider setting the matplotlib.pyplot &quot;</span>
                    <span class="s2">&quot;`rcParams[&#39;timezone&#39;]` parameter to automatically convert the time axis back to the &quot;</span>
                    <span class="s2">&quot;original timezone.&quot;</span>
                <span class="p">)</span>
                <span class="n">time_index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">time_index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">time_index</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">time_index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">time_col</span> <span class="k">if</span> <span class="n">time_col</span> <span class="k">else</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">series_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">series_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">series_df</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">time_index</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span> <span class="o">+</span> <span class="n">DIMS</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="n">time_index</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">time_index</span><span class="p">,</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">series_df</span><span class="o">.</span><span class="n">columns</span><span class="p">},</span>
            <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="n">STATIC_COV_TAG</span><span class="p">:</span> <span class="n">static_covariates</span><span class="p">,</span> <span class="n">HIERARCHY_TAG</span><span class="p">:</span> <span class="n">hierarchy</span><span class="p">},</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_xarray</span><span class="p">(</span>
            <span class="n">xa</span><span class="o">=</span><span class="n">xa</span><span class="p">,</span>
            <span class="n">fill_missing_dates</span><span class="o">=</span><span class="n">fill_missing_dates</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">fillna_value</span><span class="o">=</span><span class="n">fillna_value</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.from_group_dataframe"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_group_dataframe">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_group_dataframe</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">group_cols</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">time_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">value_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">static_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fillna_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;TimeSeries&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a list of TimeSeries instances grouped by a selection of columns from a DataFrame.</span>
<span class="sd">        One column (or the DataFrame index) has to represent the time,</span>
<span class="sd">        a list of columns `group_cols` must be used for extracting the individual TimeSeries by groups,</span>
<span class="sd">        and a list of columns `value_cols` has to represent the values for the individual time series.</span>
<span class="sd">        Values from columns ``group_cols`` and ``static_cols`` are added as static covariates to the resulting</span>
<span class="sd">        TimeSeries objects. These can be viewed with `my_series.static_covariates`. Different to `group_cols`,</span>
<span class="sd">        `static_cols` only adds the static values but are not used to extract the TimeSeries groups.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df</span>
<span class="sd">            The DataFrame</span>
<span class="sd">        group_cols</span>
<span class="sd">            A string or list of strings representing the columns from the DataFrame by which to extract the</span>
<span class="sd">            individual TimeSeries groups.</span>
<span class="sd">        time_col</span>
<span class="sd">            The time column name. If set, the column will be cast to a pandas DatetimeIndex (if it contains</span>
<span class="sd">            timestamps) or a RangeIndex (if it contains integers).</span>
<span class="sd">            If not set, the DataFrame index will be used. In this case the DataFrame must contain an index that is</span>
<span class="sd">            either a pandas DatetimeIndex, a pandas RangeIndex, or a pandas Index that can be converted to a</span>
<span class="sd">            RangeIndex. Be aware that the index must represents the actual index of each individual time series group</span>
<span class="sd">            (can contain non-unique values). It is better if the index has no holes; alternatively setting</span>
<span class="sd">            `fill_missing_dates` can in some cases solve these issues (filling holes with NaN, or with the provided</span>
<span class="sd">            `fillna_value` numeric value, if any).</span>
<span class="sd">        value_cols</span>
<span class="sd">            A string or list of strings representing the value column(s) to be extracted from the DataFrame. If set to</span>
<span class="sd">            `None`, the whole DataFrame will be used.</span>
<span class="sd">        static_cols</span>
<span class="sd">            A string or list of strings representing static variable columns from the DataFrame that should be</span>
<span class="sd">            appended as static covariates to the resulting TimeSeries groups. Different to `group_cols`, the</span>
<span class="sd">            DataFrame is not grouped by these columns. Note that for every group, there must be exactly one</span>
<span class="sd">            unique value.</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates (or indices in case of integer index)</span>
<span class="sd">            with NaN values. This requires either a provided `freq` or the possibility to infer the frequency from the</span>
<span class="sd">            provided timestamps. See :meth:`_fill_missing_dates() &lt;TimeSeries._fill_missing_dates&gt;` for more info.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string or integer representing the frequency of the underlying index. This is useful in order</span>
<span class="sd">            to fill in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>
<span class="sd">            If a string, represents the frequency of the pandas DatetimeIndex (see `offset aliases</span>
<span class="sd">            &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_ for more info on</span>
<span class="sd">            supported frequencies).</span>
<span class="sd">            If an integer, represents the step size of the pandas Index or pandas RangeIndex.</span>
<span class="sd">        fillna_value</span>
<span class="sd">            Optionally, a numeric value to fill missing values (NaNs) with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[TimeSeries]</span>
<span class="sd">            A list containing a univariate or multivariate deterministic TimeSeries per group in the DataFrame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">time_col</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;UserWarning: `time_col` was not set and `df` has a monotonically increasing (time) index. This &quot;</span>
                <span class="s2">&quot;results in time series groups with non-overlapping (time) index. You can ignore this warning if the &quot;</span>
                <span class="s2">&quot;index represents the actual index of each individual time series group.&quot;</span>
            <span class="p">)</span>

        <span class="n">group_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">group_cols</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group_cols</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">group_cols</span>
        <span class="k">if</span> <span class="n">static_cols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">static_cols</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[</span><span class="n">static_cols</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">static_cols</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">static_cols</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">static_cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">static_cov_cols</span> <span class="o">=</span> <span class="n">group_cols</span> <span class="o">+</span> <span class="n">static_cols</span>

        <span class="c1"># split df by groups, and store group values and static values (static covariates)</span>
        <span class="c1"># single elements group columns must be unpacked for same groupby() behavior across different pandas versions</span>
        <span class="n">splits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">static_cov_vals</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
            <span class="n">group_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group_cols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">group_cols</span>
        <span class="p">):</span>
            <span class="n">static_cov_vals</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">static_cov_vals</span><span class="p">,)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">static_cov_vals</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">static_cov_vals</span>
            <span class="p">)</span>
            <span class="c1"># check that for each group there is only one unique value per column in `static_cols`</span>
            <span class="k">if</span> <span class="n">static_cols</span><span class="p">:</span>
                <span class="n">static_cols_valid</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">static_cols</span>
                <span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">static_cols_valid</span><span class="p">):</span>
                    <span class="c1"># encountered performance issues when evaluating the error message from below in every</span>
                    <span class="c1"># iteration with `raise_if_not(all(static_cols_valid), message, logger)`</span>
                    <span class="n">invalid_cols</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">static_col</span>
                        <span class="k">for</span> <span class="n">static_col</span><span class="p">,</span> <span class="n">is_valid</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">static_cols</span><span class="p">,</span> <span class="n">static_cols_valid</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_valid</span>
                    <span class="p">]</span>
                    <span class="n">raise_if</span><span class="p">(</span>
                        <span class="kc">True</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;Encountered more than one unique value in group </span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2"> for given static columns: &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">invalid_cols</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">,</span>
                        <span class="n">logger</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="c1"># add the static covariates to the group values</span>
                <span class="n">static_cov_vals</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="n">static_cols</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># store static covariate Series and group DataFrame (without static cov columns)</span>
            <span class="n">splits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">static_cov_vals</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">static_cov_cols</span><span class="p">),</span>
                    <span class="n">group</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">static_cov_cols</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># create a list with multiple TimeSeries and add static covariates</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">TimeSeries</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span>
                <span class="n">df</span><span class="o">=</span><span class="n">split</span><span class="p">,</span>
                <span class="n">time_col</span><span class="o">=</span><span class="n">time_col</span><span class="p">,</span>
                <span class="n">value_cols</span><span class="o">=</span><span class="n">value_cols</span><span class="p">,</span>
                <span class="n">fill_missing_dates</span><span class="o">=</span><span class="n">fill_missing_dates</span><span class="p">,</span>
                <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
                <span class="n">fillna_value</span><span class="o">=</span><span class="n">fillna_value</span><span class="p">,</span>
                <span class="n">static_covariates</span><span class="o">=</span><span class="n">static_covs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">static_covs</span><span class="p">,</span> <span class="n">split</span> <span class="ow">in</span> <span class="n">splits</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.from_series"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_series">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_series</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">pd_series</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
        <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fillna_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">static_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a univariate deterministic series from a pandas Series.</span>

<span class="sd">        The series must contain an index that is either a pandas DatetimeIndex, a pandas RangeIndex, or a pandas Index</span>
<span class="sd">        that can be converted into a RangeIndex. It is better if the index has no holes; alternatively setting</span>
<span class="sd">        `fill_missing_dates` can in some cases solve these issues (filling holes with NaN, or with the provided</span>
<span class="sd">        `fillna_value` numeric value, if any).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pd_series</span>
<span class="sd">            The pandas Series instance.</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates (or indices in case of integer index)</span>
<span class="sd">            with NaN values. This requires either a provided `freq` or the possibility to infer the frequency from the</span>
<span class="sd">            provided timestamps. See :meth:`_fill_missing_dates() &lt;TimeSeries._fill_missing_dates&gt;` for more info.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string or integer representing the frequency of the underlying index. This is useful in order</span>
<span class="sd">            to fill in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>
<span class="sd">            If a string, represents the frequency of the pandas DatetimeIndex (see `offset aliases</span>
<span class="sd">            &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_ for more info on</span>
<span class="sd">            supported frequencies).</span>
<span class="sd">            If an integer, represents the step size of the pandas Index or pandas RangeIndex.</span>
<span class="sd">        fillna_value</span>
<span class="sd">            Optionally, a numeric value to fill missing values (NaNs) with.</span>
<span class="sd">        static_covariates</span>
<span class="sd">            Optionally, a set of static covariates to be added to the TimeSeries. Either a pandas Series or a</span>
<span class="sd">            single-row pandas DataFrame. If a Series, the index represents the static variables. If a DataFrame, the</span>
<span class="sd">            columns represent the static variables and the single row represents the univariate TimeSeries component.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A univariate and deterministic TimeSeries constructed from the inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pd_series</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span>
            <span class="n">time_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">value_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">fill_missing_dates</span><span class="o">=</span><span class="n">fill_missing_dates</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">fillna_value</span><span class="o">=</span><span class="n">fillna_value</span><span class="p">,</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="n">static_covariates</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.from_times_and_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_times_and_values">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_times_and_values</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">times</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">],</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">fill_missing_dates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">_typing</span><span class="o">.</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fillna_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">static_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hierarchy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a series from a time index and value array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times</span>
<span class="sd">            A pandas DateTimeIndex, RangeIndex, or Index that can be converted to a RangeIndex representing the time</span>
<span class="sd">            axis for the time series. It is better if the index has no holes; alternatively setting</span>
<span class="sd">            `fill_missing_dates` can in some cases solve these issues (filling holes with NaN, or with the provided</span>
<span class="sd">            `fillna_value` numeric value, if any).</span>
<span class="sd">        values</span>
<span class="sd">            A Numpy array of values for the TimeSeries. Both 2-dimensional arrays, for deterministic series,</span>
<span class="sd">            and 3-dimensional arrays, for probabilistic series, are accepted. In the former case the dimensions</span>
<span class="sd">            should be (time, component), and in the latter case (time, component, sample).</span>
<span class="sd">        fill_missing_dates</span>
<span class="sd">            Optionally, a boolean value indicating whether to fill missing dates (or indices in case of integer index)</span>
<span class="sd">            with NaN values. This requires either a provided `freq` or the possibility to infer the frequency from the</span>
<span class="sd">            provided timestamps. See :meth:`_fill_missing_dates() &lt;TimeSeries._fill_missing_dates&gt;` for more info.</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string or integer representing the frequency of the underlying index. This is useful in order</span>
<span class="sd">            to fill in missing values if some dates are missing and `fill_missing_dates` is set to `True`.</span>
<span class="sd">            If a string, represents the frequency of the pandas DatetimeIndex (see `offset aliases</span>
<span class="sd">            &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_ for more info on</span>
<span class="sd">            supported frequencies).</span>
<span class="sd">            If an integer, represents the step size of the pandas Index or pandas RangeIndex.</span>
<span class="sd">        columns</span>
<span class="sd">            Columns to be used by the underlying pandas DataFrame.</span>
<span class="sd">        fillna_value</span>
<span class="sd">            Optionally, a numeric value to fill missing values (NaNs) with.</span>
<span class="sd">        static_covariates</span>
<span class="sd">            Optionally, a set of static covariates to be added to the TimeSeries. Either a pandas Series or a pandas</span>
<span class="sd">            DataFrame. If a Series, the index represents the static variables. The covariates are globally &#39;applied&#39;</span>
<span class="sd">            to all components of the TimeSeries. If a DataFrame, the columns represent the static variables and the</span>
<span class="sd">            rows represent the components of the uni/multivariate TimeSeries. If a single-row DataFrame, the covariates</span>
<span class="sd">            are globally &#39;applied&#39; to all components of the TimeSeries. If a multi-row DataFrame, the number of</span>
<span class="sd">            rows must match the number of components of the TimeSeries (in this case, the number of columns in</span>
<span class="sd">            ``values``). This adds control for component-specific static covariates.</span>
<span class="sd">        hierarchy</span>
<span class="sd">            Optionally, a dictionary describing the grouping(s) of the time series. The keys are component names, and</span>
<span class="sd">            for a given component name `c`, the value is a list of component names that `c` &quot;belongs&quot; to. For instance,</span>
<span class="sd">            if there is a `total` component, split both in two divisions `d1` and `d2` and in two regions `r1` and `r2`,</span>
<span class="sd">            and four products `d1r1` (in division `d1` and region `r1`), `d2r1`, `d1r2` and `d2r2`, the hierarchy would</span>
<span class="sd">            be encoded as follows.</span>

<span class="sd">            .. highlight:: python</span>
<span class="sd">            .. code-block:: python</span>

<span class="sd">                hierarchy={</span>
<span class="sd">                    &quot;d1r1&quot;: [&quot;d1&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d1r2&quot;: [&quot;d1&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d2r1&quot;: [&quot;d2&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d2r2&quot;: [&quot;d2&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;d2&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r2&quot;: [&quot;total&quot;]</span>
<span class="sd">                }</span>
<span class="sd">            ..</span>
<span class="sd">            The hierarchy can be used to reconcile forecasts (so that the sums of the forecasts at</span>
<span class="sd">            different levels are consistent), see `hierarchical reconciliation</span>
<span class="sd">            &lt;https://unit8co.github.io/darts/generated_api/darts.dataprocessing.transformers.reconciliation.html&gt;`_.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A TimeSeries constructed from the inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">VALID_INDEX_TYPES</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">times</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">),</span>
            <span class="s2">&quot;the `times` argument must be a RangeIndex, or a DateTimeIndex. Use &quot;</span>
            <span class="s2">&quot;TimeSeries.from_values() if you want to use an automatic RangeIndex.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># BUGFIX : force time-index to be timezone naive as xarray doesn&#39;t support it</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="n">times</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;The `times` argument was associated with a timezone, which is currently not supported &quot;</span>
                <span class="s2">&quot;by xarray. To avoid unexpected behaviour, the tz information was removed. Consider calling &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`ts.time_index.tz_localize(</span><span class="si">{</span><span class="n">times</span><span class="o">.</span><span class="n">tz</span><span class="si">}</span><span class="s2">)` when exporting the results.&quot;</span>
                <span class="s2">&quot;To plot the series with the right time steps, consider setting the matplotlib.pyplot &quot;</span>
                <span class="s2">&quot;`rcParams[&#39;timezone&#39;]` parameter to automatically convert the time axis back to the &quot;</span>
                <span class="s2">&quot;original timezone.&quot;</span>
            <span class="p">)</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">times_name</span> <span class="o">=</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">times</span><span class="o">.</span><span class="n">name</span> <span class="k">else</span> <span class="n">times</span><span class="o">.</span><span class="n">name</span>

        <span class="c1"># avoid copying if data is already np.ndarray:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">values</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">times_name</span><span class="p">:</span> <span class="n">times</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span><span class="p">[</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">columns</span>

        <span class="n">xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">values</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">times_name</span><span class="p">,)</span> <span class="o">+</span> <span class="n">DIMS</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="n">STATIC_COV_TAG</span><span class="p">:</span> <span class="n">static_covariates</span><span class="p">,</span> <span class="n">HIERARCHY_TAG</span><span class="p">:</span> <span class="n">hierarchy</span><span class="p">},</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_xarray</span><span class="p">(</span>
            <span class="n">xa</span><span class="o">=</span><span class="n">xa</span><span class="p">,</span>
            <span class="n">fill_missing_dates</span><span class="o">=</span><span class="n">fill_missing_dates</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">fillna_value</span><span class="o">=</span><span class="n">fillna_value</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.from_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_values">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_values</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">_typing</span><span class="o">.</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fillna_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">static_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hierarchy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an integer-indexed series from an array of values.</span>
<span class="sd">        The series will have an integer index (RangeIndex).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values</span>
<span class="sd">            A Numpy array of values for the TimeSeries. Both 2-dimensional arrays, for deterministic series,</span>
<span class="sd">            and 3-dimensional arrays, for probabilistic series, are accepted. In the former case the dimensions</span>
<span class="sd">            should be (time, component), and in the latter case (time, component, sample).</span>
<span class="sd">        columns</span>
<span class="sd">            Columns to be used by the underlying pandas DataFrame.</span>
<span class="sd">        fillna_value</span>
<span class="sd">            Optionally, a numeric value to fill missing values (NaNs) with.</span>
<span class="sd">        static_covariates</span>
<span class="sd">            Optionally, a set of static covariates to be added to the TimeSeries. Either a pandas Series or a pandas</span>
<span class="sd">            DataFrame. If a Series, the index represents the static variables. The covariates are globally &#39;applied&#39;</span>
<span class="sd">            to all components of the TimeSeries. If a DataFrame, the columns represent the static variables and the</span>
<span class="sd">            rows represent the components of the uni/multivariate TimeSeries. If a single-row DataFrame, the covariates</span>
<span class="sd">            are globally &#39;applied&#39; to all components of the TimeSeries. If a multi-row DataFrame, the number of</span>
<span class="sd">            rows must match the number of components of the TimeSeries (in this case, the number of columns in</span>
<span class="sd">            ``values``). This adds control for component-specific static covariates.</span>
<span class="sd">        hierarchy</span>
<span class="sd">            Optionally, a dictionary describing the grouping(s) of the time series. The keys are component names, and</span>
<span class="sd">            for a given component name `c`, the value is a list of component names that `c` &quot;belongs&quot; to. For instance,</span>
<span class="sd">            if there is a `total` component, split both in two divisions `d1` and `d2` and in two regions `r1` and `r2`,</span>
<span class="sd">            and four products `d1r1` (in division `d1` and region `r1`), `d2r1`, `d1r2` and `d2r2`, the hierarchy would</span>
<span class="sd">            be encoded as follows.</span>

<span class="sd">            .. highlight:: python</span>
<span class="sd">            .. code-block:: python</span>

<span class="sd">                hierarchy={</span>
<span class="sd">                    &quot;d1r1&quot;: [&quot;d1&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d1r2&quot;: [&quot;d1&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d2r1&quot;: [&quot;d2&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d2r2&quot;: [&quot;d2&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;d2&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r2&quot;: [&quot;total&quot;]</span>
<span class="sd">                }</span>
<span class="sd">            ..</span>
<span class="sd">            The hierarchy can be used to reconcile forecasts (so that the sums of the forecasts at</span>
<span class="sd">            different levels are consistent), see `hierarchical reconciliation</span>
<span class="sd">            &lt;https://unit8co.github.io/darts/generated_api/darts.dataprocessing.transformers.reconciliation.html&gt;`_.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A TimeSeries constructed from the inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">values_</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">values</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_times_and_values</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">time_index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">values_</span><span class="p">,</span>
            <span class="n">fill_missing_dates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">fillna_value</span><span class="o">=</span><span class="n">fillna_value</span><span class="p">,</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="n">static_covariates</span><span class="p">,</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="n">hierarchy</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.from_json"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_json">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">json_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">static_covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hierarchy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a series from the JSON String representation of a ``TimeSeries``</span>
<span class="sd">        (produced using :func:`TimeSeries.to_json()`).</span>

<span class="sd">        At the moment this only supports deterministic time series (i.e., made of 1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        json_str</span>
<span class="sd">            The JSON String to convert</span>
<span class="sd">        static_covariates</span>
<span class="sd">            Optionally, a set of static covariates to be added to the TimeSeries. Either a pandas Series or a pandas</span>
<span class="sd">            DataFrame. If a Series, the index represents the static variables. The covariates are globally &#39;applied&#39;</span>
<span class="sd">            to all components of the TimeSeries. If a DataFrame, the columns represent the static variables and the</span>
<span class="sd">            rows represent the components of the uni/multivariate TimeSeries. If a single-row DataFrame, the covariates</span>
<span class="sd">            are globally &#39;applied&#39; to all components of the TimeSeries. If a multi-row DataFrame, the number of</span>
<span class="sd">            rows must match the number of components of the TimeSeries (in this case, the number of columns in</span>
<span class="sd">            ``value_cols``). This adds control for component-specific static covariates.</span>
<span class="sd">        hierarchy</span>
<span class="sd">            Optionally, a dictionary describing the grouping(s) of the time series. The keys are component names, and</span>
<span class="sd">            for a given component name `c`, the value is a list of component names that `c` &quot;belongs&quot; to. For instance,</span>
<span class="sd">            if there is a `total` component, split both in two divisions `d1` and `d2` and in two regions `r1` and `r2`,</span>
<span class="sd">            and four products `d1r1` (in division `d1` and region `r1`), `d2r1`, `d1r2` and `d2r2`, the hierarchy would</span>
<span class="sd">            be encoded as follows.</span>

<span class="sd">            .. highlight:: python</span>
<span class="sd">            .. code-block:: python</span>

<span class="sd">                hierarchy={</span>
<span class="sd">                    &quot;d1r1&quot;: [&quot;d1&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d1r2&quot;: [&quot;d1&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d2r1&quot;: [&quot;d2&quot;, &quot;r1&quot;],</span>
<span class="sd">                    &quot;d2r2&quot;: [&quot;d2&quot;, &quot;r2&quot;],</span>
<span class="sd">                    &quot;d1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;d2&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r1&quot;: [&quot;total&quot;],</span>
<span class="sd">                    &quot;r2&quot;: [&quot;total&quot;]</span>
<span class="sd">                }</span>
<span class="sd">            ..</span>
<span class="sd">            The hierarchy can be used to reconcile forecasts (so that the sums of the forecasts at</span>
<span class="sd">            different levels are consistent), see `hierarchical reconciliation</span>
<span class="sd">            &lt;https://unit8co.github.io/darts/generated_api/darts.dataprocessing.transformers.reconciliation.html&gt;`_.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The time series object converted from the JSON String</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_json</span><span class="p">(</span><span class="n">json_str</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s2">&quot;split&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span> <span class="n">static_covariates</span><span class="o">=</span><span class="n">static_covariates</span><span class="p">,</span> <span class="n">hierarchy</span><span class="o">=</span><span class="n">hierarchy</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.from_pickle"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.from_pickle">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_pickle</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a pickled ``TimeSeries``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : string</span>
<span class="sd">            path pointing to a pickle file that will be loaded</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            timeseries object loaded from file</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Xarray docs [1]_ suggest not using pickle as a long-term data storage.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] http://xarray.pydata.org/en/stable/user-guide/io.html#pickle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Properties</span>
<span class="sd">    ==========</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">static_covariates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the static covariates contained in the series as a pandas DataFrame.</span>
<span class="sd">        The columns represent the static variables and the rows represent the components of the uni/multivariate</span>
<span class="sd">        series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">STATIC_COV_TAG</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hierarchy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The hierarchy of this TimeSeries, if any.</span>
<span class="sd">        If set, the hierarchy is encoded as a dictionary, whose keys are individual components</span>
<span class="sd">        and values are the set of parent(s) of these components in the hierarchy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">HIERARCHY_TAG</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_hierarchy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether this series is hierarchical or not.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">top_level_component</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The top level component name of this series, or None if the series has no hierarchy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_level_component</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bottom_level_components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The bottom level component names of this series, or None if the series has no hierarchy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bottom_level_components</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">top_level_series</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;TimeSeries&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The univariate series containing the single top-level component of this series,</span>
<span class="sd">        or None if the series has no hierarchy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">top_level_component</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_hierarchy</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bottom_level_series</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="s2">&quot;TimeSeries&quot;</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The series containing the bottom-level components of this series in the same</span>
<span class="sd">        order as they appear in the series, or None if the series has no hierarchy.</span>

<span class="sd">        The returned series is multivariate if there are multiple bottom components.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="p">[[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottom_level_components</span><span class="p">]]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_hierarchy</span>
            <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of samples contained in the series.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sample</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of components (dimensions) contained in the series.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">component</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; &quot;Width&quot; (= number of components) of the series.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_timesteps</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of time steps in the series.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether this series is deterministic.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_stochastic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether this series is stochastic.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_probabilistic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether this series is stochastic (= probabilistic).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stochastic</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_univariate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether this series is univariate.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">freq</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The frequency of the series.</span>
<span class="sd">        A `pd.DateOffset` if series is indexed with a `pd.DatetimeIndex`.</span>
<span class="sd">        An integer (step size) if series is indexed with a `pd.RangeIndex`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">freq_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The frequency string representation of the series.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq_str</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The dtype of the series&#39; values.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The names of the components, as a Pandas Index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The names of the components, as a Pandas Index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The time index of this time series.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The name of the time dimension for this time series.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_datetime_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether this series is indexed with a DatetimeIndex (otherwise it is indexed with an RangeIndex).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_range_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether this series is indexed with an RangeIndex (otherwise it is indexed with a DatetimeIndex).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_static_covariates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether this series contains static covariates.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">duration</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The duration of this time series (as a time delta or int).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Some asserts</span>
<span class="sd">    =============</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO: put at the bottom</span>

    <span class="k">def</span> <span class="nf">_assert_univariate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_univariate</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="s2">&quot;Only univariate TimeSeries instances support this method&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_assert_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="s2">&quot;Only deterministic TimeSeries (with 1 sample) instances support this method&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_assert_stochastic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stochastic</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="s2">&quot;Only non-deterministic TimeSeries (with more than 1 samples) &quot;</span>
                    <span class="s2">&quot;instances support this method&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_raise_if_not_within</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="c1"># Not that the converse doesn&#39;t apply (a time-indexed series can be called with an integer)</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">,</span>
                <span class="s2">&quot;Function called with a timestamp, but series not time-indexed.&quot;</span><span class="p">,</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">is_inside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
                <span class="n">is_inside</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_inside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span>

        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="n">is_inside</span><span class="p">,</span>
            <span class="s2">&quot;Timestamp must be between </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span>
            <span class="p">),</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_first_timestamp_after</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="n">ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_last_timestamp_before</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Export functions</span>
<span class="sd">    ================</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TimeSeries.data_array"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.data_array">[docs]</a>    <span class="k">def</span> <span class="nf">data_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ``xarray.DataArray`` representation underlying this series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the series. Leave it to True unless you know what you are doing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataArray</span>
<span class="sd">            The xarray DataArray underlying this time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span></div>

<div class="viewcode-block" id="TimeSeries.pd_series"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.pd_series">[docs]</a>    <span class="k">def</span> <span class="nf">pd_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a Pandas Series representation of this univariate deterministic time series.</span>

<span class="sd">        Works only for univariate series that are deterministic (i.e., made of 1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the series. Leave it to True unless you know what you are doing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.Series</span>
<span class="sd">            A Pandas Series representation of this univariate time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_univariate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.pd_dataframe"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.pd_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">pd_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a Pandas DataFrame representation of this time series.</span>

<span class="sd">        Each of the series components will appear as a column in the DataFrame.</span>
<span class="sd">        If the series is stochastic, the samples are returned as columns of the dataframe with column names</span>
<span class="sd">        as &#39;component_s#&#39; (e.g. with two components and two samples:</span>
<span class="sd">        &#39;comp0_s0&#39;, &#39;comp0_s1&#39; &#39;comp1_s0&#39; &#39;comp1_s1&#39;).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the dataframe. Leave it to True unless you know what you are doing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            The Pandas DataFrame representation of this time series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">suppress_warnings</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;You are transforming a stochastic TimeSeries (i.e., contains several samples). &quot;</span>
                    <span class="s2">&quot;The resulting DataFrame is a 2D object with all samples on the columns. &quot;</span>
                    <span class="s2">&quot;If this is not the expected behavior consider calling a function &quot;</span>
                    <span class="s2">&quot;adapted to stochastic TimeSeries like quantile_df().&quot;</span>
                <span class="p">)</span>

            <span class="n">comp_name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">)</span>
            <span class="n">df_col_names</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;_s&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">comp_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">sample_id</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">comp_name</span><span class="p">,</span> <span class="n">sample_id</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">comp_name</span><span class="p">,</span> <span class="n">samples</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                    <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                    <span class="n">columns</span><span class="o">=</span><span class="n">df_col_names</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                    <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
                    <span class="n">columns</span><span class="o">=</span><span class="n">df_col_names</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                    <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                    <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                    <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
                    <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.quantile_df"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.quantile_df">[docs]</a>    <span class="k">def</span> <span class="nf">quantile_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantile</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a Pandas DataFrame containing the single desired quantile of each component (over the samples).</span>

<span class="sd">        Each of the series components will appear as a column in the DataFrame. The column will be named</span>
<span class="sd">        &quot;&lt;component&gt;_X&quot;, where &quot;&lt;component&gt;&quot; is the column name corresponding to this component, and &quot;X&quot;</span>
<span class="sd">        is the quantile value.</span>
<span class="sd">        The quantile columns represent the marginal distributions of the components of this series.</span>

<span class="sd">        This works only on stochastic series (i.e., with more than 1 sample)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        quantile</span>
<span class="sd">            The desired quantile value. The value must be represented as a fraction</span>
<span class="sd">            (between 0 and 1 inclusive). For instance, `0.5` will return a DataFrame</span>
<span class="sd">            containing the median of the (marginal) distribution of each component.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            The Pandas DataFrame containing the desired quantile for each component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_stochastic</span><span class="p">()</span>
        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">quantile</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;The quantile values must be expressed as fraction (between 0 and 1 inclusive).&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># column names</span>
        <span class="n">cnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">quantile</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">quantile</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">cnames</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.quantile_timeseries"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.quantile_timeseries">[docs]</a>    <span class="k">def</span> <span class="nf">quantile_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantile</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a deterministic ``TimeSeries`` containing the single desired quantile of each component</span>
<span class="sd">        (over the samples) of this stochastic ``TimeSeries``.</span>

<span class="sd">        The components in the new series are named &quot;&lt;component&gt;_X&quot;, where &quot;&lt;component&gt;&quot;</span>
<span class="sd">        is the column name corresponding to this component, and &quot;X&quot; is the quantile value.</span>
<span class="sd">        The quantile columns represent the marginal distributions of the components of this series.</span>

<span class="sd">        This works only on stochastic series (i.e., with more than 1 sample)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        quantile</span>
<span class="sd">            The desired quantile value. The value must be represented as a fraction</span>
<span class="sd">            (between 0 and 1 inclusive). For instance, `0.5` will return a TimeSeries</span>
<span class="sd">            containing the median of the (marginal) distribution of each component.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Other keyword arguments are passed down to `numpy.quantile()`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The TimeSeries containing the desired quantile for each component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_stochastic</span><span class="p">()</span>
        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">quantile</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;The quantile values must be expressed as fraction (between 0 and 1 inclusive).&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># component names</span>
        <span class="n">cnames</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">quantile</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">]</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">q</span><span class="o">=</span><span class="n">quantile</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">new_xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">new_data</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">,</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cnames</span><span class="p">)},</span>
            <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.quantiles_df"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.quantiles_df">[docs]</a>    <span class="k">def</span> <span class="nf">quantiles_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a Pandas DataFrame containing the desired quantiles of each component (over the samples).</span>

<span class="sd">        Each of the series components will appear as a column in the DataFrame. The column will be named</span>
<span class="sd">        &quot;&lt;component&gt;_X&quot;, where &quot;&lt;component&gt;&quot; is the column name corresponding to this component, and &quot;X&quot;</span>
<span class="sd">        is the quantile value.</span>
<span class="sd">        The quantiles represent the marginal distributions of the components of this series.</span>

<span class="sd">        This works only on stochastic series (i.e., with more than 1 sample)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        quantiles</span>
<span class="sd">            Tuple containing the desired quantiles. The values must be represented as fractions</span>
<span class="sd">            (between 0 and 1 inclusive). For instance, `(0.1, 0.5, 0.9)` will return a DataFrame</span>
<span class="sd">            containing the 10th-percentile, median and 90th-percentile of the (marginal) distribution of each component.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            The Pandas DataFrame containing the quantiles for each component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">quantile_timeseries</span><span class="p">(</span><span class="n">quantile</span><span class="p">)</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">quantile</span> <span class="ow">in</span> <span class="n">quantiles</span>
            <span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.astype"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.astype">[docs]</a>    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts this series to a new series with desired dtype.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype</span>
<span class="sd">            A NumPy dtype (np.float32 or np.float64)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A TimeSeries having the desired dtype.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span></div>

<div class="viewcode-block" id="TimeSeries.start_time"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.start_time">[docs]</a>    <span class="k">def</span> <span class="nf">start_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Start time of the series.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pandas.Timestamp, int]</span>
<span class="sd">            A timestamp containing the first time of the TimeSeries (if indexed by DatetimeIndex),</span>
<span class="sd">            or an integer (if indexed by RangeIndex)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.end_time"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.end_time">[docs]</a>    <span class="k">def</span> <span class="nf">end_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        End time of the series.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[pandas.Timestamp, int]</span>
<span class="sd">            A timestamp containing the last time of the TimeSeries (if indexed by DatetimeIndex),</span>
<span class="sd">            or an integer (if indexed by RangeIndex)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.first_value"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.first_value">[docs]</a>    <span class="k">def</span> <span class="nf">first_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        First value of this univariate series.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The first value of this univariate deterministic time series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_univariate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="TimeSeries.last_value"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.last_value">[docs]</a>    <span class="k">def</span> <span class="nf">last_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Last value of this univariate series.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The last value of this univariate deterministic time series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_univariate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="TimeSeries.first_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.first_values">[docs]</a>    <span class="k">def</span> <span class="nf">first_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        First values of this potentially multivariate series.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            The first values of every component of this deterministic time series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="TimeSeries.last_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.last_values">[docs]</a>    <span class="k">def</span> <span class="nf">last_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Last values of this potentially multivariate series.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            The last values of every component of this deterministic time series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="TimeSeries.values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.values">[docs]</a>    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">sample</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a 2-D array of shape (time, component), containing this series&#39; values for one `sample`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the values, otherwise returns a view.</span>
<span class="sd">            Leave it to True unless you know what you are doing.</span>
<span class="sd">        sample</span>
<span class="sd">            For stochastic series, the sample for which to return values. Default: 0 (first sample).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The values composing the time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_if</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span> <span class="ow">and</span> <span class="n">sample</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;This series contains one sample only (deterministic),&quot;</span>
            <span class="s2">&quot;so only sample=0 is accepted.&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">sample</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">sample</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.random_component_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.random_component_values">[docs]</a>    <span class="k">def</span> <span class="nf">random_component_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a 2-D array of shape (time, component), containing the values for</span>
<span class="sd">        one sample taken uniformly at random among this series&#39; samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the values, otherwise returns a view.</span>
<span class="sd">            Leave it to True unless you know what you are doing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The values composing one sample taken at random from the time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">sample</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">sample</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.all_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.all_values">[docs]</a>    <span class="k">def</span> <span class="nf">all_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a 3-D array of dimension (time, component, sample),</span>
<span class="sd">        containing this series&#39; values for all samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the values, otherwise returns a view.</span>
<span class="sd">            Leave it to True unless you know what you are doing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The values composing the time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span></div>

<div class="viewcode-block" id="TimeSeries.univariate_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.univariate_values">[docs]</a>    <span class="k">def</span> <span class="nf">univariate_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">sample</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a 1-D Numpy array of shape (time,),</span>
<span class="sd">        containing this univariate series&#39; values for one `sample`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the values. Leave it to True unless you know what you are doing.</span>
<span class="sd">        sample</span>
<span class="sd">            For stochastic series, the sample for which to return values. Default: 0 (first sample).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The values composing the time series guaranteed to be univariate.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_univariate</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sample</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sample</span><span class="p">]</span><span class="o">.</span><span class="n">values</span></div>

<div class="viewcode-block" id="TimeSeries.static_covariates_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.static_covariates_values">[docs]</a>    <span class="k">def</span> <span class="nf">static_covariates_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a 2-D array of dimension (component, static variable),</span>
<span class="sd">        containing the static covariate values of the TimeSeries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy</span>
<span class="sd">            Whether to return a copy of the values, otherwise returns a view.</span>
<span class="sd">            Can only return a view if all values have the same dtype.</span>
<span class="sd">            Leave it to True unless you know what you are doing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Optional[numpy.ndarray]</span>
<span class="sd">            The static covariate values if the series has static covariates, else `None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_static_covariates</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.head"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.head">[docs]</a>    <span class="k">def</span> <span class="nf">head</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a TimeSeries containing the first `size` points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : int, default 5</span>
<span class="sd">               number of points to retain</span>
<span class="sd">        axis : str or int, optional, default: 0</span>
<span class="sd">               axis along which to slice the series</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The series made of the first `size` points along the desired `axis`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">axis_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dim_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">display_n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">axis_str</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">axis_str</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[:</span><span class="n">display_n</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[{</span><span class="n">axis_str</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="n">display_n</span><span class="p">)}])</span></div>

<div class="viewcode-block" id="TimeSeries.tail"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.tail">[docs]</a>    <span class="k">def</span> <span class="nf">tail</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return last `size` points of the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : int, default: 5</span>
<span class="sd">            number of points to retain</span>
<span class="sd">        axis : str or int, optional, default: 0 (time dimension)</span>
<span class="sd">            axis along which we intend to display records</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The series made of the last `size` points along the desired `axis`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">axis_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dim_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">display_n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">axis_str</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">axis_str</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="n">display_n</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[{</span><span class="n">axis_str</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">display_n</span><span class="p">,</span> <span class="mi">0</span><span class="p">)}])</span></div>

<div class="viewcode-block" id="TimeSeries.concatenate"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.concatenate">[docs]</a>    <span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;TimeSeries&quot;</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">ignore_time_axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_static_covariates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">drop_hierarchy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;TimeSeries&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate another timeseries to the current one along given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : TimeSeries</span>
<span class="sd">            another timeseries to concatenate to this one</span>
<span class="sd">        axis : str or int</span>
<span class="sd">            axis along which timeseries will be concatenated. [&#39;time&#39;, &#39;component&#39; or &#39;sample&#39;; Default: 0 (time)]</span>
<span class="sd">        ignore_time_axis : bool, default False</span>
<span class="sd">            Ignore errors when time axis varies for some timeseries. Note that this may yield unexpected results</span>
<span class="sd">        ignore_static_covariates : bool</span>
<span class="sd">            whether to ignore all requirements for static covariate concatenation and only transfer the</span>
<span class="sd">            static covariates of the first TimeSeries element in `series` to the concatenated TimeSeries.</span>
<span class="sd">            Only effective when `axis=1`.</span>
<span class="sd">        drop_hierarchy : bool</span>
<span class="sd">            When `axis=1`, whether to drop hierarchy information. True by default.</span>
<span class="sd">            When False, the hierarchies will be &quot;concatenated&quot; as well</span>
<span class="sd">            (by merging the hierarchy dictionaries), which may cause issues if the component</span>
<span class="sd">            names of the resulting series and that of the merged hierarchy do not match.</span>
<span class="sd">            When `axis=0` or `axis=2`, the hierarchy of the first series is always kept.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            concatenated timeseries</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        concatenate : a function to concatenate multiple series along a given axis.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When concatenating along the `time` dimension, the current series marks the start date of</span>
<span class="sd">        the resulting series, and the other series will have its time index ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span>
            <span class="n">series</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">ignore_time_axis</span><span class="o">=</span><span class="n">ignore_time_axis</span><span class="p">,</span>
            <span class="n">ignore_static_covariates</span><span class="o">=</span><span class="n">ignore_static_covariates</span><span class="p">,</span>
            <span class="n">drop_hierarchy</span><span class="o">=</span><span class="n">drop_hierarchy</span><span class="p">,</span>
        <span class="p">)</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Other methods</span>
<span class="sd">    =============</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TimeSeries.gaps"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.gaps">[docs]</a>    <span class="k">def</span> <span class="nf">gaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;any&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function to compute and return gaps in the TimeSeries. Works only on deterministic time series (1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode</span>
<span class="sd">            Only relevant for multivariate time series. The mode defines how gaps are defined. Set to</span>
<span class="sd">            &#39;any&#39; if a NaN value in any columns should be considered as as gaps. &#39;all&#39; will only</span>
<span class="sd">            consider periods where all columns&#39; values are NaN. Defaults to &#39;all&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">            A pandas.DataFrame containing a row for every gap (rows with all-NaN values in underlying DataFrame)</span>
<span class="sd">            in this time series. The DataFrame contains three columns that include the start and end time stamps</span>
<span class="sd">            of the gap and the integer length of the gap (in `self.freq` units if the series is indexed</span>
<span class="sd">            by a DatetimeIndex).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">is_nan_series</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;any&quot;</span><span class="p">:</span>
            <span class="n">is_nan_series</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Keyword mode accepts only &#39;any&#39; or &#39;all&#39;. Provided </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">is_nan_series</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">is_nan_series</span><span class="o">.</span><span class="n">index</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">gap_starts</span> <span class="o">=</span> <span class="n">diff</span><span class="p">[</span><span class="n">diff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>
        <span class="n">gap_ends</span> <span class="o">=</span> <span class="n">diff</span><span class="p">[</span><span class="n">diff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>

        <span class="k">if</span> <span class="n">is_nan_series</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">gap_starts</span> <span class="o">=</span> <span class="n">gap_starts</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">is_nan_series</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">gap_ends</span> <span class="o">=</span> <span class="n">gap_ends</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gap_ends</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">())</span>

        <span class="n">gap_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;gap_start&quot;</span><span class="p">,</span> <span class="s2">&quot;gap_end&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">gap_starts</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gap_df</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">intvl</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">)</span><span class="o">.</span><span class="n">size</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">int</span><span class="p">((</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">gap_df</span><span class="p">[</span><span class="s2">&quot;gap_start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gap_starts</span>
            <span class="n">gap_df</span><span class="p">[</span><span class="s2">&quot;gap_end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gap_ends</span>
            <span class="n">gap_df</span><span class="p">[</span><span class="s2">&quot;gap_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gap_df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">intvl</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">row</span><span class="o">.</span><span class="n">gap_start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">row</span><span class="o">.</span><span class="n">gap_end</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="n">gap_df</span></div>

<div class="viewcode-block" id="TimeSeries.copy"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of this series.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A copy of this time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># the xarray will be copied in the TimeSeries constructor.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.get_index_at_point"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.get_index_at_point">[docs]</a>    <span class="k">def</span> <span class="nf">get_index_at_point</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">after</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a point along the time axis index into an integer index ranging in (0, len(series)-1).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point</span>
<span class="sd">            This parameter supports 3 different data types: ``pd.Timestamp``, ``float`` and ``int``.</span>

<span class="sd">            ``pd.Timestamp`` work only on series that are indexed with a ``pd.DatetimeIndex``. In such cases, the</span>
<span class="sd">            returned point will be the index of this timestamp if it is present in the series time index.</span>
<span class="sd">            It it&#39;s not present in the time index, the index of the next timestamp is returned if `after=True`</span>
<span class="sd">            (if it exists in the series), otherwise the index of the previous timestamp is returned</span>
<span class="sd">            (if it exists in the series).</span>

<span class="sd">            In case of a ``float``, the parameter will be treated as the proportion of the time series</span>
<span class="sd">            that should lie before the point.</span>

<span class="sd">            If an ``int`` and series is datetime-indexed, the value of `point` is returned.</span>
<span class="sd">            If an ``int`` and series is integer-indexed, the index position of `point` in the RangeIndex is returned</span>
<span class="sd">            (accounting for steps).</span>
<span class="sd">        after</span>
<span class="sd">            If the provided pandas Timestamp is not in the time series index, whether to return the index of the</span>
<span class="sd">            next timestamp or the index of the previous one.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">point_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">point</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">,</span>
                <span class="s2">&quot;point (float) should be between 0.0 and 1.0.&quot;</span><span class="p">,</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">point_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">point</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_datetime_index</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">point_index</span> <span class="o">=</span> <span class="n">point</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">point_index_float</span> <span class="o">=</span> <span class="p">(</span><span class="n">point</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">())</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
                <span class="n">point_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">point_index_float</span><span class="p">)</span>
                <span class="n">raise_if</span><span class="p">(</span>
                    <span class="n">point_index</span> <span class="o">!=</span> <span class="n">point_index_float</span><span class="p">,</span>
                    <span class="s2">&quot;The provided point is not a valid index for this series.&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">point_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                <span class="sa">f</span><span class="s2">&quot;The index corresponding to the provided point (</span><span class="si">{</span><span class="n">point</span><span class="si">}</span><span class="s2">) should be a valid index in series&quot;</span><span class="p">,</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">,</span>
                <span class="s2">&quot;A Timestamp has been provided, but this series is not time-indexed.&quot;</span><span class="p">,</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_not_within</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">point_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">point_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_first_timestamp_after</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">after</span>
                    <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_last_timestamp_before</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;`point` needs to be either `float`, `int` or `pd.Timestamp`&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">point_index</span></div>

<div class="viewcode-block" id="TimeSeries.get_timestamp_at_point"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.get_timestamp_at_point">[docs]</a>    <span class="k">def</span> <span class="nf">get_timestamp_at_point</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a point into a pandas.Timestamp (if Datetime-indexed) or into an integer (if Int64-indexed).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point</span>
<span class="sd">            This parameter supports 3 different data types: `float`, `int` and `pandas.Timestamp`.</span>
<span class="sd">            In case of a `float`, the parameter will be treated as the proportion of the time series</span>
<span class="sd">            that should lie before the point.</span>
<span class="sd">            In case of `int`, the parameter will be treated as an integer index to the time index of</span>
<span class="sd">            `series`. Will raise a ValueError if not a valid index in `series`.</span>
<span class="sd">            In case of a `pandas.Timestamp`, point will be returned as is provided that the timestamp</span>
<span class="sd">            is present in the series time index, otherwise will raise a ValueError.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index_at_point</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_split_at</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">split_point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">after</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s2">&quot;TimeSeries&quot;</span><span class="p">,</span> <span class="s2">&quot;TimeSeries&quot;</span><span class="p">]:</span>
        <span class="c1"># Get index with not after in order to avoid moving twice if split_point is not in self</span>
        <span class="n">point_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index_at_point</span><span class="p">(</span><span class="n">split_point</span><span class="p">,</span> <span class="ow">not</span> <span class="n">after</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="p">[:</span> <span class="n">point_index</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">after</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)],</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">point_index</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">after</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span> <span class="p">:],</span>
        <span class="p">)</span>

<div class="viewcode-block" id="TimeSeries.split_after"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.split_after">[docs]</a>    <span class="k">def</span> <span class="nf">split_after</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">split_point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s2">&quot;TimeSeries&quot;</span><span class="p">,</span> <span class="s2">&quot;TimeSeries&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits the series in two, after a provided `split_point`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        split_point</span>
<span class="sd">            A timestamp, float or integer. If float, represents the proportion of the series to include in the</span>
<span class="sd">            first TimeSeries (must be between 0.0 and 1.0). If integer, represents the index position after</span>
<span class="sd">            which the split is performed. A pd.Timestamp can be provided for TimeSeries that are indexed by a</span>
<span class="sd">            pd.DatetimeIndex. In such cases, the timestamp will be contained in the first TimeSeries, but not</span>
<span class="sd">            in the second one. The timestamp itself does not have to appear in the original TimeSeries index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[TimeSeries, TimeSeries]</span>
<span class="sd">            A tuple of two time series. The first time series contains the first samples up to the `split_point`,</span>
<span class="sd">            and the second contains the remaining ones.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_at</span><span class="p">(</span><span class="n">split_point</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.split_before"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.split_before">[docs]</a>    <span class="k">def</span> <span class="nf">split_before</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">split_point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s2">&quot;TimeSeries&quot;</span><span class="p">,</span> <span class="s2">&quot;TimeSeries&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits the series in two, before a provided `split_point`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        split_point</span>
<span class="sd">            A timestamp, float or integer. If float, represents the proportion of the series to include in the</span>
<span class="sd">            first TimeSeries (must be between 0.0 and 1.0). If integer, represents the index position before</span>
<span class="sd">            which the split is performed. A pd.Timestamp can be provided for TimeSeries that are indexed by a</span>
<span class="sd">            pd.DatetimeIndex. In such cases, the timestamp will be contained in the second TimeSeries, but not</span>
<span class="sd">            in the first one. The timestamp itself does not have to appear in the original TimeSeries index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[TimeSeries, TimeSeries]</span>
<span class="sd">            A tuple of two time series. The first time series contains the first samples up to the `split_point`,</span>
<span class="sd">            and the second contains the remaining ones.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_at</span><span class="p">(</span><span class="n">split_point</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.drop_after"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.drop_after">[docs]</a>    <span class="k">def</span> <span class="nf">drop_after</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split_point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drops everything after the provided time `split_point`, included.</span>
<span class="sd">        The timestamp may not be in the series. If it is, the timestamp will be dropped.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        split_point</span>
<span class="sd">            The timestamp that indicates cut-off time.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries, after `ts`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index_at_point</span><span class="p">(</span><span class="n">split_point</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span></div>

<div class="viewcode-block" id="TimeSeries.drop_before"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.drop_before">[docs]</a>    <span class="k">def</span> <span class="nf">drop_before</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split_point</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drops everything before the provided time `split_point`, included.</span>
<span class="sd">        The timestamp may not be in the series. If it is, the timestamp will be dropped.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        split_point</span>
<span class="sd">            The timestamp that indicates cut-off time.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries, after `ts`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_index_at_point</span><span class="p">(</span><span class="n">split_point</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span></div>

<div class="viewcode-block" id="TimeSeries.slice"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.slice">[docs]</a>    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">start_ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">end_ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new TimeSeries, starting later than `start_ts` and ending before `end_ts`.</span>
<span class="sd">        For series having DatetimeIndex, this is inclusive on both ends. For series having a RangeIndex,</span>
<span class="sd">        `end_ts` is exclusive.</span>

<span class="sd">        `start_ts` and `end_ts` don&#39;t have to be in the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_ts</span>
<span class="sd">            The timestamp that indicates the left cut-off.</span>
<span class="sd">        end_ts</span>
<span class="sd">            The timestamp that indicates the right cut-off.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new series, with indices greater or equal than `start_ts` and smaller or equal than `end_ts`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">start_ts</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">end_ts</span><span class="p">),</span>
            <span class="s2">&quot;The two timestamps provided to slice() have to be of the same type.&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_ts</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">,</span>
                <span class="s2">&quot;Timestamps have been provided to slice(), but the series is &quot;</span>
                <span class="s2">&quot;indexed using an integer-based RangeIndex.&quot;</span><span class="p">,</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">start_ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span> <span class="ow">and</span> <span class="n">end_ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span>
                    <span class="n">start_ts</span><span class="p">:</span><span class="n">end_ts</span>
                <span class="p">]</span>  <span class="c1"># we assume this is faster than the filtering below</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span>
                    <span class="p">(</span><span class="n">start_ts</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span> <span class="o">&lt;=</span> <span class="n">end_ts</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_if</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">,</span>
                <span class="s2">&quot;start and end times have been provided as integers to slice(), but &quot;</span>
                <span class="s2">&quot;the series is indexed with a DatetimeIndex.&quot;</span><span class="p">,</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># get closest timestamps if either start or end are not in the index</span>
            <span class="n">effective_start_ts</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">start_ts</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">start_ts</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span>
                <span class="k">else</span> <span class="n">start_ts</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">effective_start_ts</span> <span class="o">&lt;</span> <span class="n">start_ts</span><span class="p">:</span>
                <span class="c1"># if the requested start_ts is smaller than the start argument,</span>
                <span class="c1"># we have to increase it to be consistent with the docstring</span>
                <span class="n">effective_start_ts</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>

            <span class="n">effective_end_ts</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">end_ts</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">end_ts</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span>
                <span class="k">else</span> <span class="n">end_ts</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">end_ts</span> <span class="o">&gt;=</span> <span class="n">effective_end_ts</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">:</span>
                <span class="c1"># if the requested end_ts is further off from the end of the time series,</span>
                <span class="c1"># we have to increase effectiv_end_ts to make the last timestamp inclusive.</span>
                <span class="n">effective_end_ts</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span><span class="n">effective_start_ts</span><span class="p">,</span> <span class="n">effective_end_ts</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.slice_n_points_after"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.slice_n_points_after">[docs]</a>    <span class="k">def</span> <span class="nf">slice_n_points_after</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new TimeSeries, starting a `start_ts` (inclusive) and having at most `n` points.</span>

<span class="sd">        The provided timestamps will be included in the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_ts</span>
<span class="sd">            The timestamp or index that indicates the splitting time.</span>
<span class="sd">        n</span>
<span class="sd">            The maximal length of the new TimeSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries, with length at most `n`, starting at `start_ts`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;n should be a positive integer.&quot;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_not_within</span><span class="p">(</span><span class="n">start_ts</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_ts</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start_ts</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">start_ts</span> <span class="o">+</span> <span class="n">n</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_ts</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="c1"># get first timestamp greater or equal to start_ts</span>
            <span class="n">tss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_first_timestamp_after</span><span class="p">(</span><span class="n">start_ts</span><span class="p">)</span>
            <span class="n">point_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index_at_point</span><span class="p">(</span><span class="n">tss</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">point_index</span> <span class="p">:</span> <span class="n">point_index</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;start_ts must be an int or a pandas Timestamp.&quot;</span><span class="p">),</span> <span class="n">logger</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.slice_n_points_before"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.slice_n_points_before">[docs]</a>    <span class="k">def</span> <span class="nf">slice_n_points_before</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end_ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new TimeSeries, ending at `end_ts` (inclusive) and having at most `n` points.</span>

<span class="sd">        The provided timestamps will be included in the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        end_ts</span>
<span class="sd">            The timestamp or index that indicates the splitting time.</span>
<span class="sd">        n</span>
<span class="sd">            The maximal length of the new TimeSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries, with length at most `n`, ending at `start_ts`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">raise_if_not</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;n should be a positive integer.&quot;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_not_within</span><span class="p">(</span><span class="n">end_ts</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end_ts</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">end_ts</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">end_ts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end_ts</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="c1"># get last timestamp smaller or equal to start_ts</span>
            <span class="n">tss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_last_timestamp_before</span><span class="p">(</span><span class="n">end_ts</span><span class="p">)</span>
            <span class="n">point_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index_at_point</span><span class="p">(</span><span class="n">tss</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">point_index</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="n">point_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;start_ts must be an int or a pandas Timestamp.&quot;</span><span class="p">),</span> <span class="n">logger</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.slice_intersect"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.slice_intersect">[docs]</a>    <span class="k">def</span> <span class="nf">slice_intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;TimeSeries&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a ``TimeSeries`` slice of this series, where the time index has been intersected with the one</span>
<span class="sd">        of the `other` series.</span>

<span class="sd">        This method is in general *not* symmetric.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            the other time series</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            a new series, containing the values of this series, over the time-span common to both time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">time_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">time_index</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.strip"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.strip">[docs]</a>    <span class="k">def</span> <span class="nf">strip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">how</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a ``TimeSeries`` slice of this deterministic time series, where NaN-containing entries at the beginning</span>
<span class="sd">        and the end of the series are removed. No entries after (and including) the first non-NaN entry and</span>
<span class="sd">        before (and including) the last non-NaN entry are removed.</span>

<span class="sd">        This method is only applicable to deterministic series (i.e., having 1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        how</span>
<span class="sd">            Define if the entries containing `NaN` in all the components (&#39;all&#39;) or in any of the components (&#39;any&#39;)</span>
<span class="sd">            should be stripped. Default: &#39;all&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            a new series based on the original where NaN-containing entries at start and end have been removed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_if</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_probabilistic</span><span class="p">,</span>
            <span class="s2">&quot;`strip` cannot be applied to stochastic TimeSeries&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">first_finite_row</span><span class="p">,</span> <span class="n">last_finite_row</span> <span class="o">=</span> <span class="n">_finite_rows_boundaries</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">from_times_and_values</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">[</span><span class="n">first_finite_row</span> <span class="p">:</span> <span class="n">last_finite_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="n">first_finite_row</span> <span class="p">:</span> <span class="n">last_finite_row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.longest_contiguous_slice"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.longest_contiguous_slice">[docs]</a>    <span class="k">def</span> <span class="nf">longest_contiguous_slice</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">max_gap_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the largest TimeSeries slice of this deterministic series that contains no gaps</span>
<span class="sd">        (contiguous all-NaN values) larger than `max_gap_size`.</span>

<span class="sd">        This method is only applicable to deterministic series (i.e., having 1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_gap_size</span>
<span class="sd">            Indicate the maximum gap size that the TimeSerie can contain</span>
<span class="sd">        mode</span>
<span class="sd">            Only relevant for multivariate time series. The mode defines how gaps are defined. Set to</span>
<span class="sd">            &#39;any&#39; if a NaN value in any columns should be considered as as gaps. &#39;all&#39; will only</span>
<span class="sd">            consider periods where all columns&#39; values are NaN. Defaults to &#39;all&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            a new series constituting the largest slice of the original with no or bounded gaps</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.gaps : return the gaps in the TimeSeries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">))</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">stripped_series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">gaps</span> <span class="o">=</span> <span class="n">stripped_series</span><span class="o">.</span><span class="n">gaps</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="n">relevant_gaps</span> <span class="o">=</span> <span class="n">gaps</span><span class="p">[</span><span class="n">gaps</span><span class="p">[</span><span class="s2">&quot;gap_size&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_gap_size</span><span class="p">]</span>

        <span class="n">curr_slice_start</span> <span class="o">=</span> <span class="n">stripped_series</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span>
        <span class="n">max_size</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">max_slice_start</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">max_slice_end</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">relevant_gaps</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="c1"># evaluate size of the current slice. the slice ends one time step before row[&#39;gap_start&#39;]</span>
            <span class="n">curr_slice_end</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;gap_start&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">curr_slice_end</span> <span class="o">-</span> <span class="n">curr_slice_start</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">max_size</span><span class="p">:</span>
                <span class="n">max_size</span> <span class="o">=</span> <span class="n">size</span>
                <span class="n">max_slice_start</span> <span class="o">=</span> <span class="n">curr_slice_start</span>
                <span class="n">max_slice_end</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;gap_start&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>
            <span class="n">curr_slice_start</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;gap_end&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>

        <span class="k">if</span> <span class="n">stripped_series</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span> <span class="o">-</span> <span class="n">curr_slice_start</span> <span class="o">&gt;</span> <span class="n">max_size</span><span class="p">:</span>
            <span class="n">max_slice_start</span> <span class="o">=</span> <span class="n">curr_slice_start</span>
            <span class="n">max_slice_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">stripped_series</span><span class="p">[</span><span class="n">max_slice_start</span><span class="p">:</span><span class="n">max_slice_end</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.rescale_with_value"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.rescale_with_value">[docs]</a>    <span class="k">def</span> <span class="nf">rescale_with_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_at_first_step</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new ``TimeSeries``, which is a multiple of this series such that</span>
<span class="sd">        the first value is `value_at_first_step`.</span>
<span class="sd">        (Note: numerical errors can appear with `value_at_first_step &gt; 1e+24`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value_at_first_step</span>
<span class="sd">            The new value for the first entry of the TimeSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries, where the first value is `value_at_first_step` and other values</span>
<span class="sd">            have been scaled accordingly.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;Cannot rescale with first value 0.&quot;</span><span class="p">,</span> <span class="n">logger</span>
        <span class="p">)</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">value_at_first_step</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">coef</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">))</span>  <span class="c1"># TODO: test</span>
        <span class="n">new_series</span> <span class="o">=</span> <span class="n">coef</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_series</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.shift"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.shift">[docs]</a>    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shifts the time axis of this TimeSeries by `n` time steps.</span>

<span class="sd">        If :math:`n &gt; 0`, shifts in the future. If :math:`n &lt; 0`, shifts in the past.</span>

<span class="sd">        For example, with :math:`n=2` and `freq=&#39;M&#39;`, March 2013 becomes May 2013.</span>
<span class="sd">        With :math:`n=-2`, March 2013 becomes Jan 2013.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n</span>
<span class="sd">            The number of time steps (in self.freq unit) to shift by. Can be negative.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries, with a shifted index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;TimeSeries.shift(): converting n to int from </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
        <span class="k">except</span> <span class="n">pd</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">OutOfBoundsDatetime</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">OverflowError</span><span class="p">(</span>
                    <span class="s2">&quot;the add operation between </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2"> will &quot;</span>
                    <span class="s2">&quot;overflow&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_range_index</span><span class="p">:</span>
            <span class="n">new_time_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_time_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">ts</span><span class="p">:</span> <span class="n">ts</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_time_index</span><span class="o">.</span><span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_time_index</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span>
        <span class="n">new_xa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">new_time_index</span><span class="p">})</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.diff"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.diff">[docs]</a>    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">periods</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">dropna</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a differenced time series. This is often used to make a time series stationary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n</span>
<span class="sd">            Optionally, a positive integer indicating the number of differencing steps (default = 1).</span>
<span class="sd">            For instance, n=2 computes the second order differences.</span>
<span class="sd">        periods</span>
<span class="sd">            Optionally, periods to shift for calculating difference. For instance, periods=12 computes the</span>
<span class="sd">            difference between values at time `t` and times `t-12`.</span>
<span class="sd">        dropna</span>
<span class="sd">            Whether to drop the missing values after each differencing steps. If set to False, the corresponding</span>
<span class="sd">            first `periods` time steps will be filled with NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries, with the differenced values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;n&#39; must be a positive integer &gt;= 1.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">periods</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;periods&#39; must be an integer &gt;= 1.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_compute_diff</span><span class="p">(</span><span class="n">xa</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="c1"># xarray doesn&#39;t support Pandas &quot;period&quot; so compute diff() ourselves</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dropna</span><span class="p">:</span>
                <span class="c1"># In this case the new DataArray will have the same size and filled with NaNs</span>
                <span class="n">new_xa_</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new_xa_</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="n">periods</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">new_xa_</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">periods</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">xa</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">periods</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">xa</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="o">-</span><span class="n">periods</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># In this case the new DataArray will be shorter</span>
                <span class="n">new_xa_</span> <span class="o">=</span> <span class="n">xa</span><span class="p">[</span><span class="n">periods</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new_xa_</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">periods</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">xa</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="o">-</span><span class="n">periods</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">return</span> <span class="n">new_xa_</span>

        <span class="n">new_xa</span> <span class="o">=</span> <span class="n">_compute_diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">new_xa</span> <span class="o">=</span> <span class="n">_compute_diff</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.cumsum"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.cumsum">[docs]</a>    <span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cumulative sum of the time series along the time axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries, with the cumulatively summed values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span></div>

<div class="viewcode-block" id="TimeSeries.has_same_time_as"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.has_same_time_as">[docs]</a>    <span class="k">def</span> <span class="nf">has_same_time_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;TimeSeries&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether this series has the same time index as `other`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            the other series</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if both TimeSeries have the same index, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">time_index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></div>

<div class="viewcode-block" id="TimeSeries.append"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;TimeSeries&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends another series to this series along the time axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            A second TimeSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries, obtained by appending the second TimeSeries to the first.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.concatenate : concatenate another series along a given axis.</span>
<span class="sd">        TimeSeries.prepend : prepend (i.e. add to the beginning) another series along the time axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">has_datetime_index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_datetime_index</span><span class="p">,</span>
            <span class="s2">&quot;Both series must have the same type of time index (either DatetimeIndex or RangeIndex).&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">freq</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
            <span class="s2">&quot;Appended TimeSeries must have the same frequency as the current one&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">n_components</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span>
            <span class="s2">&quot;Both series must have the same number of components.&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">n_samples</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">,</span>
            <span class="s2">&quot;Both series must have the same number of components.&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="n">other</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
                <span class="s2">&quot;Appended TimeSeries must start one time step after current one.&quot;</span><span class="p">,</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">other_xa</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">data_array</span><span class="p">()</span>

        <span class="n">new_xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other_xa</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">time_index</span><span class="p">),</span>
                <span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">from_xarray</span><span class="p">(</span>
            <span class="n">new_xa</span><span class="p">,</span> <span class="n">fill_missing_dates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq_str</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.append_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.append_values">[docs]</a>    <span class="k">def</span> <span class="nf">append_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends new values to current TimeSeries, extending its time index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values</span>
<span class="sd">            An array with the values to append.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries with the new values appended</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span>
                <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span>
                <span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">,</span>
                <span class="n">stop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">,</span>
                <span class="n">step</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">from_times_and_values</span><span class="p">(</span>
                <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
                <span class="n">times</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span>
                <span class="n">fill_missing_dates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">static_covariates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.prepend"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.prepend">[docs]</a>    <span class="k">def</span> <span class="nf">prepend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;TimeSeries&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepends (i.e. adds to the beginning) another series to this series along the time axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            A second TimeSeries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries, obtained by appending the second TimeSeries to the first.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Timeseries.append : append (i.e. add to the end) another series along the time axis.</span>
<span class="sd">        TimeSeries.concatenate : concatenate another series along a given axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">),</span>
            <span class="sa">f</span><span class="s2">&quot;`other` to prepend must be a </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> object.&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.prepend_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.prepend_values">[docs]</a>    <span class="k">def</span> <span class="nf">prepend_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepends (i.e. adds to the beginning) new values to current TimeSeries, extending its time index into the past.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values</span>
<span class="sd">            An array with the values to prepend to the start.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries with the new values prepended.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="p">],</span>
                <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">(),</span>
                <span class="n">step</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepend</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">from_times_and_values</span><span class="p">(</span>
                <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
                <span class="n">times</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span>
                <span class="n">fill_missing_dates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">static_covariates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.with_values"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.with_values">[docs]</a>    <span class="k">def</span> <span class="nf">with_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new ``TimeSeries`` similar to this one but with new specified values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values</span>
<span class="sd">            A Numpy array with new values. It must have the dimensions for time</span>
<span class="sd">            and componentns, but may contain a different number of samples.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries with the new values and same index, static covariates and hierarchy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span>
            <span class="s2">&quot;The new values must have the same shape (time, components) as the present series. &quot;</span>
            <span class="s2">&quot;Received: </span><span class="si">{}</span><span class="s2">, expected: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="p">),</span>
        <span class="p">)</span>

        <span class="n">new_xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">values</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.with_static_covariates"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.with_static_covariates">[docs]</a>    <span class="k">def</span> <span class="nf">with_static_covariates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a new TimeSeries object with added static covariates.</span>

<span class="sd">        Static covariates contain data attached to the time series, but which are not varying with time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        covariates</span>
<span class="sd">            Optionally, a set of static covariates to be added to the TimeSeries. Either a pandas Series, a pandas</span>
<span class="sd">            DataFrame, or `None`. If `None`, will set the static covariates to `None`. If a Series, the index</span>
<span class="sd">            represents the static variables. The covariates are then globally &#39;applied&#39; to all components of the</span>
<span class="sd">            TimeSeries. If a DataFrame, the columns represent the static variables and the rows represent the</span>
<span class="sd">            components of the uni/multivariate TimeSeries. If a single-row DataFrame, the covariates are globally</span>
<span class="sd">            &#39;applied&#39; to all components of the TimeSeries. If a multi-row DataFrame, the number of rows must match the</span>
<span class="sd">            number of components of the TimeSeries. This adds component-specific static covariates.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If there are a large number of static covariates variables (i.e., the static covariates have a very large</span>
<span class="sd">        dimension), there might be a noticeable performance penalty for creating ``TimeSeries`` objects, unless</span>
<span class="sd">        the covariates already have the same ``dtype`` as the series data.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; from darts.utils.timeseries_generation import linear_timeseries</span>
<span class="sd">        &gt;&gt;&gt; # add global static covariates</span>
<span class="sd">        &gt;&gt;&gt; static_covs = pd.Series([0., 1.], index=[&quot;static_cov_1&quot;, &quot;static_cov_2&quot;])</span>
<span class="sd">        &gt;&gt;&gt; series = linear_timeseries(length=3)</span>
<span class="sd">        &gt;&gt;&gt; series_new1 = series.with_static_covariates(static_covs)</span>
<span class="sd">        &gt;&gt;&gt; series_new1.static_covariates</span>
<span class="sd">                           static_cov_1  static_cov_2</span>
<span class="sd">        component</span>
<span class="sd">        linear              0.0           1.0</span>

<span class="sd">        &gt;&gt;&gt; # add component specific static covariates</span>
<span class="sd">        &gt;&gt;&gt; static_covs_multi = pd.DataFrame([[0., 1.], [2., 3.]], columns=[&quot;static_cov_1&quot;, &quot;static_cov_2&quot;])</span>
<span class="sd">        &gt;&gt;&gt; series_multi = series.stack(series)</span>
<span class="sd">        &gt;&gt;&gt; series_new2 = series_multi.with_static_covariates(static_covs_multi)</span>
<span class="sd">        &gt;&gt;&gt; series_new2.static_covariates</span>
<span class="sd">                           static_cov_1  static_cov_2</span>
<span class="sd">        component</span>
<span class="sd">        linear              0.0           1.0</span>
<span class="sd">        linear_1            2.0           3.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
                <span class="n">coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span>
                <span class="n">attrs</span><span class="o">=</span><span class="p">{</span>
                    <span class="n">STATIC_COV_TAG</span><span class="p">:</span> <span class="n">covariates</span><span class="p">,</span>
                    <span class="n">HIERARCHY_TAG</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.with_hierarchy"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.with_hierarchy">[docs]</a>    <span class="k">def</span> <span class="nf">with_hierarchy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hierarchy</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a hierarchy to the TimeSeries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hierarchy</span>
<span class="sd">            A dictionary mapping components to a list of their parent(s) in the hierarchy.</span>
<span class="sd">            Single parents may be specified as string or list containing one string.</span>
<span class="sd">            For example, assume the series contains the components</span>
<span class="sd">            ``[&quot;total&quot;, &quot;a&quot;, &quot;b&quot;, &quot;x&quot;, &quot;y&quot;, &quot;ax&quot;, &quot;ay&quot;, &quot;bx&quot;, &quot;by&quot;]``,</span>
<span class="sd">            the following dictionary would encode the groupings shown on</span>
<span class="sd">            `this figure &lt;https://otexts.com/fpp3/hts.html#fig:GroupTree&gt;`_:</span>

<span class="sd">            .. highlight:: python</span>
<span class="sd">            .. code-block:: python</span>

<span class="sd">                hierarchy = {&#39;ax&#39;: [&#39;a&#39;, &#39;x&#39;],</span>
<span class="sd">                             &#39;ay&#39;: [&#39;a&#39;, &#39;y&#39;],</span>
<span class="sd">                             &#39;bx&#39;: [&#39;b&#39;, &#39;x&#39;],</span>
<span class="sd">                             &#39;by&#39;: [&#39;b&#39;, &#39;y&#39;],</span>
<span class="sd">                             &#39;a&#39;: [&#39;total&#39;],</span>
<span class="sd">                             &#39;b&#39;: [&#39;total&#39;],</span>
<span class="sd">                             &#39;x&#39;: &#39;total&#39;,  # or use a single string</span>
<span class="sd">                             &#39;y&#39;: &#39;total&#39;}</span>
<span class="sd">            ..</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
                <span class="n">coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span>
                <span class="n">attrs</span><span class="o">=</span><span class="p">{</span>
                    <span class="n">STATIC_COV_TAG</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span>
                    <span class="n">HIERARCHY_TAG</span><span class="p">:</span> <span class="n">hierarchy</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.stack"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.stack">[docs]</a>    <span class="k">def</span> <span class="nf">stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;TimeSeries&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;TimeSeries&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stacks another univariate or multivariate TimeSeries with the same time index on top of</span>
<span class="sd">        the current one (along the component axis).</span>

<span class="sd">        Return a new TimeSeries that includes all the components of `self` and of `other`.</span>

<span class="sd">        The resulting TimeSeries will have the same name for its time dimension as this TimeSeries, and the</span>
<span class="sd">        same number of samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            A TimeSeries instance with the same index and the same number of samples as the current one.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new multivariate TimeSeries instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.drop_columns"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.drop_columns">[docs]</a>    <span class="k">def</span> <span class="nf">drop_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new ``TimeSeries`` instance with dropped columns/components.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------</span>
<span class="sd">        col_names</span>
<span class="sd">            String or list of strings corresponding to the columns to be dropped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries instance with specified columns dropped.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">col_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_names</span><span class="p">]</span>

        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="nb">all</span><span class="p">([(</span><span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_list</span><span class="p">())</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">col_names</span><span class="p">]),</span>
            <span class="s2">&quot;Some column names in col_names don&#39;t exist in the time series.&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">new_xa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">drop_sel</span><span class="p">({</span><span class="s2">&quot;component&quot;</span><span class="p">:</span> <span class="n">col_names</span><span class="p">})</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.univariate_component"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.univariate_component">[docs]</a>    <span class="k">def</span> <span class="nf">univariate_component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve one of the components of the series</span>
<span class="sd">        and return it as new univariate ``TimeSeries`` instance.</span>

<span class="sd">        This drops the hierarchy (if any), and retains only the relevant static</span>
<span class="sd">        covariates column.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index</span>
<span class="sd">            An zero-indexed integer indicating which component to retrieve. If components have names,</span>
<span class="sd">            this can be a string with the component&#39;s name.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new univariate TimeSeries instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span></div>

<div class="viewcode-block" id="TimeSeries.add_datetime_attribute"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.add_datetime_attribute">[docs]</a>    <span class="k">def</span> <span class="nf">add_datetime_attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">,</span>
        <span class="n">one_hot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cyclic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">tz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;TimeSeries&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a new series with one (or more) additional component(s) that contain an attribute</span>
<span class="sd">        of the time index of the series.</span>

<span class="sd">        The additional components are specified with `attribute`, such as &#39;weekday&#39;, &#39;day&#39; or &#39;month&#39;.</span>

<span class="sd">        This works only for deterministic time series (i.e., made of 1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attribute</span>
<span class="sd">            A pd.DatatimeIndex attribute which will serve as the basis of the new column(s).</span>
<span class="sd">        one_hot</span>
<span class="sd">            Boolean value indicating whether to add the specified attribute as a one hot encoding</span>
<span class="sd">            (results in more columns).</span>
<span class="sd">        cyclic</span>
<span class="sd">            Boolean value indicating whether to add the specified attribute as a cyclic encoding.</span>
<span class="sd">            Alternative to one_hot encoding, enable only one of the two.</span>
<span class="sd">            (adds 2 columns, corresponding to sin and cos transformation).</span>
<span class="sd">        tz</span>
<span class="sd">            Optionally, a time zone to convert the time index to before computing the attributes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            New TimeSeries instance enhanced by `attribute`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">timeseries_generation</span> <span class="k">as</span> <span class="n">tg</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="n">tg</span><span class="o">.</span><span class="n">datetime_attribute_timeseries</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">,</span>
                <span class="n">attribute</span><span class="o">=</span><span class="n">attribute</span><span class="p">,</span>
                <span class="n">one_hot</span><span class="o">=</span><span class="n">one_hot</span><span class="p">,</span>
                <span class="n">cyclic</span><span class="o">=</span><span class="n">cyclic</span><span class="p">,</span>
                <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.add_holidays"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.add_holidays">[docs]</a>    <span class="k">def</span> <span class="nf">add_holidays</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">country_code</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">prov</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">state</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;TimeSeries&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a binary univariate component to the current series that equals 1 at every index that</span>
<span class="sd">        corresponds to selected country&#39;s holiday, and 0 otherwise.</span>

<span class="sd">        The frequency of the TimeSeries is daily.</span>

<span class="sd">        Available countries can be found `here &lt;https://github.com/dr-prodigy/python-holidays#available-countries&gt;`_.</span>

<span class="sd">        This works only for deterministic time series (i.e., made of 1 sample).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        country_code</span>
<span class="sd">            The country ISO code</span>
<span class="sd">        prov</span>
<span class="sd">            The province</span>
<span class="sd">        state</span>
<span class="sd">            The state</span>
<span class="sd">        tz</span>
<span class="sd">            Optionally, a time zone to convert the time index to before computing the attributes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries instance, enhanced with binary holiday component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_deterministic</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">timeseries_generation</span> <span class="k">as</span> <span class="n">tg</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="n">tg</span><span class="o">.</span><span class="n">holidays_timeseries</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">,</span>
                <span class="n">country_code</span><span class="o">=</span><span class="n">country_code</span><span class="p">,</span>
                <span class="n">prov</span><span class="o">=</span><span class="n">prov</span><span class="p">,</span>
                <span class="n">state</span><span class="o">=</span><span class="n">state</span><span class="p">,</span>
                <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.resample"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.resample">[docs]</a>    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a reindexed ``TimeSeries`` with a given frequency.</span>
<span class="sd">        Provided method is used to fill holes in reindexed TimeSeries, by default &#39;pad&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq</span>
<span class="sd">            The new time difference between two adjacent entries in the returned TimeSeries.</span>
<span class="sd">            A DateOffset alias is expected.</span>
<span class="sd">        method:</span>
<span class="sd">            Method to fill holes in reindexed TimeSeries (note this does not fill NaNs that already were present):</span>

<span class="sd">            &#39;pad&#39;: propagate last valid observation forward to next valid</span>

<span class="sd">            &#39;backfill&#39;: use NEXT valid observation to fill.</span>
<span class="sd">        kwargs</span>
<span class="sd">            some keyword arguments for the `xarray.resample` method, notably `offset` or `base` to indicate where</span>
<span class="sd">            to start the resampling and avoid nan at the first value of the resampled TimeSeries</span>
<span class="sd">            For more informations, see the `xarray resample() documentation</span>
<span class="sd">            &lt;https://docs.xarray.dev/en/stable/generated/xarray.DataArray.resample.html&gt;`_.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; times = pd.date_range(start=pd.Timestamp(&quot;20200101233000&quot;), periods=6, freq=&quot;15T&quot;)</span>
<span class="sd">        &gt;&gt;&gt; pd_series = pd.Series(range(6), index=times)</span>
<span class="sd">        &gt;&gt;&gt; ts = TimeSeries.from_series(pd_series)</span>
<span class="sd">        &gt;&gt;&gt; print(ts.time_index)</span>
<span class="sd">        DatetimeIndex([&#39;2020-01-01 23:30:00&#39;, &#39;2020-01-01 23:45:00&#39;,</span>
<span class="sd">                       &#39;2020-01-02 00:00:00&#39;, &#39;2020-01-02 00:15:00&#39;,</span>
<span class="sd">                       &#39;2020-01-02 00:30:00&#39;, &#39;2020-01-02 00:45:00&#39;],</span>
<span class="sd">                       dtype=&#39;datetime64[ns]&#39;, name=&#39;time&#39;, freq=&#39;15T&#39;)</span>
<span class="sd">        &gt;&gt;&gt; resampled_nokwargs_ts = ts.resample(freq=&quot;1h&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(resampled_nokwargs_ts.time_index)</span>
<span class="sd">        DatetimeIndex([&#39;2020-01-01 23:00:00&#39;, &#39;2020-01-02 00:00:00&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, name=&#39;time&#39;, freq=&#39;H&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(resampled_nokwargs_ts.values())</span>
<span class="sd">        [[nan]</span>
<span class="sd">        [ 2.]]</span>
<span class="sd">        &gt;&gt;&gt; resampled_ts = ts.resample(freq=&quot;1h&quot;, offset=pd.Timedelta(&quot;30T&quot;))</span>
<span class="sd">        &gt;&gt;&gt; print(resampled_ts.time_index)</span>
<span class="sd">        DatetimeIndex([&#39;2020-01-01 23:30:00&#39;, &#39;2020-01-02 00:30:00&#39;],</span>
<span class="sd">                      dtype=&#39;datetime64[ns]&#39;, name=&#39;time&#39;, freq=&#39;H&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(resampled_ts.values())</span>
<span class="sd">        [[0.]</span>
<span class="sd">        [4.]]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A reindexed TimeSeries with given frequency.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">resample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span>
            <span class="n">indexer</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="n">freq</span><span class="p">},</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># TODO: check</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;pad&quot;</span><span class="p">:</span>
            <span class="n">new_xa</span> <span class="o">=</span> <span class="n">resample</span><span class="o">.</span><span class="n">pad</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bfill&quot;</span><span class="p">:</span>
            <span class="n">new_xa</span> <span class="o">=</span> <span class="n">resample</span><span class="o">.</span><span class="n">backfill</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.is_within_range"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.is_within_range">[docs]</a>    <span class="k">def</span> <span class="nf">is_within_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether a given timestamp or integer is within the time interval of this time series.</span>
<span class="sd">        If a timestamp is provided, it does not need to be an element of the time index of the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ts</span>
<span class="sd">            The `pandas.Timestamp` (if indexed with DatetimeIndex) or integer (if indexed with RangeIndex) to check.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether `ts` is contained within the interval of this time series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeSeries.map"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.map">[docs]</a>    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">],</span>
            <span class="n">Callable</span><span class="p">[[</span><span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">],</span>
        <span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>  <span class="c1"># noqa: E501</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the function `fn` to the underlying NumPy array containing this series&#39; values.</span>

<span class="sd">        Return a new TimeSeries instance. If `fn` takes 1 argument it is simply applied on the backing array</span>
<span class="sd">        of shape (time, n_components, n_samples).</span>
<span class="sd">        If it takes 2 arguments, it is applied repeatedly on the (ts, value[ts]) tuples, where</span>
<span class="sd">        &quot;ts&quot; denotes a timestamp value, and &quot;value[ts]&quot; denote the array of values at this timestamp, of shape</span>
<span class="sd">        (n_components, n_samples).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fn</span>
<span class="sd">            Either a function which takes a NumPy array and returns a NumPy array of same shape;</span>
<span class="sd">            e.g., `lambda x: x ** 2`, `lambda x: x / x.shape[0]` or `np.log`.</span>
<span class="sd">            It can also be a function which takes a timestamp and array, and returns a new array of same shape;</span>
<span class="sd">            e.g., `lambda ts, x: x / ts.days_in_month`.</span>
<span class="sd">            The type of `ts` is either `pd.Timestamp` (if the series is indexed with a DatetimeIndex),</span>
<span class="sd">            or an integer otherwise (if the series is indexed with an RangeIndex).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;fn should be callable&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ufunc</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fn</span><span class="o">.</span><span class="n">nin</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">fn</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">num_args</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">fn</span><span class="o">.</span><span class="n">nin</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">fn</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">num_args</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;fn must have either one or two arguments and return a single value&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">num_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;inspect.signature(fn) failed. Try wrapping fn in a lambda, e.g. lambda x: fn(x)&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">new_xa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">num_args</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># apply fn on values directly</span>
            <span class="n">new_xa</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">num_args</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># map function uses timestamp f(timestamp, x)</span>
            <span class="c1"># go over shortest amount of iterations, either over time steps or components and samples</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_timesteps</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">:</span>
                <span class="n">new_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
                            <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_timesteps</span><span class="p">)</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span><span class="p">)</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">)</span>
                    <span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">new_xa</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">new_vals</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fn must have either one or two arguments&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.window_transform"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.window_transform">[docs]</a>    <span class="k">def</span> <span class="nf">window_transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">transforms</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Dict</span><span class="p">]],</span>
        <span class="n">treat_na</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">forecasting_safe</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">keep_non_transformed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">include_current</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;TimeSeries&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a moving/rolling, expanding or exponentially weighted window transformation over this ``TimeSeries``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        transforms</span>
<span class="sd">            A dictionary or a list of dictionaries.</span>
<span class="sd">            Each dictionary specifies a different window transform.</span>

<span class="sd">            The dictionaries can contain the following keys:</span>

<span class="sd">            :``&quot;function&quot;``: Mandatory. The name of one of the pandas builtin transformation functions,</span>
<span class="sd">                            or a callable function that can be applied to the input series.</span>
<span class="sd">                            Pandas&#39; functions can be found in the</span>
<span class="sd">                            `documentation &lt;https://pandas.pydata.org/docs/reference/window.html&gt;`_.</span>

<span class="sd">            :``&quot;mode&quot;``: Optional. The name of the pandas windowing mode on which the ``&quot;function&quot;`` is going to be</span>
<span class="sd">                        applied. The options are &quot;rolling&quot;, &quot;expanding&quot; and &quot;ewm&quot;.</span>
<span class="sd">                        If not provided, Darts defaults to &quot;expanding&quot;.</span>
<span class="sd">                        User defined functions can use either &quot;rolling&quot; or &quot;expanding&quot; modes.</span>
<span class="sd">                        More information on pandas windowing operations can be found in the `documentation</span>
<span class="sd">                        &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/window.html&gt;`_.</span>

<span class="sd">            :``&quot;components&quot;``: Optional. A string or list of strings specifying the TimeSeries components on which the</span>
<span class="sd">                               transformation should be applied. If not specified, the transformation will be</span>
<span class="sd">                               applied on all components.</span>

<span class="sd">            :``&quot;function_name&quot;``: Optional. A string specifying the function name referenced as part of</span>
<span class="sd">                                  the transformation output name. For example, given a user-provided function</span>
<span class="sd">                                  transformation on rolling window size of 5 on the component &quot;comp&quot;, the</span>
<span class="sd">                                  default transformation output name is &quot;rolling_udf_5_comp&quot; whereby &quot;udf&quot;</span>
<span class="sd">                                  refers to &quot;user defined function&quot;. If specified, the ``&quot;function_name&quot;`` will</span>
<span class="sd">                                  replace the default name &quot;udf&quot;. Similarly, the ``&quot;function_name&quot;`` will replace</span>
<span class="sd">                                  the name of the pandas builtin transformation function name in the output name.</span>

<span class="sd">            All other dictionary items provided will be treated as keyword arguments for the windowing mode</span>
<span class="sd">            (i.e., ``rolling/ewm/expanding``) or for the specific function</span>
<span class="sd">            in that mode (i.e., ``pandas.DataFrame.rolling.mean/std/max/min...`` or</span>
<span class="sd">            ``pandas.DataFrame.ewm.mean/std/sum``).</span>
<span class="sd">            This allows for more flexibility in configuring the transformation, by providing for</span>
<span class="sd">            example:</span>

<span class="sd">            * :``&quot;window&quot;``: Size of the moving window for the &quot;rolling&quot; mode.</span>
<span class="sd">                            If an integer, the fixed number of observations used for each window.</span>
<span class="sd">                            If an offset, the time period of each window with data type :class:`pandas.Timedelta`</span>
<span class="sd">                            representing a fixed duration.</span>
<span class="sd">            * :``&quot;min_periods&quot;``: The minimum number of observations in the window required to have a value (otherwise</span>
<span class="sd">                NaN). Darts reuses pandas defaults of 1 for &quot;rolling&quot; and &quot;expanding&quot; modes and of 0 for &quot;ewm&quot; mode.</span>
<span class="sd">            * :``&quot;win_type&quot;``: The type of weigthing to apply to the window elements.</span>
<span class="sd">                If provided, it should be one of `scipy.signal.windows</span>
<span class="sd">                &lt;https://docs.scipy.org/doc/scipy/reference/signal.windows.html#module-scipy.signal.windows&gt;`_.</span>
<span class="sd">            * :``&quot;center&quot;``: ``True``/``False`` to set the observation at the current timestep at the center of the</span>
<span class="sd">                window (when ``forecasting_safe`` is `True`, Darts enforces ``&quot;center&quot;`` to ``False``).</span>
<span class="sd">            * :``&quot;closed&quot;``: ``&quot;right&quot;``/``&quot;left&quot;``/``&quot;both&quot;``/``&quot;neither&quot;`` to specify whether the right,</span>
<span class="sd">                left or both ends of the window are included in the window, or neither of them.</span>
<span class="sd">                Darts defaults to pandas default of ``&quot;right&quot;``.</span>

<span class="sd">            More information on the available functions and their parameters can be found in the</span>
<span class="sd">            `Pandas documentation &lt;https://pandas.pydata.org/docs/reference/window.html&gt;`_.</span>

<span class="sd">            For user-provided functions, extra keyword arguments in the transformation dictionary are passed to the</span>
<span class="sd">            user-defined function.</span>
<span class="sd">            By default, Darts expects user-defined functions to receive numpy arrays as input.</span>
<span class="sd">            This can be modified by adding item ``&quot;raw&quot;: False`` in the transformation dictionary.</span>
<span class="sd">            It is expected that the function returns a single</span>
<span class="sd">            value for each window. Other possible configurations can be found in the</span>
<span class="sd">            `pandas.DataFrame.rolling().apply()</span>
<span class="sd">            documentation &lt;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.rolling.html&gt;`_</span>
<span class="sd">            and `pandas.DataFrame.expanding().apply()</span>
<span class="sd">            documentation &lt;https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.expanding.html&gt;`_.</span>

<span class="sd">        treat_na</span>
<span class="sd">            Specifies how to treat missing values that were added by the window transformations</span>
<span class="sd">            at the beginning of the resulting TimeSeries. By default, Darts will leave NaNs in the resulting TimeSeries.</span>
<span class="sd">            This parameter can be one of the following:</span>

<span class="sd">            * :``&quot;dropna&quot;``: to truncate the TimeSeries and drop rows containing missing values.</span>
<span class="sd">                If multiple columns contain different numbers of missing values, only the minimum number</span>
<span class="sd">                of rows is dropped. This operation might reduce the length of the resulting TimeSeries.</span>

<span class="sd">            * :``&quot;bfill&quot;`` or ``&quot;backfill&quot;``: to specify that NaNs should be filled with the last transformed</span>
<span class="sd">                and valid observation. If the original TimeSeries starts with NaNs, those are kept.</span>
<span class="sd">                When ``forecasting_safe`` is ``True``, this option returns an exception to avoid future observation</span>
<span class="sd">                contaminating the past.</span>

<span class="sd">            * :an integer or float: in which case NaNs will be filled with this value.</span>
<span class="sd">                All columns will be filled with the same provided value.</span>

<span class="sd">        forecasting_safe</span>
<span class="sd">            If True, Darts enforces that the resulting TimeSeries is safe to be used in forecasting models as target</span>
<span class="sd">            or as feature. The window transformation will not allow future values to be included in the computations</span>
<span class="sd">            at their corresponding current timestep. Default is ``True``.</span>
<span class="sd">            &quot;ewm&quot; and &quot;expanding&quot; modes are forecasting safe by default.</span>
<span class="sd">            &quot;rolling&quot; mode is forecasting safe if ``&quot;center&quot;: False`` is guaranteed.</span>

<span class="sd">        keep_non_transformed</span>
<span class="sd">            ``False`` to return the transformed components only, ``True`` to return all original components along</span>
<span class="sd">            the transformed ones. Default is ``False``.</span>

<span class="sd">        include_current</span>
<span class="sd">            ``True`` to include the current time step in the window, ``False`` to exclude it. Default is ``True``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            Returns a new TimeSeries instance with the transformed components. If ``keep_non_transformed`` is ``True``,</span>
<span class="sd">            the resulting TimeSeries will contain the original non-transformed components along the transformed ones.</span>
<span class="sd">            If the input series is stochastic, all samples are identically transformed.</span>
<span class="sd">            The naming convention for the transformed components is as follows:</span>
<span class="sd">            [window_mode]_[function_name]_[window_size if provided]_[min_periods if not default]_[original_comp_name],</span>
<span class="sd">            e.g., rolling_sum_3_comp_0 (i.e., window_mode= rolling, function_name = sum, window_size=3,</span>
<span class="sd">            original_comp_name=comp_0) ;</span>
<span class="sd">            ewm_mean_comp_1 (i.e., window_mode= ewm, function_name = mean, original_comp_name=comp_1);</span>
<span class="sd">            expanding_sum_3_comp_2 (i.e., window_mode= expanding, function_name = sum, window_size=3,</span>
<span class="sd">            original_comp_name=comp_2). For user-defined functions, function_name = udf.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">VALID_BFILL_NA</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;bfill&quot;</span><span class="p">,</span> <span class="s2">&quot;backfill&quot;</span><span class="p">}</span>
        <span class="n">VALID_TREAT_NA</span> <span class="o">=</span> <span class="n">VALID_BFILL_NA</span><span class="o">.</span><span class="n">union</span><span class="p">({</span><span class="s2">&quot;dropna&quot;</span><span class="p">})</span>

        <span class="n">PD_WINDOW_OPERATIONS</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;rolling&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">rolling</span><span class="p">,</span>
            <span class="s2">&quot;expanding&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">expanding</span><span class="p">,</span>
            <span class="s2">&quot;ewm&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">ewm</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># helper function to read and format kwargs</span>
        <span class="k">def</span> <span class="nf">_get_kwargs</span><span class="p">(</span><span class="n">transformation</span><span class="p">,</span> <span class="n">forecasting_safe</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Builds the kwargs dictionary for the transformation function.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            transformation</span>
<span class="sd">                The transformation dictionary.</span>
<span class="sd">            builtins</span>
<span class="sd">                The built-in transformations read from the WindowTransformer class.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            dict, dict</span>
<span class="sd">                The kwargs dictionaries for both the function group and the specific function.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># take expanding as the default window operation if not specified, safer than rolling</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">transformation</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mode&quot;</span><span class="p">,</span> <span class="s2">&quot;expanding&quot;</span><span class="p">)</span>

            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="n">mode</span> <span class="ow">in</span> <span class="n">PD_WINDOW_OPERATIONS</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid window operation: &#39;</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&#39;. Must be one of </span><span class="si">{</span><span class="n">PD_WINDOW_OPERATIONS</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">,</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">window_mode</span> <span class="o">=</span> <span class="n">PD_WINDOW_OPERATIONS</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>

            <span class="c1"># minimum number of observations in window required to have a value (otherwise result in NaN)</span>
            <span class="k">if</span> <span class="s2">&quot;min_periods&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">transformation</span><span class="p">:</span>
                <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;min_periods&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;ewm&quot;</span> <span class="k">else</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;rolling&quot;</span><span class="p">:</span>
                <span class="c1"># pandas default for &#39;center&#39; is False, no need to set it explicitly</span>
                <span class="k">if</span> <span class="s2">&quot;center&quot;</span> <span class="ow">in</span> <span class="n">transformation</span><span class="p">:</span>
                    <span class="n">raise_if_not</span><span class="p">(</span>
                        <span class="ow">not</span> <span class="p">(</span><span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">forecasting_safe</span><span class="p">),</span>
                        <span class="s2">&quot;When `forecasting_safe` is True, `center` must be False.&quot;</span><span class="p">,</span>
                        <span class="n">logger</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">],</span> <span class="n">Callable</span><span class="p">):</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="s2">&quot;apply&quot;</span>
                <span class="n">udf</span> <span class="o">=</span> <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]</span>
                <span class="c1"># make sure that we provide a numpy array to the user function, &quot;raw&quot;: True</span>
                <span class="k">if</span> <span class="s2">&quot;raw&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">transformation</span><span class="p">:</span>
                    <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;raw&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Transformation function must be a string or a callable. &quot;</span>
                        <span class="s2">&quot;String can be the name of any function available for pandas window. &quot;</span>
                        <span class="s2">&quot;A list of those function can be found in the `documentation &quot;</span>
                        <span class="s2">&quot;&lt;https://pandas.pydata.org/pandas-docs/stable/reference/window.html&gt;`.&quot;</span>
                    <span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">available_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">transformation</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="p">{</span>
                <span class="s2">&quot;function&quot;</span><span class="p">,</span>
                <span class="s2">&quot;group&quot;</span><span class="p">,</span>
                <span class="s2">&quot;components&quot;</span><span class="p">,</span>
                <span class="s2">&quot;function_name&quot;</span><span class="p">,</span>
            <span class="p">}</span>

            <span class="n">window_mode_expected_args</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">window_mode</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">co_varnames</span><span class="p">)</span>
            <span class="n">window_mode_available_keys</span> <span class="o">=</span> <span class="n">window_mode_expected_args</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                <span class="n">available_keys</span>
            <span class="p">)</span>

            <span class="n">window_mode_available_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">transformation</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">window_mode_available_keys</span>
            <span class="p">}</span>

            <span class="n">available_keys</span> <span class="o">-=</span> <span class="n">window_mode_available_keys</span>

            <span class="n">function_expected_args</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="nb">getattr</span><span class="p">(</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(),</span> <span class="n">window_mode</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)(</span>
                        <span class="o">**</span><span class="n">window_mode_available_kwargs</span>
                    <span class="p">),</span>
                    <span class="n">fn</span><span class="p">,</span>
                <span class="p">)</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">co_varnames</span>
            <span class="p">)</span>

            <span class="n">function_available_keys</span> <span class="o">=</span> <span class="n">function_expected_args</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="n">available_keys</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">function_available_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">transformation</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">function_available_keys</span>
            <span class="p">}</span>

            <span class="n">available_keys</span> <span class="o">-=</span> <span class="n">function_available_keys</span>

            <span class="n">udf_expected_args</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">udf</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">co_varnames</span><span class="p">)</span> <span class="k">if</span> <span class="n">fn</span> <span class="o">==</span> <span class="s2">&quot;apply&quot;</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">udf_available_keys</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">udf_expected_args</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">available_keys</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">fn</span> <span class="o">==</span> <span class="s2">&quot;apply&quot;</span>
                <span class="k">else</span> <span class="kc">None</span>
            <span class="p">)</span>

            <span class="n">udf_kwargs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">transformation</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">udf_available_keys</span><span class="p">}</span>
                <span class="k">if</span> <span class="n">fn</span> <span class="o">==</span> <span class="s2">&quot;apply&quot;</span>
                <span class="k">else</span> <span class="kc">None</span>
            <span class="p">)</span>

            <span class="n">function_available_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="n">udf</span><span class="p">,</span> <span class="s2">&quot;kwargs&quot;</span><span class="p">:</span> <span class="n">udf_kwargs</span><span class="p">}</span> <span class="k">if</span> <span class="n">fn</span> <span class="o">==</span> <span class="s2">&quot;apply&quot;</span> <span class="k">else</span> <span class="p">{}</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">window_mode</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">window_mode_available_kwargs</span><span class="p">),</span> <span class="p">(</span>
                <span class="n">fn</span><span class="p">,</span>
                <span class="n">function_available_kwargs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># make sure we have a list in transforms</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transforms</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="n">transforms</span><span class="p">]</span>

        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">]),</span>
            <span class="s2">&quot;`transforms` must be a non-empty dictionary or a non-empty list of dictionaries.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># read series dataframe</span>
        <span class="n">ts_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># store some original attributes of the series</span>
        <span class="n">original_components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples</span>
        <span class="n">original_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_index</span>

        <span class="n">resulting_transformations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">new_columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">added_na</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># run through all transformations in transforms</span>
        <span class="k">for</span> <span class="n">transformation</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;components&quot;</span> <span class="ow">in</span> <span class="n">transformation</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;components&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;components&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;components&quot;</span><span class="p">]]</span>
                <span class="n">comps_to_transform</span> <span class="o">=</span> <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;components&quot;</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">comps_to_transform</span> <span class="o">=</span> <span class="n">original_components</span>

            <span class="n">df_cols</span> <span class="o">=</span> <span class="n">ts_df</span><span class="o">.</span><span class="n">columns</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">:</span>
                <span class="n">filter_df_columns</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">df_col</span>
                    <span class="k">for</span> <span class="n">df_col</span> <span class="ow">in</span> <span class="n">df_cols</span>
                    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;_s.*$&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">df_col</span><span class="p">)</span> <span class="ow">in</span> <span class="n">comps_to_transform</span>
                <span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">filter_df_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">df_col</span> <span class="k">for</span> <span class="n">df_col</span> <span class="ow">in</span> <span class="n">comps_to_transform</span><span class="p">]</span>

            <span class="p">(</span><span class="n">window_mode</span><span class="p">,</span> <span class="n">window_mode_kwargs</span><span class="p">),</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">function_kwargs</span><span class="p">)</span> <span class="o">=</span> <span class="n">_get_kwargs</span><span class="p">(</span>
                <span class="n">transformation</span><span class="p">,</span> <span class="n">forecasting_safe</span>
            <span class="p">)</span>

            <span class="n">closed</span> <span class="o">=</span> <span class="n">transformation</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;closed&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">include_current</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">window_mode</span> <span class="o">==</span> <span class="s2">&quot;rolling&quot;</span><span class="p">:</span>
                    <span class="n">shifts</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">closed</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span> <span class="k">else</span> <span class="mi">1</span>  <span class="c1"># avoid shifting twice</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">shifts</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shifts</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">resulting_transformations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">resulting_transformations</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span>
                        <span class="nb">getattr</span><span class="p">(</span><span class="n">ts_df</span><span class="p">[</span><span class="n">filter_df_columns</span><span class="p">],</span> <span class="n">window_mode</span><span class="p">)(</span>
                            <span class="o">**</span><span class="n">window_mode_kwargs</span>
                        <span class="p">),</span>
                        <span class="n">fn</span><span class="p">,</span>
                    <span class="p">)(</span><span class="o">**</span><span class="n">function_kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="n">shifts</span><span class="p">),</span>
                <span class="p">],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">min_periods</span> <span class="o">=</span> <span class="n">transformation</span><span class="p">[</span><span class="s2">&quot;min_periods&quot;</span><span class="p">]</span>
            <span class="c1"># set new columns names</span>
            <span class="n">fn_name</span> <span class="o">=</span> <span class="n">transformation</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;function_name&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fn_name</span><span class="p">:</span>
                <span class="n">function_name</span> <span class="o">=</span> <span class="n">fn_name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">function_name</span> <span class="o">=</span> <span class="n">fn</span> <span class="k">if</span> <span class="n">fn</span> <span class="o">!=</span> <span class="s2">&quot;apply&quot;</span> <span class="k">else</span> <span class="s2">&quot;udf&quot;</span>
            <span class="n">name_prefix</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">window_mode</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">function_name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">transformation</span><span class="p">[</span><span class="s1">&#39;window&#39;</span><span class="p">])</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="s1">&#39;window&#39;</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">transformation</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">min_periods</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">min_periods</span><span class="o">&gt;</span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="n">new_columns</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name_prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">comp_name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">comp_name</span> <span class="ow">in</span> <span class="n">comps_to_transform</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># track how many NaN rows are added by each transformation on each transformed column</span>
            <span class="c1"># NaNs would appear only if user changes &quot;min_periods&quot; to else than 1, if not,</span>
            <span class="c1"># by default there should be no NaNs unless the original series starts with NaNs (those would be maintained)</span>
            <span class="n">total_na</span> <span class="o">=</span> <span class="n">min_periods</span> <span class="o">+</span> <span class="n">shifts</span> <span class="o">+</span> <span class="p">(</span><span class="n">closed</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>
            <span class="n">added_na</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">total_na</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">min_periods</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">total_na</span>
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">filter_df_columns</span>
                <span class="p">]</span>
            <span class="p">)</span>

        <span class="c1"># keep all original components</span>
        <span class="k">if</span> <span class="n">keep_non_transformed</span><span class="p">:</span>
            <span class="n">resulting_transformations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span><span class="n">resulting_transformations</span><span class="p">,</span> <span class="n">ts_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">new_columns</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">original_components</span><span class="p">)</span>

        <span class="c1"># Treat NaNs that were introduced by the transformations only</span>
        <span class="c1"># Default to leave NaNs</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">treat_na</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="n">treat_na</span> <span class="ow">in</span> <span class="n">VALID_TREAT_NA</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;`treat_na` must be one of </span><span class="si">{</span><span class="n">VALID_TREAT_NA</span><span class="si">}</span><span class="s2"> or a scalar, but found </span><span class="si">{</span><span class="n">treat_na</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="ow">not</span> <span class="p">(</span><span class="n">treat_na</span> <span class="ow">in</span> <span class="n">VALID_BFILL_NA</span> <span class="ow">and</span> <span class="n">forecasting_safe</span><span class="p">),</span>
                <span class="s2">&quot;when `forecasting_safe` is True, back filling NaNs is not allowed as &quot;</span>
                <span class="s2">&quot;it risks contaminating past time steps with future values.&quot;</span><span class="p">,</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">treat_na</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">treat_na</span> <span class="ow">in</span> <span class="n">VALID_BFILL_NA</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">added_na</span><span class="p">),</span> <span class="n">n_samples</span><span class="p">):</span>
                <span class="n">s_idx</span> <span class="o">=</span> <span class="n">added_na</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">n_samples</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">treat_na</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">treat_na</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
                    <span class="k">else</span> <span class="n">resulting_transformations</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">s_idx</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">n_samples</span><span class="p">)]</span>
                <span class="p">)</span>
                <span class="n">resulting_transformations</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">s_idx</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">n_samples</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">treat_na</span> <span class="o">==</span> <span class="s2">&quot;dropna&quot;</span><span class="p">:</span>
            <span class="c1"># can only drop the NaN rows that are common among the columns</span>
            <span class="n">drop_before_index</span> <span class="o">=</span> <span class="n">original_index</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">added_na</span><span class="p">)]</span>
            <span class="n">resulting_transformations</span> <span class="o">=</span> <span class="n">resulting_transformations</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                <span class="n">drop_before_index</span><span class="p">:</span>
            <span class="p">]</span>

        <span class="c1"># revert dataframe to TimeSeries</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="n">original_index</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">resulting_transformations</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="n">transformed_time_series</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="o">.</span><span class="n">from_times_and_values</span><span class="p">(</span>
            <span class="n">times</span><span class="o">=</span><span class="n">new_index</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">resulting_transformations</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">new_index</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_samples</span>
            <span class="p">),</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">new_columns</span><span class="p">,</span>
            <span class="n">static_covariates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span>
            <span class="n">hierarchy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">transformed_time_series</span></div>

<div class="viewcode-block" id="TimeSeries.to_json"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.to_json">[docs]</a>    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a JSON string representation of this deterministic series.</span>

<span class="sd">        At the moment this function works only on deterministic time series (i.e., made of 1 sample).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Static covariates are not returned in the JSON string. When using `TimeSeries.from_json()`, the static</span>
<span class="sd">        covariates can be added with input argument `static_covariates`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            A JSON String representing the time series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;split&quot;</span><span class="p">,</span> <span class="n">date_format</span><span class="o">=</span><span class="s2">&quot;iso&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.to_csv"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.to_csv">[docs]</a>    <span class="k">def</span> <span class="nf">to_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes this deterministic series to a CSV file.</span>
<span class="sd">        For a list of parameters, refer to the documentation of :func:`pandas.DataFrame.to_csv()` [1]_.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_csv.html?highlight=to_csv</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="s2">&quot;The pd_dataframe() method can only return DataFrames of deterministic &quot;</span>
                    <span class="s2">&quot;time series, and this series is not deterministic (it contains several samples). &quot;</span>
                    <span class="s2">&quot;Consider calling quantile_df() instead.&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pd_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.to_pickle"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.to_pickle">[docs]</a>    <span class="k">def</span> <span class="nf">to_pickle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">protocol</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save this series in pickle format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : string</span>
<span class="sd">            path to a file where current object will be pickled</span>
<span class="sd">        protocol : integer, default highest</span>
<span class="sd">            pickling protocol. The default is best in most cases, use it only if having backward compatibility issues</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Xarray docs [1]_ suggest not using pickle as a long-term data storage.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] http://xarray.pydata.org/en/stable/user-guide/io.html#pickle</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fh</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">protocol</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.plot"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">central_quantile</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">low_quantile</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
        <span class="n">high_quantile</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.95</span><span class="p">,</span>
        <span class="n">default_formatting</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">max_nr_components</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the series.</span>

<span class="sd">        This is a wrapper method around :func:`xarray.DataArray.plot()`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_plot</span>
<span class="sd">            Whether to spawn a new axis to plot on. See also parameter `ax`.</span>
<span class="sd">        central_quantile</span>
<span class="sd">            The quantile (between 0 and 1) to plot as a &quot;central&quot; value, if the series is stochastic (i.e., if</span>
<span class="sd">            it has multiple samples). This will be applied on each component separately (i.e., to display quantiles</span>
<span class="sd">            of the components&#39; marginal distributions). For instance, setting `central_quantile=0.5` will plot the</span>
<span class="sd">            median of each component. `central_quantile` can also be set to &#39;mean&#39;.</span>
<span class="sd">        low_quantile</span>
<span class="sd">            The quantile to use for the lower bound of the plotted confidence interval. Similar to `central_quantile`,</span>
<span class="sd">            this is applied to each component separately (i.e., displaying marginal distributions). No confidence</span>
<span class="sd">            interval is shown if `confidence_low_quantile` is None (default 0.05).</span>
<span class="sd">        high_quantile</span>
<span class="sd">            The quantile to use for the upper bound of the plotted confidence interval. Similar to `central_quantile`,</span>
<span class="sd">            this is applied to each component separately (i.e., displaying marginal distributions). No confidence</span>
<span class="sd">            interval is shown if `high_quantile` is None (default 0.95).</span>
<span class="sd">        default_formatting</span>
<span class="sd">            Whether to use the darts default scheme.</span>
<span class="sd">        label</span>
<span class="sd">            Can either be a string or list of strings. If a string and the series only has a single component, it is</span>
<span class="sd">            used as the label for that component. If a string and the series has multiple components, it is used as</span>
<span class="sd">            a prefix for each component name. If a list of strings with length equal to the number of components in</span>
<span class="sd">            the series, the labels will be mapped to the components in order.</span>
<span class="sd">        max_nr_components</span>
<span class="sd">            The maximum number of components of a series to plot. -1 means all components will be plotted.</span>
<span class="sd">        ax</span>
<span class="sd">            Optionally, an axis to plot on. If `None`, and `new_plot=False`, will use the current axis. If</span>
<span class="sd">            `new_plot=True`, will create a new axis.</span>
<span class="sd">        alpha</span>
<span class="sd">             Optionally, set the line alpha for deterministic series, or the confidence interval alpha for</span>
<span class="sd">            probabilistic series.</span>
<span class="sd">        args</span>
<span class="sd">            some positional arguments for the `plot()` method</span>
<span class="sd">        kwargs</span>
<span class="sd">            some keyword arguments for the `plot()` method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matplotlib.axes.Axes</span>
<span class="sd">            Either the passed `ax` axis, a newly created one if `new_plot=True`, or the existing one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha_confidence_intvls</span> <span class="o">=</span> <span class="mf">0.25</span>

        <span class="k">if</span> <span class="n">central_quantile</span> <span class="o">!=</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">central_quantile</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">central_quantile</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">,</span>
                <span class="s1">&#39;central_quantile must be either &quot;mean&quot;, or a float between 0 and 1.&#39;</span><span class="p">,</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">high_quantile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">low_quantile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">low_quantile</span> <span class="o">&lt;=</span> <span class="mf">1.0</span> <span class="ow">and</span> <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">high_quantile</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">,</span>
                <span class="s2">&quot;confidence interval low and high quantiles must be between 0 and 1.&quot;</span><span class="p">,</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">new_plot</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">lw</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">for</span> <span class="n">lw</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;lw&quot;</span><span class="p">,</span> <span class="s2">&quot;linewidth&quot;</span><span class="p">]):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;lw&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="n">n_components_to_plot</span> <span class="o">=</span> <span class="n">max_nr_components</span>
        <span class="k">if</span> <span class="n">n_components_to_plot</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">n_components_to_plot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">&gt;</span> <span class="n">max_nr_components</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Number of components is larger than </span><span class="si">{</span><span class="n">max_nr_components</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="si">}</span><span class="s2">). &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Plotting only the first </span><span class="si">{</span><span class="n">max_nr_components</span><span class="si">}</span><span class="s2"> components.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;You can overwrite this in the using the `plot_all_components` argument in plot()&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Beware that plotting a large number of components may cause performance issues.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span>
                <span class="ow">or</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">&gt;</span> <span class="n">n_components_to_plot</span>
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">n_components_to_plot</span>
                <span class="p">),</span>
                <span class="s2">&quot;The label argument should have the same length as the number of plotted components &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span><span class="w"> </span><span class="n">n_components_to_plot</span><span class="p">)</span><span class="si">}</span><span class="s2">), only </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="si">}</span><span class="s2"> labels were provided&quot;</span><span class="p">,</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">custom_labels</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">custom_labels</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">component</span><span class="p">[:</span><span class="n">n_components_to_plot</span><span class="p">]):</span>
            <span class="n">comp_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">component</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">central_quantile</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
                    <span class="n">central_series</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">central_series</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">central_quantile</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">central_series</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;alpha&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;alpha&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;alpha&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">custom_labels</span><span class="p">:</span>
                <span class="n">label_to_use</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="n">label_to_use</span> <span class="o">=</span> <span class="n">comp_name</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">label_to_use</span> <span class="o">=</span> <span class="n">label</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">label_to_use</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">comp_name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">label_to_use</span>

            <span class="k">if</span> <span class="n">central_series</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">central_series</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># empty TimeSeries</span>
            <span class="k">elif</span> <span class="n">central_series</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                    <span class="p">[],</span>
                    <span class="p">[],</span>
                    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">()],</span>
                    <span class="n">central_series</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;o&quot;</span><span class="p">,</span>
                    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">color_used</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_color</span><span class="p">()</span> <span class="k">if</span> <span class="n">default_formatting</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="c1"># Optionally show confidence intervals</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">comp</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="n">low_quantile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="n">high_quantile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="n">low_series</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">low_quantile</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">high_series</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">high_quantile</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">low_series</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">,</span>
                        <span class="n">low_series</span><span class="p">,</span>
                        <span class="n">high_series</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">color_used</span><span class="p">,</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="p">(</span><span class="n">alpha</span> <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">alpha_confidence_intvls</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">()],</span>
                        <span class="p">[</span><span class="n">low_series</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high_series</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="s2">&quot;-+&quot;</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">color_used</span><span class="p">,</span>
                        <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="TimeSeries.with_columns_renamed"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.with_columns_renamed">[docs]</a>    <span class="k">def</span> <span class="nf">with_columns_renamed</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">col_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">],</span> <span class="n">col_names_new</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new ``TimeSeries`` instance with new columns/components names. It also</span>
<span class="sd">        adapts the names in the hierarchy, if any.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------</span>
<span class="sd">        col_names</span>
<span class="sd">            String or list of strings corresponding the the column names to be changed.</span>
<span class="sd">        col_names_new</span>
<span class="sd">            String or list of strings corresponding to the new column names. Must be the same length as col_names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">col_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col_names_new</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">col_names_new</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_names_new</span><span class="p">]</span>

        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="nb">all</span><span class="p">([(</span><span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_list</span><span class="p">())</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">col_names</span><span class="p">]),</span>
            <span class="s2">&quot;Some column names in col_names don&#39;t exist in the time series.&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">col_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_names_new</span><span class="p">),</span>
            <span class="s2">&quot;Length of col_names_new list should be&quot;</span>
            <span class="s2">&quot; equal to the length of col_names list.&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">old2new</span> <span class="o">=</span> <span class="p">{</span><span class="n">old</span><span class="p">:</span> <span class="n">new</span> <span class="k">for</span> <span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">col_names</span><span class="p">,</span> <span class="n">col_names_new</span><span class="p">)}</span>

        <span class="c1"># update component names</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">old2new</span><span class="p">[</span><span class="n">old</span><span class="p">]</span> <span class="k">if</span> <span class="n">old</span> <span class="ow">in</span> <span class="n">old2new</span> <span class="k">else</span> <span class="n">old</span> <span class="k">for</span> <span class="n">old</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">]</span>

        <span class="c1"># update hierarchy names</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hierarchy</span> <span class="o">=</span> <span class="p">{</span>
                <span class="p">(</span><span class="n">old2new</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">old2new</span> <span class="k">else</span> <span class="n">key</span><span class="p">):</span> <span class="p">[</span>
                    <span class="n">old2new</span><span class="p">[</span><span class="n">old</span><span class="p">]</span> <span class="k">if</span> <span class="n">old</span> <span class="ow">in</span> <span class="n">old2new</span> <span class="k">else</span> <span class="n">old</span>
                    <span class="k">for</span> <span class="n">old</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hierarchy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">new_attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">attrs</span>
        <span class="n">new_attrs</span><span class="p">[</span><span class="n">HIERARCHY_TAG</span><span class="p">]</span> <span class="o">=</span> <span class="n">hierarchy</span>

        <span class="n">new_xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">,</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cols</span><span class="p">)},</span>
            <span class="n">attrs</span><span class="o">=</span><span class="n">new_attrs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple statistic and aggregation functions. Calculate various statistics over the samples of stochastic time series</span>
<span class="sd">    or aggregate over components/time for deterministic series.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_get_agg_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_cname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper function to rename reduced axis. Returns a dictionary containing the new coordinates&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># set time_index to first day</span>
            <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># rename components</span>
            <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">,</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="n">new_cname</span><span class="p">])}</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># do nothing</span>
            <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span><span class="p">,</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">}</span>

<div class="viewcode-block" id="TimeSeries.mean"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a ``TimeSeries`` containing the mean calculated over the specified axis.</span>

<span class="sd">        If we reduce over time (``axis=0``), the resulting ``TimeSeries`` will have length one and will use the first</span>
<span class="sd">        entry of the original ``time_index``. If we perform the calculation over the components (``axis=1``), the</span>
<span class="sd">        resulting single component will be renamed to &quot;components_mean&quot;.  When applied to the samples (``axis=2``),</span>
<span class="sd">        a deterministic ``TimeSeries`` is returned.</span>

<span class="sd">        If ``axis=1``, the static covariates and the hierarchy are discarded from the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis</span>
<span class="sd">            The axis to reduce over. The default is to calculate over samples, i.e. axis=2.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries with mean applied to the indicated axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">new_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_agg_coords</span><span class="p">(</span><span class="s2">&quot;components_mean&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">new_xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">new_data</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">new_coords</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">attrs</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.median"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.median">[docs]</a>    <span class="k">def</span> <span class="nf">median</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a ``TimeSeries`` containing the median calculated over the specified axis.</span>

<span class="sd">        If we reduce over time (``axis=0``), the resulting ``TimeSeries`` will have length one and will use the first</span>
<span class="sd">        entry of the original ``time_index``. If we perform the calculation over the components (``axis=1``), the</span>
<span class="sd">        resulting single component will be renamed to &quot;components_median&quot;.  When applied to the samples (``axis=2``),</span>
<span class="sd">        a deterministic ``TimeSeries`` is returned.</span>

<span class="sd">        If ``axis=1``, the static covariates and the hierarchy are discarded from the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis</span>
<span class="sd">            The axis to reduce over. The default is to calculate over samples, i.e. axis=2.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries with median applied to the indicated axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">new_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_agg_coords</span><span class="p">(</span><span class="s2">&quot;components_median&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">new_xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">new_data</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">new_coords</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">attrs</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.sum"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a ``TimeSeries`` containing the sum calculated over the specified axis.</span>

<span class="sd">        If we reduce over time (``axis=0``), the resulting ``TimeSeries`` will have length one and will use the first</span>
<span class="sd">        entry of the original ``time_index``. If we perform the calculation over the components (``axis=1``), the</span>
<span class="sd">        resulting single component will be renamed to &quot;components_sum&quot;.  When applied to the samples (``axis=2``),</span>
<span class="sd">        a deterministic ``TimeSeries`` is returned.</span>

<span class="sd">        If ``axis=1``, the static covariates and the hierarchy are discarded from the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis</span>
<span class="sd">            The axis to reduce over. The default is to calculate over samples, i.e. axis=2.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries with sum applied to the indicated axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">new_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_agg_coords</span><span class="p">(</span><span class="s2">&quot;components_sum&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">new_xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">new_data</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">new_coords</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">attrs</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.min"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a ``TimeSeries`` containing the min calculated over the specified axis.</span>

<span class="sd">        If we reduce over time (``axis=0``), the resulting ``TimeSeries`` will have length one and will use the first</span>
<span class="sd">        entry of the original ``time_index``. If we perform the calculation over the components (``axis=1``), the</span>
<span class="sd">        resulting single component will be renamed to &quot;components_min&quot;.  When applied to the samples (``axis=2``),</span>
<span class="sd">        a deterministic ``TimeSeries`` is returned.</span>

<span class="sd">        If ``axis=1``, the static covariates and the hierarchy are discarded from the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis</span>
<span class="sd">            The axis to reduce over. The default is to calculate over samples, i.e. axis=2.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries with min applied to the indicated axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">new_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_agg_coords</span><span class="p">(</span><span class="s2">&quot;components_min&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">new_xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">new_data</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">new_coords</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">attrs</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.max"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a ``TimeSeries`` containing the max calculated over the specified axis.</span>

<span class="sd">        If we reduce over time (``axis=0``), the resulting ``TimeSeries`` will have length one and will use the first</span>
<span class="sd">        entry of the original ``time_index``. If we perform the calculation over the components (``axis=1``), the</span>
<span class="sd">        resulting single component will be renamed to &quot;components_max&quot;.  When applied to the samples (``axis=2``),</span>
<span class="sd">        a deterministic ``TimeSeries`` is returned.</span>

<span class="sd">        If ``axis=1``, the static covariates and the hierarchy are discarded from the series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis</span>
<span class="sd">            The axis to reduce over. The default is to calculate over samples, i.e. axis=2.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            A new TimeSeries with max applied to the indicated axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">new_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_agg_coords</span><span class="p">(</span><span class="s2">&quot;components_max&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">new_xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">new_data</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">new_coords</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">attrs</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.var"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.var">[docs]</a>    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ddof</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a deterministic ``TimeSeries`` containing the variance of each component</span>
<span class="sd">        (over the samples) of this stochastic ``TimeSeries``.</span>

<span class="sd">        This works only on stochastic series (i.e., with more than 1 sample)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ddof</span>
<span class="sd">            &quot;Delta Degrees of Freedom&quot;: the divisor used in the calculation is N - ddof where N represents the</span>
<span class="sd">            number of elements. By default, ddof is 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The TimeSeries containing the variance for each component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_stochastic</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">new_xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">new_data</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">attrs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.std"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.std">[docs]</a>    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ddof</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a deterministic ``TimeSeries`` containing the standard deviation of each component</span>
<span class="sd">        (over the samples) of this stochastic ``TimeSeries``.</span>

<span class="sd">        This works only on stochastic series (i.e., with more than 1 sample)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ddof</span>
<span class="sd">            &quot;Delta Degrees of Freedom&quot;: the divisor used in the calculation is N - ddof where N represents the</span>
<span class="sd">            number of elements. By default, ddof is 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The TimeSeries containing the standard deviation for each component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_stochastic</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">new_xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">new_data</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">attrs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.skew"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.skew">[docs]</a>    <span class="k">def</span> <span class="nf">skew</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a deterministic ``TimeSeries`` containing the skew of each component</span>
<span class="sd">        (over the samples) of this stochastic ``TimeSeries``.</span>

<span class="sd">        This works only on stochastic series (i.e., with more than 1 sample)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs</span>
<span class="sd">            Other keyword arguments are passed down to `scipy.stats.skew()`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The TimeSeries containing the skew for each component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_stochastic</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">skew</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">new_xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">new_data</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">attrs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.kurtosis"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.kurtosis">[docs]</a>    <span class="k">def</span> <span class="nf">kurtosis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a deterministic ``TimeSeries`` containing the kurtosis of each component</span>
<span class="sd">        (over the samples) of this stochastic ``TimeSeries``.</span>

<span class="sd">        This works only on stochastic series (i.e., with more than 1 sample)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs</span>
<span class="sd">            Other keyword arguments are passed down to `scipy.stats.kurtosis()`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The TimeSeries containing the kurtosis for each component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_stochastic</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">kurtosis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">new_xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">new_data</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">attrs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.quantile"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.TimeSeries.quantile">[docs]</a>    <span class="k">def</span> <span class="nf">quantile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantile</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a deterministic ``TimeSeries`` containing the single desired quantile of each component</span>
<span class="sd">        (over the samples) of this stochastic ``TimeSeries``.</span>

<span class="sd">        The components in the new series are named &quot;&lt;component&gt;_X&quot;, where &quot;&lt;component&gt;&quot;</span>
<span class="sd">        is the column name corresponding to this component, and &quot;X&quot; is the quantile value.</span>
<span class="sd">        The quantile columns represent the marginal distributions of the components of this series.</span>

<span class="sd">        This works only on stochastic series (i.e., with more than 1 sample)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        quantile</span>
<span class="sd">            The desired quantile value. The value must be represented as a fraction</span>
<span class="sd">            (between 0 and 1 inclusive). For instance, `0.5` will return a TimeSeries</span>
<span class="sd">            containing the median of the (marginal) distribution of each component.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Other keyword arguments are passed down to `numpy.quantile()`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries</span>
<span class="sd">            The TimeSeries containing the desired quantile for each component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantile_timeseries</span><span class="p">(</span><span class="n">quantile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dunder methods</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_combine_arrays</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;TimeSeries&quot;</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">combine_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a helper function that allows us to combine this series with another one,</span>
<span class="sd">        directly applying an operation on their underlying numpy arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="n">other_vals</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="n">other_vals</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_vals</span> <span class="o">=</span> <span class="n">other</span>

        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="s2">&quot;Attempted to perform operation on two TimeSeries of unequal shapes.&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">new_xa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_xa</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">combine_fn</span><span class="p">(</span><span class="n">new_xa</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other_vals</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_xa</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_fill_missing_dates</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">xa</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an xarray DataArray instance with missing dates inserted from an input xarray DataArray.</span>
<span class="sd">        The first dimension of the input DataArray `xa` has to be the time dimension.</span>

<span class="sd">        This requires either a provided `freq` or the possibility to infer a unique frequency (see</span>
<span class="sd">        `offset aliases &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_</span>
<span class="sd">        for more info on supported frequencies) from the provided timestamps.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xa</span>
<span class="sd">            The xarray DataArray</span>
<span class="sd">        freq</span>
<span class="sd">            Optionally, a string representing the frequency of the Pandas DateTimeIndex to fill in the missing dates.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `xa`&#39;s DateTimeIndex contains less than 3 elements;</span>
<span class="sd">            if no unique frequency can be inferred from `xa`&#39;s DateTimeIndex;</span>
<span class="sd">            if the resampled DateTimeIndex does not contain all dates from `xa` (see</span>
<span class="sd">                :meth:`_restore_xarray_from_frequency() &lt;TimeSeries._restore_xarray_from_frequency&gt;`)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray DataArray</span>
<span class="sd">            xarray DataArray with filled missing dates from `xa`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_restore_xarray_from_frequency</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

        <span class="n">raise_if</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">,</span>
            <span class="s2">&quot;Input time series must be of (length&gt;=3) when fill_missing_dates=True and freq=None.&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">time_dim</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sorted_xa</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_sort_index</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">time_index</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">sorted_xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">time_dim</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="n">has_datetime_index</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">observed_freqs</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_observed_freq_datetime_index</span><span class="p">(</span><span class="n">time_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># integer index (non RangeIndex)</span>
            <span class="n">has_datetime_index</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">observed_freqs</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_observed_freq_integer_index</span><span class="p">(</span><span class="n">time_index</span><span class="p">)</span>

        <span class="n">offset_alias_info</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span>
                <span class="s2">&quot; For more information about frequency aliases, read &quot;</span>
                <span class="s2">&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">has_datetime_index</span>
            <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">observed_freqs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Could not observe an inferred frequency. An explicit frequency must be evident over a span of &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;at least 3 consecutive time stamps in the input data. </span><span class="si">{</span><span class="n">offset_alias_info</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">observed_freqs</span><span class="p">)</span>
                    <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;Could not find a unique inferred frequency (not constant). Observed frequencies: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">observed_freqs</span><span class="si">}</span><span class="s2">. If any of those is the actual frequency, try passing it with &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;`fill_missing_dates=True` and `freq=your_frequency`.</span><span class="si">{</span><span class="n">offset_alias_info</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">freq</span> <span class="o">=</span> <span class="n">observed_freqs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_restore_xarray_from_frequency</span><span class="p">(</span><span class="n">sorted_xa</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_sort_index</span><span class="p">(</span><span class="n">xa</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sorts an xarray by its time dimension index (only if it is not already monotonically increasing).&quot;&quot;&quot;</span>
        <span class="n">time_dim</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">xa</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">time_dim</span><span class="p">)</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>
            <span class="k">else</span> <span class="n">xa</span><span class="o">.</span><span class="n">sortby</span><span class="p">(</span><span class="n">time_dim</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_observed_freq_datetime_index</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns all observed/inferred frequencies of a pandas DatetimeIndex. The frequencies are inferred from all</span>
<span class="sd">        combinations of three adjacent time steps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># find unique time deltas indices from three consecutive time stamps</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">unq_td_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([(</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">index</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])]),</span>
            <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># for each unique index, take one example including the left time stamp, and one including the right</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">index</span><span class="p">[</span><span class="n">unq_td_index</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>

        <span class="c1"># find all unique inferred frequencies</span>
        <span class="n">observed_freqs</span> <span class="o">=</span> <span class="p">{</span><span class="n">pd</span><span class="o">.</span><span class="n">infer_freq</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">}</span>
        <span class="n">observed_freqs</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">observed_freqs</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_observed_freq_integer_index</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns all observed/inferred frequencies of a pandas Index (integer index). The frequencies are inferred</span>
<span class="sd">        from all differences between two adjacent indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">index</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_integer_to_range_indexed_xarray</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">xa</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If possible, converts an integer indexed xarray DataArray to a range indexed (pd.RangeIndex) DataArray.</span>
<span class="sd">        Otherwise, raises an error. An integer Index can be converted to a pd.RangeIndex, if the sorted integer index</span>
<span class="sd">        has a constant step size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_dim</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sorted_xa</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_sort_index</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">time_index</span> <span class="o">=</span> <span class="n">sorted_xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">time_dim</span><span class="p">)</span>
        <span class="n">observed_freqs</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_observed_freq_integer_index</span><span class="p">(</span><span class="n">time_index</span><span class="p">)</span>
        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">observed_freqs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;Could not convert integer index to a pd.RangeIndex. Found non-unique step sizes/frequencies: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">observed_freqs</span><span class="si">}</span><span class="s2">. If any of those is the actual frequency, try passing it with fill_missing_dates=True &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;and freq=your_frequency.&quot;</span><span class="p">,</span>
            <span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">observed_freqs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span>
            <span class="n">start</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">time_index</span><span class="p">),</span>
            <span class="n">stop</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">time_index</span><span class="p">)</span> <span class="o">+</span> <span class="n">freq</span><span class="p">,</span>
            <span class="n">step</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">time_index</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> <span class="n">idx</span><span class="p">,</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> <span class="n">xa</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">sorted_xa</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="n">xa</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_restore_xarray_from_frequency</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">xa</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">freq</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an xarray DataArray instance that is resampled from an input xarray DataArray `xa` with frequency</span>
<span class="sd">        `freq`. `freq` should be the inferred or actual frequency of `xa`. All data from `xa` is maintained in the</span>
<span class="sd">        output DataArray at the corresponding dates. Any missing dates from `xa` will be inserted into the returned</span>
<span class="sd">        DataArray with np.nan values.</span>

<span class="sd">        The first dimension of the input DataArray `xa` has to be the time dimension.</span>

<span class="sd">        This requires a provided frequency/step size `freq`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xa</span>
<span class="sd">            The xarray DataArray</span>
<span class="sd">        freq</span>
<span class="sd">            If a string, represents the actual or inferred frequency of the pandas DatetimeIndex from `xa` (see</span>
<span class="sd">            `offset aliases &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_</span>
<span class="sd">            for more info on supported frequencies).</span>
<span class="sd">            If an integer, represents the actual or inferred step size of the pandas Index or pandas RangeIndex from</span>
<span class="sd">            `xa`.</span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the resampled/reindexed DateTimeIndex/RangeIndex does not contain all dates from `xa`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray DataArray</span>
<span class="sd">            xarray DataArray resampled from `xa` with `freq` including all data from `xa` and inserted missing dates</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">time_dim</span> <span class="o">=</span> <span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sorted_xa</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_sort_index</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">time_index</span> <span class="o">=</span> <span class="n">sorted_xa</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">time_dim</span><span class="p">)</span>
        <span class="n">resampled_time_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">time_index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="n">has_datetime_index</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">resampled_time_index</span> <span class="o">=</span> <span class="n">resampled_time_index</span><span class="o">.</span><span class="n">asfreq</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># integer index (non RangeIndex) -&gt; resampled to RangeIndex</span>
            <span class="n">has_datetime_index</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">resampled_time_index</span> <span class="o">=</span> <span class="n">resampled_time_index</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">time_index</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">time_index</span><span class="p">)</span> <span class="o">+</span> <span class="n">freq</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># check if new time index with inferred frequency contains all input data</span>
        <span class="n">contains_all_data</span> <span class="o">=</span> <span class="n">time_index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">resampled_time_index</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

        <span class="n">offset_alias_info</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span>
                <span class="s2">&quot; For more information about frequency aliases, read &quot;</span>
                <span class="s2">&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">has_datetime_index</span>
            <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">contains_all_data</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Could not correctly fill missing </span><span class="si">{</span><span class="s1">&#39;dates&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">has_datetime_index</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;indices&#39;</span><span class="si">}</span><span class="s2"> with the &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;observed/passed </span><span class="si">{</span><span class="s1">&#39;frequency&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">has_datetime_index</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;step size&#39;</span><span class="si">}</span><span class="s2"> `freq=&#39;</span><span class="si">{</span><span class="n">freq</span><span class="si">}</span><span class="s2">&#39;`. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Not all input </span><span class="si">{</span><span class="s1">&#39;time stamps&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">has_datetime_index</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;indices&#39;</span><span class="si">}</span><span class="s2"> contained in the newly &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;created TimeSeries.</span><span class="si">{</span><span class="n">offset_alias_info</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> <span class="n">resampled_time_index</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> <span class="n">xa</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
        <span class="p">}</span>

        <span class="c1"># convert to float as for instance integer arrays cannot accept nans</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">xa</span><span class="o">.</span><span class="n">dtype</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
        <span class="p">)</span>
        <span class="n">resampled_xa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">resampled_time_index</span><span class="p">),)</span> <span class="o">+</span> <span class="n">xa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span>
            <span class="p">),</span>
            <span class="n">dims</span><span class="o">=</span><span class="n">xa</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="n">xa</span><span class="o">.</span><span class="n">attrs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">resampled_xa</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">resampled_xa</span><span class="p">[</span><span class="n">resampled_time_index</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">time_index</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sorted_xa</span><span class="o">.</span><span class="n">data</span>
        <span class="k">return</span> <span class="n">resampled_xa</span>

    <span class="k">def</span> <span class="nf">_get_dim_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span>
            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">DIMS</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">raise_if</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;If `axis` is an integer it must be between 0 and 2.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">known_dims</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">,)</span> <span class="o">+</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="n">axis</span> <span class="ow">in</span> <span class="n">known_dims</span><span class="p">,</span>
                <span class="s2">&quot;`axis` must be a known dimension of this series: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">known_dims</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">axis</span>

    <span class="k">def</span> <span class="nf">_get_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">axis</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;If `axis` is an integer it must be between 0 and 2.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">axis</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">known_dims</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">,)</span> <span class="o">+</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="n">axis</span> <span class="ow">in</span> <span class="n">known_dims</span><span class="p">,</span>
                <span class="s2">&quot;`axis` must be a known dimension of this series: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">known_dims</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">known_dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="n">_xarray_with_attrs</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">+</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_arrays</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;unsupported operand type(s) for + or add(): &#39;</span><span class="si">{}</span><span class="s2">&#39; and &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="p">)</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="n">_xarray_with_attrs</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">-</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_arrays</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">s1</span> <span class="o">-</span> <span class="n">s2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;unsupported operand type(s) for - or sub(): &#39;</span><span class="si">{}</span><span class="s2">&#39; and &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="p">)</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="n">_xarray_with_attrs</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">*</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_arrays</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">s1</span> <span class="o">*</span> <span class="n">s2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;unsupported operand type(s) for * or mul(): &#39;</span><span class="si">{}</span><span class="s2">&#39; and &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="p">)</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">raise_if</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Attempted to raise a series to a negative power.&quot;</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="n">_xarray_with_attrs</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">**</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_arrays</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">s1</span><span class="o">**</span><span class="n">s2</span><span class="p">)</span>  <span class="c1"># elementwise power</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;unsupported operand type(s) for ** or pow(): &#39;</span><span class="si">{}</span><span class="s2">&#39; and &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="p">)</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">raise_log</span><span class="p">(</span><span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s2">&quot;Cannot divide by 0.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="n">_xarray_with_attrs</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">/</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">TimeSeries</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">all_values</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">raise_log</span><span class="p">(</span>
                    <span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s2">&quot;Cannot divide by a TimeSeries with a value 0.&quot;</span><span class="p">),</span>
                    <span class="n">logger</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_arrays</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="n">s1</span> <span class="o">/</span> <span class="n">s2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;unsupported operand type(s) for / or truediv(): &#39;</span><span class="si">{}</span><span class="s2">&#39; and &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="p">)</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span>

    <span class="k">def</span> <span class="fm">__round__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">_xarray_with_attrs</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_xarray_with_attrs</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;unsupported operand type(s) for &lt; : &#39;</span><span class="si">{}</span><span class="s2">&#39; and &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="p">)</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">_xarray_with_attrs</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">&gt;</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_xarray_with_attrs</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;unsupported operand type(s) for &lt; : &#39;</span><span class="si">{}</span><span class="s2">&#39; and &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="p">)</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">_xarray_with_attrs</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_xarray_with_attrs</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;unsupported operand type(s) for &lt; : &#39;</span><span class="si">{}</span><span class="s2">&#39; and &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="p">)</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">_xarray_with_attrs</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_xarray_with_attrs</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;unsupported operand type(s) for &lt; : &#39;</span><span class="si">{}</span><span class="s2">&#39; and &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="p">)</span>
                <span class="p">),</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;xarray.DataArray&quot;</span><span class="p">,</span> <span class="s2">&quot;TimeSeries (DataArray)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;xarray.DataArray&quot;</span><span class="p">,</span> <span class="s2">&quot;TimeSeries (DataArray)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">_repr_html_</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="s2">&quot;xarray.DataArray&quot;</span><span class="p">,</span> <span class="s2">&quot;TimeSeries (DataArray)&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="p">,</span> <span class="n">memo</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">,</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">,</span>
            <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
            <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
            <span class="n">List</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">],</span>
            <span class="nb">str</span><span class="p">,</span>
            <span class="nb">int</span><span class="p">,</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span>
            <span class="n">Any</span><span class="p">,</span>
        <span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Allow indexing on darts TimeSeries.</span>

<span class="sd">        The supported index types are the following base types as a single value, a list or a slice:</span>
<span class="sd">        - pd.Timestamp -&gt; return a TimeSeries corresponding to the value(s) at the given timestamp(s).</span>
<span class="sd">        - str -&gt; return a TimeSeries including the column(s) (components) specified as str.</span>
<span class="sd">        - int -&gt; return a TimeSeries with the value(s) at the given row (time) index.</span>

<span class="sd">        `pd.DatetimeIndex` and `pd.RangeIndex` are also supported and will return the corresponding value(s)</span>
<span class="sd">        at the provided time indices.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            slices use pandas convention of including both ends of the slice.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For integer-indexed series, integers or slices of integer will return the result</span>
<span class="sd">        of ``isel()``. That is, if integer ``i`` is provided, it returns the ``i``-th value</span>
<span class="sd">        along the series, which is not necessarily the value where the time index is equal to ``i``</span>
<span class="sd">        (e.g., if the time index does not start at 0). In contrast, calling this method with a</span>
<span class="sd">        ``pd.RangeIndex`` returns the result of ``sel()`` - i.e., the values where the time</span>
<span class="sd">        index matches the provided range index.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_check_dt</span><span class="p">():</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">,</span>
                <span class="s2">&quot;Attempted indexing a series with a DatetimeIndex or a timestamp, &quot;</span>
                <span class="s2">&quot;but the series uses a RangeIndex.&quot;</span><span class="p">,</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">_check_range</span><span class="p">():</span>
            <span class="n">raise_if</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_datetime_index</span><span class="p">,</span>
                <span class="s2">&quot;Attempted indexing a series with a RangeIndex, &quot;</span>
                <span class="s2">&quot;but the series uses a DatetimeIndex.&quot;</span><span class="p">,</span>
                <span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">_set_freq_in_xa</span><span class="p">(</span><span class="n">xa_</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="c1"># mutates the DataArray to make sure it contains the freq</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xa_</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">),</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
                <span class="n">inferred_freq</span> <span class="o">=</span> <span class="n">xa_</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">)</span><span class="o">.</span><span class="n">inferred_freq</span>
                <span class="k">if</span> <span class="n">inferred_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">xa_</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">)</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">inferred_freq</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xa_</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">)</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>

        <span class="n">adapt_covs_on_component</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_static_covariates</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="k">else</span> <span class="kc">False</span>
        <span class="p">)</span>

        <span class="c1"># handle DatetimeIndex and RangeIndex:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="n">_check_dt</span><span class="p">()</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="n">key</span><span class="p">})</span>

            <span class="c1"># indexing may discard the freq so we restore it...</span>
            <span class="c1"># TODO: unit-test this</span>
            <span class="n">_set_freq_in_xa</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">):</span>
            <span class="n">_check_range</span><span class="p">()</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="n">key</span><span class="p">})</span>

            <span class="c1"># sel() gives us an Int64Index. We have to set the RangeIndex.</span>
            <span class="c1"># see: https://github.com/pydata/xarray/issues/6256</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="n">xa_</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">time_dim</span><span class="p">:</span> <span class="n">key</span><span class="p">})</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>

        <span class="c1"># handle slices:</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">xa_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">key</span><span class="p">})</span>
                <span class="c1"># selecting components discards the hierarchy, if any</span>
                <span class="n">xa_</span> <span class="o">=</span> <span class="n">_xarray_with_attrs</span><span class="p">(</span>
                    <span class="n">xa_</span><span class="p">,</span>
                    <span class="n">xa_</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">STATIC_COV_TAG</span><span class="p">][</span><span class="n">key</span><span class="o">.</span><span class="n">start</span> <span class="p">:</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">adapt_covs_on_component</span>
                    <span class="k">else</span> <span class="n">xa_</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">STATIC_COV_TAG</span><span class="p">],</span>
                    <span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">xa_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="n">key</span><span class="p">})</span>
                <span class="n">_set_freq_in_xa</span><span class="p">(</span>
                    <span class="n">xa_</span>
                <span class="p">)</span>  <span class="c1"># indexing may discard the freq so we restore it...</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span>
            <span class="p">):</span>
                <span class="n">_check_dt</span><span class="p">()</span>

                <span class="c1"># indexing may discard the freq so we restore it...</span>
                <span class="n">xa_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="n">key</span><span class="p">})</span>
                <span class="n">_set_freq_in_xa</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>

        <span class="c1"># handle simple types:</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># have to put key in a list not to drop the dimension</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="p">[</span><span class="n">key</span><span class="p">]})</span>
            <span class="c1"># selecting components discards the hierarchy, if any</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="n">_xarray_with_attrs</span><span class="p">(</span>
                <span class="n">xa_</span><span class="p">,</span>
                <span class="n">xa_</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">STATIC_COV_TAG</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[[</span><span class="n">key</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">adapt_covs_on_component</span>
                <span class="k">else</span> <span class="n">xa_</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">STATIC_COV_TAG</span><span class="p">],</span>
                <span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="p">[</span><span class="n">key</span><span class="p">]})</span>

            <span class="c1"># restore a RangeIndex if needed:</span>
            <span class="n">time_idx</span> <span class="o">=</span> <span class="n">xa_</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">time_idx</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">time_idx</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span>
            <span class="p">):</span>
                <span class="n">xa_</span> <span class="o">=</span> <span class="n">xa_</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span>
                            <span class="n">start</span><span class="o">=</span><span class="n">time_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                            <span class="n">stop</span><span class="o">=</span><span class="n">time_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
                            <span class="n">step</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">)</span>

            <span class="n">_set_freq_in_xa</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>  <span class="c1"># indexing may discard the freq so we restore it...</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">):</span>
            <span class="n">_check_dt</span><span class="p">()</span>

            <span class="c1"># indexing may discard the freq so we restore it...</span>
            <span class="n">xa_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="p">[</span><span class="n">key</span><span class="p">]})</span>
            <span class="n">_set_freq_in_xa</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>

        <span class="c1"># handle lists:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
                <span class="c1"># when string(s) are provided, we consider it as (a list of) component(s)</span>
                <span class="n">xa_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">key</span><span class="p">})</span>
                <span class="n">xa_</span> <span class="o">=</span> <span class="n">_xarray_with_attrs</span><span class="p">(</span>
                    <span class="n">xa_</span><span class="p">,</span>
                    <span class="n">xa_</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">STATIC_COV_TAG</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">adapt_covs_on_component</span>
                    <span class="k">else</span> <span class="n">xa_</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">STATIC_COV_TAG</span><span class="p">],</span>
                    <span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
                <span class="n">xa_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="n">key</span><span class="p">})</span>

                <span class="c1"># indexing may discard the freq so we restore it...</span>
                <span class="n">_set_freq_in_xa</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>

                <span class="n">orig_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orig_idx</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">):</span>
                    <span class="c1"># We have to restore a RangeIndex. But first we need to</span>
                    <span class="c1"># check the list is corresponding to a RangeIndex.</span>
                    <span class="n">min_idx</span><span class="p">,</span> <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="n">raise_if_not</span><span class="p">(</span>
                        <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">min_idx</span>
                        <span class="ow">and</span> <span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">max_idx</span>
                        <span class="ow">and</span> <span class="n">max_idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">min_idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
                        <span class="s2">&quot;Indexing a TimeSeries with a list requires the list to contain monotically &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;increasing integers with no gap.&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">new_idx</span> <span class="o">=</span> <span class="n">orig_idx</span><span class="p">[</span><span class="n">min_idx</span> <span class="p">:</span> <span class="n">max_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">xa_</span> <span class="o">=</span> <span class="n">xa_</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="n">new_idx</span><span class="p">})</span>

                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
                <span class="n">_check_dt</span><span class="p">()</span>

                <span class="c1"># indexing may discard the freq so we restore it...</span>
                <span class="n">xa_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xa</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span><span class="p">:</span> <span class="n">key</span><span class="p">})</span>
                <span class="n">_set_freq_in_xa</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xa_</span><span class="p">)</span>

        <span class="n">raise_log</span><span class="p">(</span><span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;The type of your index was not matched.&quot;</span><span class="p">),</span> <span class="n">logger</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_xarray_with_attrs</span><span class="p">(</span><span class="n">xa_</span><span class="p">,</span> <span class="n">static_covariates</span><span class="p">,</span> <span class="n">hierarchy</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return an DataArray instance with static covariates and hierarchy stored in the array&#39;s attributes.</span>
<span class="sd">    Warning: This is an inplace operation (mutable) and should only be called from within TimeSeries construction</span>
<span class="sd">    or to restore static covariates and hierarchy after operations in which they did not get transferred.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xa_</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">STATIC_COV_TAG</span><span class="p">]</span> <span class="o">=</span> <span class="n">static_covariates</span>
    <span class="n">xa_</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">HIERARCHY_TAG</span><span class="p">]</span> <span class="o">=</span> <span class="n">hierarchy</span>
    <span class="k">return</span> <span class="n">xa_</span>


<span class="k">def</span> <span class="nf">_concat_static_covs</span><span class="p">(</span><span class="n">series</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="s2">&quot;TimeSeries&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Concatenates static covariates along component dimension (rows of static covariates). For stacking or</span>
<span class="sd">    concatenating TimeSeries along component dimension (axis=1).</span>

<span class="sd">    Some context for stacking or concatenating two or more TimeSeries with static covariates:</span>
<span class="sd">        Concat along axis=0 (time)</span>
<span class="sd">            Along time dimension, we only take the static covariates of the first series (as static covariates are</span>
<span class="sd">            time-independent).</span>
<span class="sd">        Concat along axis=1 (components) or stacking</span>
<span class="sd">            Along component dimension, we either concatenate or transfer the static covariates of the series if one</span>
<span class="sd">            of below cases applies:</span>
<span class="sd">            1)  concatenate along component dimension (rows of static covariates) when for each series the number of</span>
<span class="sd">                static covariate components is equal to the number of components in the series. The static variable</span>
<span class="sd">                names (columns in series.static_covariates) must be identical across all series</span>
<span class="sd">            2)  if only the first series contains static covariates transfer only those</span>
<span class="sd">            3)  if `ignore_static_covarites=True` (with `concatenate()`), case 1) is ignored and only the static</span>
<span class="sd">                covariates of the first series are transferred</span>
<span class="sd">        Concat along axis=2 (samples)</span>
<span class="sd">            Along sample dimension, we only take the static covariates of the first series (as we components and</span>
<span class="sd">            time don&#39;t change).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">ts</span><span class="o">.</span><span class="n">has_static_covariates</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">only_first</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">has_static_covariates</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
        <span class="p">[</span><span class="n">ts</span><span class="o">.</span><span class="n">has_static_covariates</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
    <span class="p">)</span>
    <span class="n">all_have</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">ts</span><span class="o">.</span><span class="n">has_static_covariates</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">])</span>

    <span class="n">raise_if_not</span><span class="p">(</span>
        <span class="n">only_first</span> <span class="ow">or</span> <span class="n">all_have</span><span class="p">,</span>
        <span class="s2">&quot;Either none, only the first or all TimeSeries must have `static_covariates`.&quot;</span><span class="p">,</span>
        <span class="n">logger</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">only_first</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">static_covariates</span>

    <span class="n">raise_if_not</span><span class="p">(</span>
        <span class="nb">all</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">)</span> <span class="o">==</span> <span class="n">ts</span><span class="o">.</span><span class="n">n_components</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">])</span>
        <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">ts</span><span class="o">.</span><span class="n">static_covariates</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">static_covariates</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span>
            <span class="p">]</span>
        <span class="p">),</span>
        <span class="s2">&quot;Concatenation of multiple TimeSeries with static covariates requires all `static_covariates` &quot;</span>
        <span class="s2">&quot;DataFrames to have identical columns (static variable names), and the number of each TimeSeries&#39; &quot;</span>
        <span class="s2">&quot;components must match the number of corresponding static covariate components (the number of rows &quot;</span>
        <span class="s2">&quot;in `series.static_covariates`).&quot;</span><span class="p">,</span>
        <span class="n">logger</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
        <span class="p">[</span><span class="n">ts</span><span class="o">.</span><span class="n">static_covariates</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span> <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">has_static_covariates</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_concat_hierarchy</span><span class="p">(</span><span class="n">series</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="s2">&quot;TimeSeries&quot;</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used to concatenate the hierarchies of multiple TimeSeries, when concatenating series</span>
<span class="sd">    along axis 1 (components). This simply merges the hierarchy dictionaries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">concat_hierarchy</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">series</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">has_hierarchy</span><span class="p">:</span>
            <span class="n">concat_hierarchy</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">hierarchy</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">concat_hierarchy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">concat_hierarchy</span>


<div class="viewcode-block" id="concatenate"><a class="viewcode-back" href="../../generated_api/darts.timeseries.html#darts.timeseries.concatenate">[docs]</a><span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span>
    <span class="n">series</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="s2">&quot;TimeSeries&quot;</span><span class="p">],</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">ignore_time_axis</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">ignore_static_covariates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">drop_hierarchy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Concatenates multiple ``TimeSeries`` along a given axis.</span>

<span class="sd">    ``axis`` can be an integer in (0, 1, 2) to denote (time, component, sample) or, alternatively,</span>
<span class="sd">    a string denoting the corresponding dimension of the underlying ``DataArray``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    series : Sequence[TimeSeries]</span>
<span class="sd">        sequence of ``TimeSeries`` to concatenate</span>
<span class="sd">    axis : Union[str, int]</span>
<span class="sd">        axis along which the series will be concatenated.</span>
<span class="sd">    ignore_time_axis : bool</span>
<span class="sd">        Allow concatenation even when some series do not have matching time axes.</span>
<span class="sd">        When done along component or sample dimensions, concatenation will work as long as the series</span>
<span class="sd">        have the same lengths (in this case the resulting series will have the time axis of the first</span>
<span class="sd">        provided series). When done along time dimension, concatenation will work even if the time axes</span>
<span class="sd">        are not contiguous (in this case, the resulting series will have a start time matching the start time</span>
<span class="sd">        of the first provided series). Default: False.</span>
<span class="sd">    ignore_static_covariates : bool</span>
<span class="sd">        whether to ignore all requirements for static covariate concatenation and only transfer the static covariates</span>
<span class="sd">        of the first TimeSeries element in `series` to the concatenated TimeSeries. Only effective when `axis=1`.</span>
<span class="sd">    drop_hierarchy : bool</span>
<span class="sd">        When `axis=1`, whether to drop hierarchy information. True by default. When False, the hierarchies will be</span>
<span class="sd">        &quot;concatenated&quot; as well (by merging the hierarchy dictionaries), which may cause issues if the component</span>
<span class="sd">        names of the resulting series and that of the merged hierarchy do not match.</span>
<span class="sd">        When `axis=0` or `axis=2`, the hierarchy of the first series is always kept.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    TimeSeries</span>
<span class="sd">        concatenated series</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">time_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">ts</span><span class="o">.</span><span class="n">time_dim</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">time_dims</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">time_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;Unrecognised `axis` name. If `axis` denotes the time axis, all provided &quot;</span>
                <span class="s2">&quot;series must have the same time axis name (if that is not the case, try providing &quot;</span>
                <span class="s2">&quot;`axis=0` to concatenate along time dimension).&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># At this point all series are supposed to have same time dim name</span>
    <span class="n">time_dim_name</span> <span class="o">=</span> <span class="n">time_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">da_sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">ts</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">]</span>

    <span class="n">component_axis_equal</span> <span class="o">=</span> <span class="nb">len</span><span class="p">({</span><span class="n">ts</span><span class="o">.</span><span class="n">width</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">})</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">sample_axis_equal</span> <span class="o">=</span> <span class="nb">len</span><span class="p">({</span><span class="n">ts</span><span class="o">.</span><span class="n">n_samples</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">})</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># time</span>
        <span class="n">raise_if</span><span class="p">(</span>
            <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">component_axis_equal</span> <span class="ow">and</span> <span class="n">sample_axis_equal</span><span class="p">)),</span>
            <span class="s2">&quot;when concatenating along time dimension, the component and sample dimensions of all &quot;</span>
            <span class="s2">&quot;provided series must match.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">da_concat</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">da_sequence</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">time_dim_name</span><span class="p">)</span>

        <span class="c1"># check, if timeseries are consecutive</span>
        <span class="n">consecutive_time_axes</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">series</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span><span class="p">()</span> <span class="o">+</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">freq</span> <span class="o">!=</span> <span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span><span class="p">():</span>
                <span class="n">consecutive_time_axes</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">consecutive_time_axes</span><span class="p">:</span>
            <span class="n">raise_if_not</span><span class="p">(</span>
                <span class="n">ignore_time_axis</span><span class="p">,</span>
                <span class="s2">&quot;When concatenating over time axis, all series need to be contiguous &quot;</span>
                <span class="s2">&quot;in the time dimension. Use `ignore_time_axis=True` to override &quot;</span>
                <span class="s2">&quot;this behavior and concatenate the series by extending the time axis &quot;</span>
                <span class="s2">&quot;of the first series.&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="kn">from</span> <span class="nn">darts.utils.timeseries_generation</span> <span class="kn">import</span> <span class="n">generate_index</span>

            <span class="n">tindex</span> <span class="o">=</span> <span class="n">generate_index</span><span class="p">(</span>
                <span class="n">start</span><span class="o">=</span><span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span><span class="p">(),</span>
                <span class="n">freq</span><span class="o">=</span><span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">freq_str</span><span class="p">,</span>
                <span class="n">length</span><span class="o">=</span><span class="n">da_concat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">da_concat</span> <span class="o">=</span> <span class="n">da_concat</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="n">time_dim_name</span><span class="p">:</span> <span class="n">tindex</span><span class="p">})</span>
            <span class="n">da_concat</span> <span class="o">=</span> <span class="n">_xarray_with_attrs</span><span class="p">(</span>
                <span class="n">da_concat</span><span class="p">,</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">static_covariates</span><span class="p">,</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hierarchy</span>
            <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">time_axes_equal</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span>
                <span class="nb">map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">has_same_time_as</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">zip</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">series</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">time_axes_ok</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">time_axes_equal</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_time_axis</span>
            <span class="k">else</span> <span class="nb">len</span><span class="p">({</span><span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">})</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="p">)</span>

        <span class="n">raise_if_not</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">time_axes_ok</span>
                <span class="ow">and</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">sample_axis_equal</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="p">(</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">component_axis_equal</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">),</span>
            <span class="s2">&quot;When concatenating along component or sample dimensions, all the series must have the same time &quot;</span>
            <span class="s2">&quot;axes (unless `ignore_time_axis` is True), or time axes of same lengths (if `ignore_time_axis` is &quot;</span>
            <span class="s2">&quot;True), and all series must have the same number of samples (if concatenating along component &quot;</span>
            <span class="s2">&quot;dimension), or the same number of components (if concatenating along sample dimension).&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># we concatenate raw values using Numpy because not all series might have the same time axes</span>
        <span class="c1"># and joining using xarray.concatenate() won&#39;t work in some cases</span>
        <span class="n">concat_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">da</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">da</span> <span class="ow">in</span> <span class="n">da_sequence</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># When concatenating along component dimension, we have to re-create a component index</span>
            <span class="c1"># we rely on the factory method of TimeSeries to disambiguate names later on if needed.</span>
            <span class="n">component_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span>
                <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ts</span><span class="o">.</span><span class="n">components</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">series</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cl</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">static_covariates</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">_concat_static_covs</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_static_covariates</span>
                <span class="k">else</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">static_covariates</span>
            <span class="p">)</span>
            <span class="n">hierarchy</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">drop_hierarchy</span> <span class="k">else</span> <span class="n">_concat_hierarchy</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">component_index</span> <span class="o">=</span> <span class="n">da_sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">static_covariates</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">static_covariates</span>
            <span class="n">hierarchy</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hierarchy</span>

        <span class="n">da_concat</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">concat_vals</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">time_dim_name</span><span class="p">,)</span> <span class="o">+</span> <span class="n">DIMS</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="n">time_dim_name</span><span class="p">:</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">time_index</span><span class="p">,</span> <span class="n">DIMS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">component_index</span><span class="p">},</span>
            <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="n">STATIC_COV_TAG</span><span class="p">:</span> <span class="n">static_covariates</span><span class="p">,</span> <span class="n">HIERARCHY_TAG</span><span class="p">:</span> <span class="n">hierarchy</span><span class="p">},</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">TimeSeries</span><span class="o">.</span><span class="n">from_xarray</span><span class="p">(</span><span class="n">da_concat</span><span class="p">,</span> <span class="n">fill_missing_dates</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_finite_rows_boundaries</span><span class="p">(</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">how</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the indices of the first rows containing finite values starting from the start and the end of the first</span>
<span class="sd">    dimension of the ndarray.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    values</span>
<span class="sd">        1D, 2D or 3D numpy array where the first dimension correspond to entries/rows, and the second to components/</span>
<span class="sd">        columns</span>
<span class="sd">    how</span>
<span class="sd">        Define if the entries containing `NaN` in all the components (&#39;all&#39;) or in any of the components (&#39;any&#39;)</span>
<span class="sd">        should be stripped. Default: &#39;all&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">raise_if</span><span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Expected 1D to 3D array, received </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">D array&quot;</span><span class="p">,</span> <span class="n">logger</span>
    <span class="p">)</span>

    <span class="n">finite_rows</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">finite_rows</span> <span class="o">=</span> <span class="n">finite_rows</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;any&quot;</span><span class="p">:</span>
            <span class="n">finite_rows</span> <span class="o">=</span> <span class="n">finite_rows</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">finite_rows</span> <span class="o">=</span> <span class="n">finite_rows</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raise_log</span><span class="p">(</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;`how` parameter value not recognized, should be either &#39;all&#39; or &#39;any&#39;, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;received </span><span class="si">{</span><span class="n">how</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="n">first_finite_row</span> <span class="o">=</span> <span class="n">finite_rows</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
    <span class="n">last_finite_row</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">finite_rows</span><span class="p">)</span> <span class="o">-</span> <span class="n">finite_rows</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">first_finite_row</span><span class="p">,</span> <span class="n">last_finite_row</span>
</pre></div>

              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2020 - 2023, Unit8 SA (Apache 2.0 License).<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.3.2.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>